\documentclass{article}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc} % correct font encoding to enable search in pdf
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{url}
\usepackage[a4paper,hmargin=1in,vmargin=1.25in]{geometry}  
\usepackage[pdfborder={0 0 0.5},
            colorlinks=false]{hyperref}

\newcommand{\tttimes}{\mathop{\texttt{*}}}

\newcommand{\nonterm}[1]{\langle\textrm{#1}\rangle}
\newcommand{\seq}[1]{\textrm{seq}\nonterm{#1}}
\newcommand{\neseq}[1]{\textrm{seq}^+\nonterm{#1}}

% --------------------------------------------------------------------- %
% Typesetting definitions:              Sample output:                  %
%                                                                       %
% \begin{defn}                                                          %
% \categ{M,N}{terms}\\          M, N ::=        terms           %
% \entry{x}{variable}\\                   x               variable      %
% \entry{M\ N}{application}\\             M N             application   %
% \entry{\lambda x.\ M}{abstraction}      \x.M            abstraction   %
% \end{defn}                                                            %
%                                                                       %
% This is a tabbing environment; the last entry should have no \\.      %
% --------------------------------------------------------------------- %

\newenvironment{defn}{\begin{tabbing}
  \hspace{1.5em} \= \hspace{.27\linewidth - 1.5em} \= \hspace{1.5em} \= \kill
%  \hbra\\[-.8ex]
  }{
%\\[-.8ex]\hket
  \end{tabbing}}
\newcommand{\entry}[2]{\>$#1$\>\>#2}
\newcommand{\clause}[2]{$#1$\>\>#2}
\newcommand{\categ}[2]{\clause{#1::=}{#2}}
\newcommand{\subclause}[1]{\>\>\>#1}

\begin{document}

\title{CryptoVerif\\
Computationally Sound, Automatic\\
Cryptographic Protocol Verifier\\
User Manual}

\author{Bruno Blanchet and David Cad{\'e}\\
INRIA Paris-Rocquencourt, France}

\maketitle

\tableofcontents

\section{Introduction}

This manual describes the input syntax and output of our cryptographic
protocol verifier. It does not describe the internal algorithms used
in the system. These algorithms have been described in research
papers~\cite{Blanchet06,BlanchetEPrint05,Blanchet06b,BlanchetPointchevalEPrint06}
that can be downloaded at

\centerline{{\tt
http://prosecco.gforge.inria.fr/personal/bblanche/publications/index.html}.}

The goal of our protocol verifier is to prove security properties
of protocols in the computational model. The input file describes
the considered security protocol, the hypotheses on the cryptographic
primitives used in the protocol, and security properties to prove.

\section{Command Line}

The syntax of the command line is as follows:
\begin{quote}
$\texttt{./cryptoverif }[options]\ \nonterm{filename}$
\end{quote}
where $\nonterm{filename}$ is the name of the input file.
The options can be:
\begin{itemize}

\item $\texttt{-in }\nonterm{frontend}$: Chooses the frontend to use
by CryptoVerif. $\nonterm{frontend}$ can be either \texttt{channels}
(the default) or \texttt{oracles}. The \texttt{channels} frontend
uses a calculus inspired by the pi calculus, described 
in Section~\ref{sec:channels} and in~\cite{Blanchet06,BlanchetEPrint05}.
The \texttt{oracles} frontend uses a calculus closer to cryptographic
games, described in Section~\ref{sec:oracles} and 
in~\cite{Blanchet06b,BlanchetPointchevalEPrint06}.
By default, CryptoVerif uses the \texttt{oracles} frontend when the input
$\nonterm{filename}$ ends with \texttt{.ocv}, and otherwise it uses the
\texttt{channels} frontend.

\item $\texttt{-lib }\nonterm{filename}$: Sets the name of the library
  file (by default $\texttt{default}$) which is loaded by the system
  before reading the input file. In the \texttt{channels} front-end,
  the loaded file is $\nonterm{filename}\texttt{.cvl}$; in the
  \texttt{oracles} front-end, it is
  $\nonterm{filename}\texttt{.ocvl}$. The library file typically
  contains default declarations useful for all protocols.

\item $\texttt{-oproof }\nonterm{filename}$: Output the proof
in the given file name, instead of displaying it on the standard output.

\item $\texttt{-tex }\nonterm{filename}$: Activates TeX output, and sets
the output file name. In this mode, CryptoVerif outputs a TeX version
of the proof, in the given file.

\item $\texttt{-impl}$: Instead of proving the protocol, generate an
  implementation in OCaml corresponding to the modules defined in the input
  file.

\item $\texttt{-o }\nonterm{directory}$: If the $\texttt{-impl}$ option
  is given, outputs the implementation files in the given directory.

\end{itemize}

\newif\ifchannels

\section{\texttt{channels} Front-end}\label{sec:channels}

\channelstrue
\input{frontend}

\section{\texttt{oracles} Front-end}\label{sec:oracles}

\channelsfalse
\input{ofrontend}

\section{Summary of the Main Differences between the two Front-ends}

The main difference between the two front-ends is that the \texttt{oracles}
front-end uses oracles while the \texttt{channels} front-end uses channels.
So we have essentially the following correspondence:
\begin{center}
\begin{tabular}{l|l}
\texttt{channels}&\texttt{oracles}\\
\hline
input process& oracle definition\\
output process& oracle body\\
$\texttt{newChannel }c$& $\texttt{newOracle }O$\\
$\texttt{in(}c\texttt{, (}x_1:T_1, \ldots, x_l:T_l\texttt{));}P$&$O\texttt{(}x_1:T_1, \ldots, x_l:T_l\texttt{) := }P$\\
$\texttt{out(}c\texttt{, (}M_1, \ldots, M_l\texttt{));}Q$&$\texttt{return(}M_1, \ldots, M_l\texttt{);}Q$\\
%$\texttt{yield}$&$\texttt{end}$\\
\end{tabular}
\end{center}
The \texttt{newChannel} or \texttt{newOracle} instruction does not appear
in processes, but appears in the evaluation time of contexts.
In the \texttt{channels} front-end, channels must be declared by a
\texttt{channel} declaration. There is no such declaration in the 
\texttt{oracles} front-end.

Finally, both front-ends accept two syntaxes for replication,
generation of random numbers, and assignments. However, 
the default syntax for the display differs:
\begin{center}
\begin{tabular}{l|l}
display in \texttt{channels}&display in \texttt{oracles}\\
\hline
$\texttt{!}i\texttt{<=}N\ Q$& $\texttt{foreach }i\texttt{<=}N\texttt{ do }Q$\\
$\texttt{new }x\texttt{:}T\texttt{; }P$&$x\texttt{ <-R }T\texttt{; }P$\\
$\texttt{let }x\texttt{:}T\texttt{ = }M\texttt{ in }P$&$x\texttt{:}T\texttt{ <- }M\texttt{; }P$\\
\end{tabular}
\end{center}
The assignment $x\texttt{:}T\texttt{ <- }M$ can be
used only for assigning a variable; when a pattern occurs instead
of the variable $x$, one has to use the \texttt{let} instruction.

\section{Predefined cryptographic primitives}\label{sect:prim}

\newcommand{\vn}[1]{\mathit{#1}}
\newcommand{\ab}{\allowbreak}

\sloppy

A number of standard cryptographic primitives are predefined in
CryptoVerif.  The definitions of these primitives are given as macros
in the library file \texttt{default.cvl} (or \texttt{default.ocvl} for
the \texttt{oracles} front-end) that is automatically loaded at
startup.  The user does not need to redefine these primitives, he can
just expand the corresponding macro. The examples contained in the library
can be used as a basis in order to build definitions of new primitives, by copying
and modifying them as desired. Here is a list of the predefined primitives.
\begin{itemize}

\item $\texttt{expand IND\_CPA\_sym\_enc(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc}$$,
$  $\vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}\texttt{).}$ defines a
  IND-CPA (indistinguishable under chosen plaintext attacks)
  probabilistic symmetric encryption scheme.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{enc}(\vn{cleartext}, \vn{key}): \vn{ciphertext}$ is the encryption function. Internally, it generates random coins, so that it is probabilistic.

   $\vn{dec}(\vn{ciphertext}, \vn{key}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$ and the probability $\vn{Penc}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalence named $\texttt{ind\_cpa}(\vn{enc})$
   for use in the \texttt{crypto} command in interactive proofs
   (see Section~\ref{sec:interact}).

\item $\texttt{expand IND\_CPA\_sym\_enc\_all\_args(}\vn{key}$,
  $\vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc\_seed}$, $\vn{enc}$, $\vn{enc\_r}$, $\vn{enc\_r}'$,
  $\vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}\texttt{).}$ is similar to the above,
  with three additional arguments. 

  $\vn{enc\_seed}$ is the type of random coins for encryption, must be \texttt{bounded}.

  $\vn{enc\_r}(\vn{cleartext}, \vn{key}, \vn{enc\_seed}): \vn{ciphertext}$ is the encryption function that takes coins as argument (instead of generating them internally).

  $\vn{enc\_r}'$ is the symbol that replaces $\vn{enc\_r}$ after game transformation.

\item $\texttt{expand IND\_CPA\_sym\_enc\_nonce(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{nonce}$, $\vn{enc}$$,
$  $\vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}\texttt{).}$ defines a
  IND-CPA (indistinguishable under chosen plaintext attacks)
  probabilistic symmetric encryption scheme using a nonce 
   (which must have a different value in each call to encryption)
   instead of random coins generated by encryption.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{nonce}$ is the type of nonces.

   $\vn{enc}(\vn{cleartext}, \vn{key}, \vn{nonce}): \vn{ciphertext}$ is the encryption function. 

   $\vn{dec}(\vn{ciphertext}, \vn{key}, \vn{nonce}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$, $\vn{nonce}$ and the probability $\vn{Penc}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalence named $\texttt{ind\_cpa}(\vn{enc})$
   for use in the \texttt{crypto} command in interactive proofs
   (see Section~\ref{sec:interact}).

\item $\texttt{expand IND\_CPA\_sym\_enc\_nonce\_all\_args(}\vn{key}$,
  $\vn{cleartext}$, $\vn{ciphertext}$, $\vn{nonce}$, $\vn{enc}$, $\vn{enc}'$,
  $\vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}\texttt{).}$ is similar to the above,
  with one additional argument: $\vn{enc}'$ is the symbol that replaces $\vn{enc}$ after game transformation.

\item $\texttt{expand IND\_CPA\_INT\_CTXT\_sym\_enc(}\vn{key}$,
  $\vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc}$,
  $\vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$ defines a
  IND-CPA (indistinguishable under chosen plaintext attacks) and INT-CTXT (ciphertext integrity)
  probabilistic symmetric encryption scheme.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{enc}(\vn{cleartext}, \vn{key}): \vn{ciphertext}$ is the encryption function. Internally, it generates random coins, so that it is probabilistic.

   $\vn{dec}(\vn{ciphertext}, \vn{key}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$.

  $\vn{Pencctxt}(t, N, N', l, l')$ is the probability of breaking the
  INT-CTXT property in time $t$ for one key, $N$ encryption queries,
  $N'$ decryption queries with cleartexts of length at most $l$ and
  ciphertexts of length at most $l'$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$ and the probabilities $\vn{Penc}$ and $\vn{Pencctxt}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named $\texttt{ind\_cpa}(\vn{enc})$,
   $\texttt{int\_ctxt}(\vn{enc})$, and $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ 
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}). 
   The first equivalence corresponds to the
   IND-CPA property, the last two to the INT-CTXT property.
   The equivalence $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ is used when the
   key may be corrupted. It is applied only manually.
   The equivalence $\texttt{int\_ctxt}(\vn{enc})$
   should generally be applied before $\texttt{ind\_cpa}(\vn{enc})$,
   because $\texttt{int\_ctxt}(\vn{enc})$ eliminates the decryption oracle.

\item $\texttt{expand IND\_CPA\_INT\_CTXT\_sym\_enc\_all\_args(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc\_seed}$, $\vn{enc}$, $\vn{enc\_r}$, $\vn{enc\_r}'$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$  is similar to the above,
  with three additional arguments. 

  $\vn{enc\_seed}$ is the type of random coins for encryption, must be \texttt{bounded}.

  $\vn{enc\_r}(\vn{cleartext}, \vn{key}, \vn{enc\_seed}): \vn{ciphertext}$ is the encryption function that takes coins as argument (instead of generating them internally).

  $\vn{enc\_r}'$ is the symbol that replaces $\vn{enc\_r}$ after game transformation.

\item $\texttt{expand IND\_CPA\_INT\_CTXT\_sym\_enc\_nonce(}\vn{key}$,
  $\vn{cleartext}$, $\vn{ciphertext}$, $\vn{nonce}$, $\vn{enc}$,
  $\vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$ defines a
  IND-CPA (indistinguishable under chosen plaintext attacks) and INT-CTXT (ciphertext integrity)
  probabilistic symmetric encryption scheme using a nonce 
   (which must have a different value in each call to encryption)
   instead of random coins generated by encryption.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{nonce}$ is the type of nonces.

   $\vn{enc}(\vn{cleartext}, \vn{key}, \vn{nonce}): \vn{ciphertext}$ is the encryption function.

   $\vn{dec}(\vn{ciphertext}, \vn{key}, \vn{nonce}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$.

  $\vn{Pencctxt}(t, N, N', l, l')$ is the probability of breaking the
  INT-CTXT property in time $t$ for one key, $N$ encryption queries,
  $N'$ decryption queries with cleartexts of length at most $l$ and
  ciphertexts of length at most $l'$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$, $\vn{nonce}$ and the probabilities $\vn{Penc}$ and $\vn{Pencctxt}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named $\texttt{ind\_cpa}(\vn{enc})$,
   $\texttt{int\_ctxt}(\vn{enc})$, and $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ 
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}). 
   The first equivalence corresponds to the
   IND-CPA property, the last two to the INT-CTXT property.
   The equivalence $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ is used when the
   key may be corrupted. It is applied only manually.
   The equivalence $\texttt{int\_ctxt}(\vn{enc})$
   should generally be applied before $\texttt{ind\_cpa}(\vn{enc})$,
   because $\texttt{int\_ctxt}(\vn{enc})$ eliminates the decryption oracle.

\item $\texttt{expand IND\_CPA\_INT\_CTXT\_sym\_enc\_nonce\_all\_args(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{nonce}$, $\vn{enc}$, $\vn{enc}'$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$  is similar to the above,
  with one additional argument: $\vn{enc}'$ is the symbol that replaces $\vn{enc}$ after game transformation.

\item $\texttt{expand AEAD(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{add\_data}$, $\vn{enc}$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$ defines an
authenticated encryption scheme with additional data.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{add\_data}$ is the type of additional data.

   $\vn{enc}(\vn{cleartext}, \vn{add\_data}, \vn{key}): \vn{ciphertext}$ is the encryption function. Internally, it generates random coins, so that it is probabilistic.

   $\vn{dec}(\vn{ciphertext}, \vn{add\_data}, \vn{key}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$.

  $\vn{Pencctxt}(t, N, N', l, l', \vn{ld}, \vn{ld}')$ is the probability of
  breaking the INT-CTXT property in time $t$ for one key, $N$
  encryption queries, $N'$ decryption queries with cleartexts of
  length at most $l$ and ciphertexts of length at most $l'$,
  additional data for encryption of length at most $\vn{ld}$, and
  additional data for decryption of length at most $\vn{ld}'$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$, $\vn{add\_data}$ and the probabilities $\vn{Penc}$ and $\vn{Pencctxt}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named $\texttt{ind\_cpa}(\vn{enc})$,
   $\texttt{int\_ctxt}(\vn{enc})$, and $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ 
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}). 
   The first equivalence corresponds to the
   IND-CPA property, the last two to the INT-CTXT property.
   The equivalence $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ is used when the
   key may be corrupted. It is applied only manually.
   The equivalence $\texttt{int\_ctxt}(\vn{enc})$
   should generally be applied before $\texttt{ind\_cpa}(\vn{enc})$,
   because $\texttt{int\_ctxt}(\vn{enc})$ eliminates the decryption oracle.

\item $\texttt{expand AEAD\_all\_args(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{add\_data}$, $\vn{enc\_seed}$, $\vn{enc}$, $\vn{enc\_r}$, $\vn{enc\_r}'$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$ is similar to the above,
  with three additional arguments. 

  $\vn{enc\_seed}$ is the type of random coins for encryption, must be \texttt{bounded}.

  $\vn{enc\_r}(\vn{cleartext}, \vn{add\_data}, \vn{key}, \vn{enc\_seed}): \vn{ciphertext}$ is the encryption function that takes coins as argument (instead of generating them internally).

  $\vn{enc\_r}'$ is the symbol that replaces $\vn{enc\_r}$ after game transformation.


\item $\texttt{expand AEAD\_nonce(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{add\_data}$, $\vn{nonce}$, $\vn{enc}$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$ defines an
authenticated encryption scheme with additional data, using a nonce that must have a different
value in each call to encryption. A typical example is AES-GCM.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{add\_data}$ is the type of additional data.

   $\vn{nonce}$ is the type of nonces.

   $\vn{enc}(\vn{cleartext}, \vn{add\_data}, \vn{key}, \vn{nonce}): \vn{ciphertext}$ is the encryption function. 

   $\vn{dec}(\vn{ciphertext}, \vn{add\_data}, \vn{key}, \vn{nonce}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$.

  $\vn{Pencctxt}(t, N, N', l, l', \vn{ld}, \vn{ld}')$ is the probability of
  breaking the INT-CTXT property in time $t$ for one key, $N$
  encryption queries, $N'$ decryption queries with cleartexts of
  length at most $l$ and ciphertexts of length at most $l'$,
  additional data for encryption of length at most $\vn{ld}$, and
  additional data for decryption of length at most $\vn{ld}'$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$, $\vn{add\_data}$, $\vn{nonce}$ and the probabilities $\vn{Penc}$ and $\vn{Pencctxt}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named $\texttt{ind\_cpa}(\vn{enc})$,
   $\texttt{int\_ctxt}(\vn{enc})$, and $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ 
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}). 
   The first equivalence corresponds to the
   IND-CPA property, the last two to the INT-CTXT property.
   The equivalence $\texttt{int\_ctxt\_corrupt}(\vn{enc})$ is used when the
   key may be corrupted. It is applied only manually.
   The equivalence $\texttt{int\_ctxt}(\vn{enc})$
   should generally be applied before $\texttt{ind\_cpa}(\vn{enc})$,
   because $\texttt{int\_ctxt}(\vn{enc})$ eliminates the decryption oracle.

\item $\texttt{expand AEAD\_nonce\_all\_args(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{add\_data}$, $\vn{nonce}$, $\vn{enc}$, $\vn{enc}'$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencctxt}\texttt{).}$ is similar to the above with one additional argument.

  $\vn{enc}'$ is the symbol that replaces $\vn{enc}$ after game transformation.


\item $\texttt{expand IND\_CCA2\_sym\_enc(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc}$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}\texttt{).}$ defines a
  IND-CCA2 (indistinguishable under adaptive chosen ciphertext attacks)
  probabilistic symmetric encryption scheme.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{enc}(\vn{cleartext}, \vn{key}): \vn{ciphertext}$ is the encryption function. Internally, it generates random coins, so that it is probabilistic.

   $\vn{dec}(\vn{ciphertext}, \vn{key}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, \vn{Nu}, N', l, l')$ is the probability of breaking the
  IND-CCA2 property in time $t$ for one key, $N$ encryption queries that are 
  different in both sides of the IND-CCA2 equivalence, 
  $\vn{Nu}$ encryption queries that are the same in both side of the IND-CCA2 equivalence, $N'$
  decryption queries with cleartexts of length at most $l$ and
  ciphertexts of length at most $l'$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$ and the probability $\vn{Penc}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named
   $\texttt{ind\_cca2}(\vn{enc})$ and
   $\texttt{ind\_cca2\_partial}(\vn{enc})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}). While the
   equivalence $\texttt{ind\_cca2}(\vn{enc})$ replaces all cleartexts
   with zeroes, the equivalence
   $\texttt{ind\_cca2\_partial}(\vn{enc})$ replaces only some of them
   with zeroes. The latter equivalence can be applied only manually.
   The user should map the occurrences of encryption that he wants to
   transform to oracle $\vn{Oenc}$, the ones he wants to leave unchanged to
   oracle $\vn{Oenc\_unchanged}$, and the ones that have already been transformed
   by a previous application of this equivalence to oracle $\vn{Oenc\_unchanged}'$.

\item $\texttt{expand IND\_CCA2\_sym\_enc\_all\_args(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc\_seed}$, $\vn{enc}$, $\vn{enc\_r}$, $\vn{enc\_r}'$,
$  \vn{dec}$, $\vn{dec}'$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}\texttt{).}$ is similar to the above,
  with four additional arguments. 

  $\vn{enc\_seed}$ is the type of random coins for encryption, must be \texttt{bounded}.

  $\vn{enc\_r}(\vn{cleartext}, \vn{key}, \vn{enc\_seed}): \vn{ciphertext}$ is the encryption function that takes coins as argument (instead of generating them internally).

  $\vn{enc\_r}'$ and $\vn{dec}'$ are the symbols that replace $\vn{enc\_r}$ and $\vn{dec}$ respectively after game transformation.


\item $\texttt{expand INT\_PTXT\_sym\_enc(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc}$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Pencptxt}\texttt{).}$ defines an INT-PTXT (plaintext integrity)
  probabilistic symmetric encryption scheme.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{enc}(\vn{cleartext}, \vn{key}): \vn{ciphertext}$ is the encryption function. Internally, it generates random coins, so that it is probabilistic.

   $\vn{dec}(\vn{ciphertext}, \vn{key}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

  $\vn{Pencptxt}(t, N, N', \vn{Nu}', l, l')$ is the probability of breaking the
  INT-PTXT property in time $t$ for one key, $N$ encryption queries, $N'$
  decryption queries that are modified by the transformation, and 
  $\vn{Nu}'$ decryption queries that are left unchanged by the transformation,
  with cleartexts of length at most $l$ and
  ciphertexts of length at most $l'$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$ and the probability $\vn{Pencptxt}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, and $\vn{injbot}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named
   $\texttt{int\_ptxt}(\vn{enc})$ and
   $\texttt{int\_ptxt\_corrupt\_partial}(\vn{enc})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).  While
   the equivalence $\texttt{ind\_ptxt}(\vn{enc})$ replaces all
   decryption with lookups in encryption queries, the equivalence
   $\texttt{ind\_ptxt\_corrupt\_partial}(\vn{enc})$ may replace only some of them
   and supports corruption of the key. 
   The latter equivalence can be applied only manually.
   To transform only some occurrences of decryption, 
   the user should map the occurrences of decryption that he wants to
   transform to oracle $\vn{Odec}$, the ones he wants to leave
   unchanged to oracle $\vn{Odec\_unchanged}$, and the ones that have
   already been transformed by a previous application of this
   equivalence to oracle $\vn{Odec\_unchanged}'$.

\item $\texttt{expand INT\_PTXT\_sym\_enc\_all\_args(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc\_seed}$, $\vn{enc}$, $\vn{enc\_r}$,
$  \vn{dec}$, $\vn{dec}'$, $\vn{injbot}$, $\vn{Pencptxt}\texttt{).}$ is similar to the above,
  with three additional arguments. 

  $\vn{enc\_seed}$ is the type of random coins for encryption, must be \texttt{bounded}.

  $\vn{enc\_r}(\vn{cleartext}, \vn{key}, \vn{enc\_seed}): \vn{ciphertext}$ is the encryption function that takes coins as argument (instead of generating them internally).

  $\vn{dec}'$ is the symbol that replaces $\vn{dec}$ after game transformation.

\item $\texttt{expand IND\_CCA2\_INT\_PTXT\_sym\_enc(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc}$,
$  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencptxt}\texttt{).}$ defines a
  IND-CCA2 (indistinguishable under adaptive chosen ciphertext attacks) and INT-PTXT (plaintext integrity)
  probabilistic symmetric encryption scheme.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{enc}(\vn{cleartext}, \vn{key}): \vn{ciphertext}$ is the encryption function. Internally, it generates random coins, so that it is probabilistic.

   $\vn{dec}(\vn{ciphertext}, \vn{key}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

  $\vn{Penc}(t, N, \vn{Nu}, N', l, l')$ is the probability of breaking the
  IND-CCA2 property in time $t$ for one key, $N$ encryption queries that are 
  different in both sides of the IND-CCA2 equivalence, 
  $\vn{Nu}$ encryption queries that are the same in both side of the IND-CCA2 equivalence, $N'$
  decryption queries with cleartexts of length at most $l$ and
  ciphertexts of length at most $l'$.

  $\vn{Pencptxt}(t, N, N', \vn{Nu}', l, l')$ is the probability of breaking the
  INT-PTXT property in time $t$ for one key, $N$ encryption queries, $N'$
  decryption queries that are modified by the transformation, and 
  $\vn{Nu}'$ decryption queries that are left unchanged by the transformation,
  with cleartexts of length at most $l$ and
  ciphertexts of length at most $l'$.

   The types $\vn{key}$, $\vn{cleartext}$,
   $\vn{ciphertext}$ and the probabilities $\vn{Penc}$ and $\vn{Pencptxt}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named
   $\texttt{ind\_cca2}(\vn{enc})$,
   $\texttt{ind\_cca2\_after\_int\_ptxt}(\vn{enc})$,
   $\texttt{ind\_cca2\_partial}(\vn{enc})$,
   $\texttt{int\_ptxt}(\vn{enc})$,
   $\texttt{int\_ptxt\_after\_ind\_cca2}(\vn{enc})$, and
   $\texttt{int\_ptxt\_corrupt\_partial}(\vn{enc})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}). 
   %
   The first three correspond to the IND-CCA2 property, the last three
   to the INT-PTXT property. The equivalence
   $\texttt{ind\_cca2}(\vn{enc})$ can be applied before applying the
   INT-PTXT property, while
   $\texttt{ind\_cca2\_after\_int\_ptxt}(\vn{enc})$ can be applied
   after applying the INT-PTXT property. Similarly, the equivalence
   $\texttt{int\_ptxt}(\vn{enc})$ can be applied before applying the
   IND-CCA2 property, while
   $\texttt{int\_ptxt\_after\_ind\_cca2}(\vn{enc})$ can be applied
   after applying the IND-CCA2 property.
   %
   The equivalences $\texttt{ind\_cca2\_partial}(\vn{enc})$ and
   $\texttt{int\_ptxt\_corrupt\_partial}(\vn{enc})$ may transform only some
   occurrences of encryption and/or decryption, and
   $\texttt{int\_ptxt\_corrupt\_partial}(\vn{enc})$ supports corruption
   of the key.  They can be applied only manually, in any order.
   %
   For $\texttt{ind\_cca2\_partial}(\vn{enc})$, the user should map
   the occurrences of encryption that he wants to transform to oracle
   $\vn{Oenc}$, the ones he wants to leave unchanged to oracle
   $\vn{Oenc\_unchanged}$.
   %
   For $\texttt{int\_ptxt\_partial}(\vn{enc})$, the user should map
   the occurrences of decryption that he wants to transform to oracle
   $\vn{Odec}$, the ones he wants to leave unchanged to oracle
   $\vn{Odec\_unchanged}$.

   CryptoVerif often needs manual guidance with this property,
   because it does not know which property (IND-CCA2 or INT-PTXT)
   to apply first. Moreover, when empty plaintexts are not allowed,
   IND-CCA2 and INT-PTXT is equivalent to IND-CPA and INT-CTXT, 
   which is much easier to use for CryptoVerif, so we recommend
   using the latter property when possible.

\item $\texttt{expand IND\_CCA2\_INT\_PTXT\_sym\_enc\_all\_args(}\vn{key}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc\_seed}$, $\vn{enc}$, $\vn{enc\_r}$, $\vn{enc\_r}'$,
$  \vn{dec}$, $ \vn{dec}'$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pencptxt}\texttt{).}$ is similar to the above,
  with four additional arguments. 

  $\vn{enc\_seed}$ is the type of random coins for encryption, must be \texttt{bounded}.

  $\vn{enc\_r}(\vn{cleartext}, \vn{key}, \vn{enc\_seed}): \vn{ciphertext}$ is the encryption function that takes coins as argument (instead of generating them internally).

  $\vn{enc\_r}'$ and $\vn{dec}'$ are the symbols that replace $\vn{enc\_r}$ and $\vn{dec}$ respectively after game transformation.


\item $\texttt{expand SPRP\_cipher(}\vn{key}$,
$  \vn{blocksize}$, $\vn{enc}$, $\vn{dec}$, $\vn{Penc}\texttt{).}$
  defines a SPRP (super-pseudo-random permutation) deterministic
  symmetric encryption scheme.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{blocksize}$ is the type of cleartexts and ciphertexts, 
   must be \texttt{fixed} and \texttt{large}.
   (The modeling of SPRP block ciphers is not perfect in that, in
   order to encrypt a new message, one chooses a fresh random number,
   not necessarily different from previously generated random
   numbers. Then CryptoVerif needs to eliminate collisions between
   those random numbers, so $\vn{blocksize}$ must really be
   \texttt{large}.)

   $\vn{enc}(\vn{blocksize}, \vn{key}): \vn{blocksize}$ is the encryption function.

   $\vn{dec}(\vn{blocksize}, \vn{key}): \vn{blocksize}$ is the
  decryption function.

  $\vn{Penc}(t, N, N')$ is the probability of breaking the SPRP
  property in time $t$ for one key, $N$ encryption queries, and $N'$
  decryption queries.

  The types $\vn{key}$, $\vn{blocksize}$ and the
  probability $\vn{Penc}$ must be declared before this macro is
  expanded. The functions $\vn{enc}$ and $\vn{dec}$ are
  declared by this macro. They must not be declared elsewhere, and
  they can be used only after expanding the macro.

   This macro defines the equivalence named $\texttt{sprp}(\vn{enc})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}).

\item $\texttt{expand PRP\_cipher(}\vn{key}$,
$  \vn{blocksize}$, $\vn{enc}$, $\vn{dec}$, $\vn{Penc}\texttt{).}$
  defines a PRP (pseudo-random permutation) deterministic
  symmetric encryption scheme.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{enc}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{blocksize}$ is the type of cleartexts and ciphertexts, must be
   \texttt{fixed} and \texttt{large}.
   (The modeling of PRP block ciphers is not perfect in that, in order
   to encrypt a new message, one chooses a fresh random number, not
   necessarily different from previously generated random numbers. In
   other words, we model a PRF rather than a PRP, and apply the
   PRF/PRP switching lemma to make sure that this is sound. Then
   CryptoVerif needs to eliminate collisions between those random
   numbers, so $\vn{blocksize}$ must really be \texttt{large}.)

   $\vn{enc}(\vn{blocksize}, \vn{key}): \vn{blocksize}$ is the encryption function.

   $\vn{dec}(\vn{blocksize}, \vn{key}): \vn{blocksize}$ is the
  decryption function.

   $\vn{Penc}(t, N)$ is the probability of breaking the PRP property
   in time $t$ for one key and $N$ encryption queries.

   The types $\vn{key}$, $\vn{blocksize}$ and the probability $\vn{Penc}$ must
   be declared before this macro is expanded. The functions
   $\vn{enc}$ and $\vn{dec}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalence named $\texttt{prp}(\vn{enc})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}).

\item $\texttt{expand ICM\_cipher(}\vn{cipherkey}$, $\vn{key}$, $\vn{blocksize}$, $\vn{enc}$,
$   \vn{dec}$, $\vn{enc\_dec\_oracle}$, $\vn{qE}$, $\vn{qD}\texttt{).}$
   defines a block cipher in the ideal cipher model.

   $\vn{cipherkey}$ is the type of keys that correspond to the choice of the scheme, must be \texttt{bounded} or \texttt{nonuniform}, typically \texttt{fixed}.

   $\vn{key}$ is the type of keys (typically \texttt{large}).

   $\vn{blocksize}$ is type of the input and output of the cipher, 
   must be \texttt{bounded} or \texttt{nonuniform} (to be able to 
   generate random numbers from it; typically \texttt{fixed}), and \texttt{large}.
   (The modeling of the ideal cipher model is not perfect in that, in
   order to encrypt a new message, one chooses a fresh random number,
   not necessarily different from previously generated random
   numbers. Then CryptoVerif needs to eliminate collisions between
   those random numbers, so blocksize must really be \texttt{large}.)

   $\vn{enc}(\vn{cipherkey}, \vn{blocksize}, \vn{key}): \vn{blocksize}$ is the encryption function.

   $\vn{dec}(\vn{cipherkey}, \vn{blocksize}, \vn{key}): \vn{blocksize}$ is the decryption function.

   $\vn{enc\_dec\_oracle}$ is a parametric process that allows the adversary to
   call the encryption and decryption functions.
   WARNING: the encryption and decryption functions take 2 keys as
   input: the key of type cipherkey that corresponds to the choice of
   the scheme, and the normal encryption/decryption key. The cipherkey
   must be chosen once and for all at the beginning of the game and
   the encryption and decryption oracles must be made available to the
   adversary, by including the process $\vn{enc\_dec\_oracle}(\vn{ck})$
   where $\vn{ck}$ is the cipherkey.

   $\vn{qE}$ is the number of queries to the encryption oracle.

   $\vn{qD}$ is the number of queries to the decryption oracle.
 
   The types $\vn{cipherkey}$, $\vn{key}$, $\vn{blocksize}$ must be
   declared before this macro is expanded. The functions $\vn{enc}$,
   $\vn{dec}$, the process $\vn{enc\_dec\_oracle}$, and the paramters 
   $\vn{qE}$ and $\vn{qD}$ are declared by this macro. They must not be declared
   elsewhere, and they can be used only after expanding the macro.

   This macro defines the equivalence named $\texttt{icm}(\vn{enc})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}).

\item $\texttt{expand SUF\_CMA\_det\_mac(}\vn{mkey}$,
$  \vn{macinput}$, $\vn{macres}$, $\vn{mac}$, $\vn{check}$,
$  \vn{Pmac}\texttt{).}$ defines an SUF-CMA (strongly unforgeable under chosen
  message attacks) deterministic MAC (message authentication code).

  The difference between a UF-CMA (unforgeable under chosen message
  attacks) MAC and a SUF-CMA MAC is that, for a UF-CMA MAC, the
  adversary may easily forge a new MAC for a message for which he has
  already seen a MAC. Such a forgery is guaranteed to be hard for a
  SUF-CMA MAC. For deterministic MACs, the verification can be done by
  recomputing the MAC, and in this case, an UF-CMA MAC is always
  SUF-CMA, so we model only SUF-CMA deterministic MACs. This macro
  transforms tests $\vn{mac}(k,m) = m'$ into $\vn{check}(k, m, m')$,
  so that the MAC verification can also be written
  $\vn{mac}(k,m) = m'$.

  $\vn{mkey}$ is the type of keys, must be \texttt{bounded} (to be
  able to generate random numbers from it, and to talk about the
  runtime of $\vn{mac}$ without mentioning the length of the key),
  typically \texttt{fixed} and \texttt{large}.

   $\vn{macinput}$ is the type of inputs of MACs

   $\vn{macres}$ is the type of MACs.

   $\vn{mac}(\vn{macinput}, \vn{mkey}): \vn{macres}$ is the MAC function.

   $\vn{check}(\vn{macinput}, \vn{mkey}, \vn{macres}): \texttt{bool}$ is the verification function.

   $\vn{Pmac}(t, N, N', \vn{Nu}', l)$ is the probability of breaking the SUF-CMA
   property in time $t$ for one key, $N$ MAC queries, $N'$ verification
   queries modified by the transformation and $\vn{Nu}$ verification
   queries left unchanged by the transformation for messages of length at most $l$.

   The types $\vn{mkey}$, $\vn{macinput}$,
   $\vn{macres}$ and the probability $\vn{Pmac}$ must be declared
   before this macro is expanded. The functions 
   $\vn{mac}$, $\vn{check}$ are declared by this macro. They must not
   be declared elsewhere, and they can be used only after expanding
   the macro.

   This macro defines the equivalences named
   $\texttt{suf\_cma}(\vn{mac})$,
   $\texttt{suf\_cma\_corrupt}(\vn{mac})$, and
   $\texttt{suf\_cma\_corrupt\_partial}(\vn{mac})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).
   All equivalences correspond to the SUF-CMA property, but the first one 
   does not allow corruption of the secret keys while last two allow it.
   The last two equivalences are applied only manually, in particular because their automatic
   application can sometimes be done too early, when other transformations
   should first be done in order to eliminate uses of the secret keys.
   The equivalence $\texttt{suf\_cma\_corrupt\_partial}(\vn{mac})$ allows the
   user to transform only some occurrences of the MAC verification into a 
   lookup in the MACed messages. The user should map the occurrences 
   he wants to transform to the oracle $\vn{Ocheck}$ and the ones
   he does not want to transform to the oracle $\vn{Ocheck\_unchanged}$.

\item $\texttt{expand SUF\_CMA\_det\_mac\_all\_args(}\vn{mkey}$,
$  \vn{macinput}$, $\vn{macres}$, $\vn{mac}$, $\vn{mac}'$, $\vn{check}$,
$  \vn{Pmac}\texttt{).}$ is similar to the above, with one additional argument.

  $\vn{mac}'$ is the symbol that replaces $\vn{mac}$ after game transformation.

\item $\texttt{expand UF\_CMA\_proba\_mac(}\vn{mkey}$,
$  \vn{macinput}$, $\vn{macres}$, $\vn{mac}$, $\vn{check}$,
$  \vn{Pmac}\texttt{).}$ defines a UF-CMA (unforgeable under chosen
  message attacks) probabilistic MAC (message authentication code).
  The arguments are the same as for $\texttt{SUF\_CMA\_det\_mac}$, but the $\vn{mac}$ function chooses random
  coins internally so that it is probabilistic, and the verification is not done by recomputing the MAC.
   This macro defines the equivalences named
   $\texttt{uf\_cma}(\vn{mac})$,
   $\texttt{uf\_cma\_corrupt}(\vn{mac})$, and
   $\texttt{uf\_cma\_corrupt\_partial}(\vn{mac})$ for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}),
   similarly to $\texttt{SUF\_CMA\_det\_mac}$.

\item $\texttt{expand UF\_CMA\_proba\_mac\_all\_args(}\vn{mkey}$,
$  \vn{macinput}$, $\vn{macres}$, $\vn{mac\_seed}$, $\vn{mac}$, $\vn{mac\_r}$, $\vn{mac\_r}'$, $\vn{check}$, $\vn{check}'$,
$  \vn{Pmac}\texttt{).}$ is similar to the above,
  with four additional arguments. 

  $\vn{mac\_seed}$ is the type of random coins for MAC, must be \texttt{bounded}.

  $\vn{mac\_r}(\vn{macinput}, \vn{mkey}, \vn{mac\_seed}): \vn{macres}$ is the MAC function that takes coins as argument (instead of generating them internally).

  $\vn{mac\_r}'$ and $\vn{check}'$ are the symbols that replace $\vn{mac\_r}$ and $\vn{check}$ respectively after game transformation.

\item $\texttt{expand SUF\_CMA\_proba\_mac(}\vn{mkey}$,
$  \vn{macinput}$, $\vn{macres}$, $\vn{mac}$, $\vn{check}$,
$  \vn{Pmac}\texttt{).}$ defines a SUF-CMA (strongly unforgeable under
  chosen message attacks) probabilistic MAC (message authentication code). 
  The arguments are the same as for $\texttt{SUF\_CMA\_det\_mac}$, but the $\vn{mac}$ function chooses random
  coins internally so that it is probabilistic, and the verification is not done by recomputing the MAC.
  This macro defines the equivalences named
   $\texttt{suf\_cma}(\vn{mac})$,
   $\texttt{suf\_cma\_corrupt}(\vn{mac})$, and
   $\texttt{suf\_cma\_corrupt\_partial}(\vn{mac})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}),
   similarly to $\texttt{SUF\_CMA\_det\_mac}$.

\item $\texttt{expand SUF\_CMA\_proba\_mac\_all\_args(}\vn{mkey}$,
$  \vn{macinput}$, $\vn{macres}$, $\vn{mac\_seed}$, $\vn{mac}$, $\vn{mac\_r}$, $\vn{mac\_r}'$, $\vn{check}$, 
  $\vn{Pmac}\texttt{).}$ is similar to the above,
  with three additional arguments. 

  $\vn{mac\_seed}$ is the type of random coins for MAC, must be \texttt{bounded}.

  $\vn{mac\_r}(\vn{macinput}, \vn{mkey}, \vn{mac\_seed}): \vn{macres}$ is the MAC function that takes coins as argument (instead of generating them internally).

  $\vn{mac\_r}'$ is the symbol that replaces $\vn{mac\_r}$ after game transformation.

\item $\texttt{expand IND\_CCA2\_public\_key\_enc(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{skgen}$, $\vn{pkgen}$, $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Penccoll}\texttt{).}$ defines a
  IND-CCA2 (indistinguishable under adaptive chosen ciphertext attacks)
  probabilistic public-key encryption scheme.

  $\vn{keyseed}$ is the type of key seeds, must be \texttt{bounded}
  (to be able to generate random numbers from it, and to talk about
  the runtime of $\vn{pkgen}$ without mentioning the length of the key),
  typically \texttt{fixed} and \texttt{large}.

   $\vn{pkey}$ is the type of public keys, must be \texttt{bounded}.

   $\vn{skey}$ is the type of secret keys, must be \texttt{bounded}.

   $\vn{cleartext}$ is the type of cleartexts.

   $\vn{ciphertext}$ is the type of ciphertexts.

   $\vn{skgen}(\vn{keyseed}): \vn{skey}$ is the secret key generation function.

   $\vn{pkgen}(\vn{keyseed}): \vn{pkey}$ is the public key generation function.

   $\vn{enc}(\vn{cleartext}, \vn{pkey}): \vn{ciphertext}$ is the encryption function. Internally, it generates random coins, so that it is probabilistic.

   $\vn{dec}(\vn{ciphertext}, \vn{skey}): \texttt{bitstringbot}$ is the
  decryption function; it returns \texttt{bottom} when decryption
  fails.

   $\vn{injbot}(\vn{cleartext}): \texttt{bitstringbot}$ is the natural
  injection from $\vn{cleartext}$ to \texttt{bitstringbot}.

   $\vn{Z}(\vn{cleartext}): \vn{cleartext}$ is the function that
  returns for each cleartext a cleartext of the same length consisting
  only of zeroes.

   $\vn{Penc}(t, N)$ is the probability of breaking the IND-CCA2 property
   in time $t$ for one key and $N$ decryption queries.

   $\vn{Penccoll}$ is the probability of collision between independently generated keys.

   The types $\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
   $\vn{cleartext}$, $\vn{ciphertext}$, and the
   probabilities $\vn{Penc}$, $\vn{Penccoll}$ must be declared before
   this macro is expanded. The functions $\vn{skgen}$, $\vn{pkgen}$,
   $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, and $\vn{Z}$ are declared by
   this macro. They must not be declared elsewhere, and they can be
   used only after expanding the macro.

   This macro defines the equivalences named $\texttt{ind\_cca2}(\vn{enc})$
   and $\texttt{ind\_cca2\_partial}(\vn{enc})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}). The equivalence $\texttt{ind\_cca2\_partial}(\vn{enc})$
   can be applied only manually and allows the user to replace the encryption 
   of a message with the encryption of zeroes for only some occurrences of
   encryption under the considered key, the ones in which the public key appears explicitly.

\item $\texttt{expand IND\_CCA2\_public\_key\_enc\_all\_args(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{enc\_seed}$, $\vn{skgen}$, $\vn{skgen}'$, $\vn{pkgen}$, $\vn{pkgen}'$, $\vn{enc}$, $\vn{enc\_r}$, $\vn{enc\_r}'$, $\vn{dec}$, $\vn{dec}'$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Penccoll}\texttt{).}$ is similar to the above,
  with six additional arguments. 

  $\vn{enc\_seed}$ is the type of random coins for encryption, must be \texttt{bounded}.

  $\vn{enc\_r}(\vn{cleartext}, \vn{pkey}, \vn{enc\_seed}): \vn{ciphertext}$ is the encryption function that takes coins as argument (instead of generating them internally).

  $\vn{pkgen}'$, $\vn{skgen}'$, $\vn{enc\_r}'$, and $\vn{dec}'$ are the symbols that replace $\vn{pkgen}$, $\vn{skgen}$, $\vn{enc\_r}$ and $\vn{dec}$ respectively after game transformation.

\item $\texttt{expand UF\_CMA\_det\_signature(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{signinput}$, $\vn{signature}$, $\vn{skgen}$, $\vn{pkgen}$, $\vn{sign}$, $
  \vn{check}$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ defines a
  UF-CMA (unforgeable under chosen message attacks)
  deterministic signature scheme.

   $\vn{keyseed}$ is the type of key seeds, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about
  the runtime of $\vn{pkgen}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{pkey}$ is the type of public keys, must be \texttt{bounded}.

   $\vn{skey}$ is the type of secret keys, must be \texttt{bounded}.

  $\vn{signinput}$ is the type of signature inputs.

   $\vn{signature}$ is the type of signatures.

   $\vn{skgen}(\vn{keyseed}): \vn{skey}$ is the secret key generation function.

   $\vn{pkgen}(\vn{keyseed}): \vn{pkey}$ is the public key generation function.

   $\vn{sign}(\vn{signinput}, \vn{skey}): \vn{signature}$ is the signature function.

   $\vn{check}(\vn{signinput}, \vn{pkey}, \vn{signature}): \texttt{bool}$ is the
  verification function.

   $\vn{Psign}(t, N, l)$ is the probability of breaking the UF-CMA property
   in time $t$, for one key, $N$ signature queries with messages of length
   at most $l$.

   $\vn{Psigncoll}$ is the probability of collision between independently generated keys.

   The types $\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$, $\vn{signinput}$,
   $\vn{signature}$ and the probabilities $\vn{Psign}$, $\vn{Psigncoll}$ must
   be declared before this macro is expanded. The functions
   $\vn{skgen}$, $\vn{pkgen}$, $\vn{sign}$, and $\vn{check}$ are declared by this
   macro. They must not be declared elsewhere, and they can be used
   only after expanding the macro.

   This macro defines the equivalences named
   $\texttt{uf\_cma}(\vn{sign})$,
   $\texttt{uf\_cma\_corrupt}(\vn{sign})$, and
   $\texttt{uf\_cma\_corrupt\_partial}(\vn{sign})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).
   All three equivalences correspond to the UF-CMA property, but the first one 
   does not allow corruption of the secret keys while last two allow it.
   The last two equivalences are applied only manually, in particular because their automatic
   application can sometimes be done too early, when other transformations
   should first be done in order to eliminate uses of the secret keys.
   The equivalence $\texttt{uf\_cma\_corrupt\_partial}(\vn{sign})$ allows the
   user to transform only some occurrences of the signature verification into a 
   lookup in the signed messages, the ones in which the public key appears explicitly.  

\item $\texttt{expand UF\_CMA\_det\_signature\_all\_args(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{signinput}$, $\vn{signature}$, $\vn{skgen}$, $\vn{skgen}'$, $\vn{pkgen}$, $\vn{pkgen}'$, $\vn{sign}$, $\vn{sign}'$, $
  \vn{check}$, $\vn{check}'$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ is similar to the above with four additional arguments.

  $\vn{pkgen}'$, $\vn{skgen}'$, $\vn{sign}'$, and $\vn{check}'$ are the symbols that replace $\vn{pkgen}$, $\vn{skgen}$, $\vn{sign}$ and $\vn{check}$ respectively after game transformation.

\item $\texttt{expand SUF\_CMA\_det\_signature(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{signinput}$, $\vn{signature}$, $\vn{skgen}$, $\vn{pkgen}$, $\vn{sign}$, $
  \vn{check}$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ defines a
  SUF-CMA (strongly unforgeable under chosen message attacks)
  deterministic signature scheme.
  The difference between a UF-CMA signature and a SUF-CMA MAsignature
  is that, for a UF-CMA signature, the adversary may easily forge a
  new signature for a message for which he has already seen a
  signature. Such a forgery is guaranteed to be hard for a SUF-CMA
  signature. The arguments are the same as for $\texttt{UF\_CMA\_det\_signature}$.
   This macro defines the equivalences named
   $\texttt{suf\_cma}(\vn{sign})$,
   $\texttt{suf\_cma\_corrupt}(\vn{sign})$, and
   $\texttt{suf\_cma\_corrupt\_partial}(\vn{sign})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

\item $\texttt{expand SUF\_CMA\_det\_signature\_all\_args(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{signinput}$, $\vn{signature}$, $\vn{skgen}$, $\vn{skgen}'$, $\vn{pkgen}$, $\vn{pkgen}'$, $\vn{sign}$, $\vn{sign}'$, $\vn{check}$, $\vn{check}'$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ is similar to the above with four additional arguments.

  $\vn{pkgen}'$, $\vn{skgen}'$, $\vn{sign}'$, and $\vn{check}'$ are the symbols that replace $\vn{pkgen}$, $\vn{skgen}$, $\vn{sign}$ and $\vn{check}$ respectively after game transformation.

\item $\texttt{expand UF\_CMA\_proba\_signature(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{signinput}$, $\vn{signature}$, $\vn{skgen}$, $\vn{pkgen}$, $\vn{sign}$, $
  \vn{check}$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ defines a
  UF-CMA (strongly unforgeable under chosen message attacks)
  probabilistic signature scheme.
  The arguments are the same as for $\texttt{UF\_CMA\_det\_signature}$,
  but the signature function internally generated random coins,
  so that it is probabilistic.
   This macro defines the equivalences named
   $\texttt{uf\_cma}(\vn{sign})$,
   $\texttt{uf\_cma\_corrupt}(\vn{sign})$, and
   $\texttt{uf\_cma\_corrupt\_partial}(\vn{sign})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

\item $\texttt{expand UF\_CMA\_proba\_signature\_all\_args(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{signinput}$, $\vn{signature}$, $\vn{sign\_seed}$, $\vn{skgen}$, $\vn{skgen}'$, $\vn{pkgen}$, $\vn{pkgen}'$, $\vn{sign}$, $\vn{sign\_r}$, $\vn{sign\_r}'$, $\vn{check}$, $\vn{check}'$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ is similar to the above,
  with six additional arguments. 

  $\vn{sign\_seed}$ is the type of random coins for signature, must be \texttt{bounded}.

  $\vn{sign\_r}(\vn{signinput}, \vn{skey}, \vn{sign\_seed}): \vn{signature}$ is the signature function that takes coins as argument (instead of generating them internally).

  $\vn{pkgen}'$, $\vn{skgen}'$, $\vn{sign\_r}'$, and $\vn{check}'$ are the symbols that replace $\vn{pkgen}$, $\vn{skgen}$, $\vn{sign\_r}$ and $\vn{check}$ respectively after game transformation.

\item $\texttt{expand SUF\_CMA\_proba\_signature(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
$  \vn{signinput}$, $\vn{signature}$, $\vn{skgen}$, $\vn{pkgen}$, $\vn{sign}$, $
  \vn{check}$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ defines a
  SUF-CMA (strongly unforgeable under chosen message attacks)
  probabilistic signature scheme.
  The arguments are the same as for $\texttt{UF\_CMA\_det\_signature}$,
  but the signature function internally generated random coins,
  so that it is probabilistic.
   This macro defines the equivalences named
   $\texttt{suf\_cma}(\vn{sign})$,
   $\texttt{suf\_cma\_corrupt}(\vn{sign})$, and
   $\texttt{suf\_cma\_corrupt\_partial}(\vn{sign})$, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

\item $\texttt{expand SUF\_CMA\_proba\_signature\_all\_args(}\vn{keyseed}$, $\vn{pkey}$, $\vn{skey}$,
  $\vn{signinput}$, $\vn{signature}$, $\vn{sign\_seed}$, $\vn{skgen}$, $\vn{pkgen}$, $\vn{sign}$, $\vn{sign\_r}$, $
  \vn{check}$, $\vn{Psign}$, $\vn{Psigncoll}\texttt{).}$ is similar to the above,
  with six additional arguments. 

  $\vn{sign\_seed}$ is the type of random coins for signature, must be \texttt{bounded}.

  $\vn{sign\_r}(\vn{signinput}, \vn{skey}, \vn{sign\_seed}): \vn{signature}$ is the signature function that takes coins as argument (instead of generating them internally).

  $\vn{pkgen}'$, $\vn{skgen}'$, $\vn{sign\_r}'$, and $\vn{check}'$ are the symbols that replace $\vn{pkgen}$, $\vn{skgen}$, $\vn{sign\_r}$ and $\vn{check}$ respectively after game transformation.

\item $\texttt{expand ROM\_hash(}\vn{key}, \vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{hashoracle}, \vn{qH}\texttt{).}$
defines a hash function in the random oracle model~\cite{Bellare93b}.

$\vn{key}$ is the type of the key of the hash function, which models
the choice of the hash function, must be \texttt{bounded}, typically 
\texttt{fixed}.

   $\vn{hashinput}$ is the type of the input of the hash function.

   $\vn{hashoutput}$ is the type of the output of the hash function, must be \texttt{bounded} or \texttt{nonuniform} (typically \texttt{fixed}).

   $\vn{hash}(\vn{key}, \vn{hashinput}): \vn{hashoutput}$ is the hash function.

    $\vn{hashoracle}$ is a process that allows the adversary to call the hash function.
    WARNING: The key must be generated once and for all at the beginning of the game 
   and the hash oracle must be made available to the adversary,
    by including $\vn{hashoracle}(\vn{hk})$ in the executed process,
    where $\vn{hk}$ is the key.

    $\vn{qH}$ is the number of queries to the hash oracle.

    The types $\vn{key}$, $\vn{hashinput}$, and $\vn{hashoutput}$ must
    be declared before this macro.  The function $\vn{hash}$, the
    process $\vn{hashoracle}$, and the parameter $\vn{qH}$ are defined
    by this macro. They must not be declared elsewhere, and they can
    be used only after expanding the macro.

   This macro defines the equivalence named $\texttt{rom}(\vn{hash})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}).

\item $\texttt{expand ROM\_hash\_large(}\vn{key}, \vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{hashoracle}, \vn{qH}\texttt{).}$ defines a random oracle with a large output, that is, it optimizes the 
definition by eliminating collisions between random output elements.
Its interface is the same as the one of \texttt{ROM\_hash} above.

\item $\texttt{expand CollisionResistant\_hash(}\vn{key}, \vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{hashoracle}, \vn{Phash}\texttt{).}$
defines a collision-resistant hash function~\cite{Rogaway04}, \cite[Section~8.2]{BellareCourse}.

   $\vn{key}$ is the type of the key of the hash function, must be \texttt{bounded} or \texttt{nonuniform}, typically \texttt{fixed}.

   $\vn{hashinput}$ is the type of the input of the hash function.

   $\vn{hashoutput}$ is the type of the output of the hash function.

   $\vn{hash}(\vn{key}, \vn{hashinput}): \vn{hashoutput}$ is the hash function.

   $\vn{hashoracle}$ is a process that leaks the key that it receives as argument.
   WARNING: A collision resistant hash function is a keyed hash function.
   The key must be generated once and for all at the beginning of the game,
   and immediately made available to the adversary, for instance
   by including the process $\vn{hashoracle}(\vn{hk})$,
   where $\vn{hk}$ is the key.

   $\vn{Phash}(t)$ is the probability of breaking collision resistance,
   for an adversary that runs in time at most $t$. ($t$ is the time
   since the choice of the hash function, that is, of the key $\vn{hk}$.)

   The types $\vn{key}$, $\vn{hashinput}$, and $\vn{hashoutput}$ and
   the probability $\vn{Phash}$ must be declared before this macro.
   The function $\vn{hash}$ and the process $\vn{hashoracle}$ are
   defined by this macro. They must not be declared elsewhere, and
   they can be used only after expanding the macro.

\item $\texttt{expand HiddenKeyCollisionResistant\_hash(}\vn{key}$, $\vn{hashinput}$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$
defines a hidden-key collision-resistant hash function~\cite[Section~8.6]{BellareCourse}. It differs from collision-resistance in that the adversary is not allowed to access the key that defines the hash function; it is just allowed to query the hash oracle. The interface is similar to collision-resistant hash functions above. 

   $\vn{hashoracle}$ is a process that provides a hash oracle to the adversary.
   WARNING: A hidden-key collision resistant hash function is a keyed hash function.
   The key must be generated once and for all at the beginning of the game,
   and the hash oracle for that key must be provided to the adversary
   by including the process $\vn{hashoracle}(\vn{hk})$,
   where $\vn{hk}$ is the key.

   $\vn{qH}$ is the number of calls to the hash oracle provided by $\vn{hashoracle}$.

   $\vn{Phash}(t,N)$ is the probability of breaking collision resistance,
   for an adversary that runs in time at most $t$ and calls the hash oracle
   at most $N$ times.

   This macro defines the equivalence named
   $\texttt{collision\_res}(\vn{hash})$ for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

\item $\texttt{expand SecondPreimageResistant\_hash(}\vn{key}, \vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{hashoracle}, \vn{Phash}\texttt{).}$
defines a second-preimage-resistant hash function~\cite{Rogaway04}. The interface is the same as for collision-resistant hash functions above. However, note that the argument type $\vn{hashinput}$ must be \texttt{bounded} or \texttt{nonuniform} so that one can generate random values in it. It is typically \texttt{fixed} and \texttt{large}.

\item $\texttt{expand HiddenKeySecondPreimageResistant\_hash(}\vn{key}$, $\vn{hashinput}$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$
defines a hidden-key second-preimage-resistant hash function. The interface is the same as for hidden-key collision-resistant hash functions above. However, note that the argument type $\vn{hashinput}$ must be \texttt{bounded} or \texttt{nonuniform} so that one can generate random values in it. It is typically \texttt{fixed} and \texttt{large}.

   This macro defines the equivalence named
   $\texttt{second\_pre\_res}(\vn{hash})$ for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

\item $\texttt{expand FixedSecondPreimageResistant\_hash(}\vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{Phash}\texttt{).}$
defines a second-preimage-resistant hash function, for a hash function without key. (It can also be interpreted as a hash function with a fixed key as in~\cite{Rogaway04}, which we omit in our model.)

$\vn{hashinput}$ is the type of the input of the hash function. It
must be \texttt{bounded} or \texttt{nonuniform} so that one can
generate random values in it. It is typically \texttt{fixed} and
\texttt{large}.

   $\vn{hashoutput}$ is the type of the output of the hash function.

   $\vn{hash}(\vn{hashinput}): \vn{hashoutput}$ is the hash function.

   $\vn{Phash}(t)$ is the probability of breaking second-preimage resistance,
   for an adversary that runs in time at most $t$.

   The types $\vn{hashinput}$, and $\vn{hashoutput}$ and the
   probability $\vn{Phash}$ must be declared before this macro.  The
   function $\vn{hash}$ is defined by this macro. It must not be
   declared elsewhere, and it can be used only after expanding the
   macro.

\item $\texttt{expand PreimageResistant\_hash(}\vn{key}, \vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{hashoracle}, \vn{Phash}\texttt{).}$
defines a preimage-resistant hash function~\cite{Rogaway04}. The interface is the same as for collision-resistant hash functions above. However, note that the argument type $\vn{hashinput}$ must be \texttt{bounded} or \texttt{nonuniform} so that one can generate random values in it. It is typically \texttt{fixed} and \texttt{large}.

   This macro defines the equivalence named
   $\texttt{preimage\_res}(\vn{hash})$ for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

$\texttt{expand PreimageResistant\_hash\_all\_args(}\vn{key}, \vn{hashinput}, \vn{hashoutput}, \vn{hash}$, $\vn{hash}'$, $\vn{hashoracle}$, $\vn{Phash}\texttt{).}$ is similar, with an additional argument $\vn{hash}'$, which is a symbol that replaces $\vn{hash}$ after game transformation.

\item $\texttt{expand HiddenKeyPreimageResistant\_hash(}\vn{key}$, $\vn{hashinput}$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$
defines a hidden-key preimage-resistant hash function. The interface is the same as for hidden-key collision-resistant hash functions above. However, note that the argument type $\vn{hashinput}$ must be \texttt{bounded} or \texttt{nonuniform} so that one can generate random values in it. It is typically \texttt{fixed} and \texttt{large}.

   This macro defines the equivalence named
   $\texttt{preimage\_res}(\vn{hash})$ for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

$\texttt{expand HiddenKeyPreimageResistant\_hash\_all\_args(}\vn{key}$, $\vn{hashinput}$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hash}'$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$ is similar, with an additional argument $\vn{hash}'$, which is a symbol that replaces $\vn{hash}$ after game transformation.

\item $\texttt{expand FixedPreimageResistant\_hash(}\vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{Phash}\texttt{).}$
defines a preimage-resistant hash function, for a hash function without key. (It can also be interpreted as a hash function with a fixed key as in~\cite{Rogaway04}, which we omit in our model.)
The interface is the same as for fixed second-preimage-resistant hash functions above.

   This macro defines the equivalence named
   $\texttt{preimage\_res}(\vn{hash})$ for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

$\texttt{expand FixedPreimageResistant\_hash\_all\_args(}\vn{hashinput}, \vn{hashoutput}, \vn{hash}, \vn{hash}', \vn{Phash}\texttt{).}$ is similar, with an additional argument $\vn{hash}'$, which is a symbol that replaces $\vn{hash}$ after game transformation.

  \item Similarly to the macros above, for $N$ from 1 to 10, the macros\\
   $\texttt{expand ROM\_hash\_$N$(}\vn{key}, \vn{hashinput1}, \dots, \vn{hashinput}N, \vn{hashoutput}, \vn{hash}, \vn{hashoracle}, \vn{qH}\texttt{).}$\\
   $\texttt{expand ROM\_hash\_large\_$N$(}\vn{key}, \vn{hashinput1}, \dots, \vn{hashinput}N, \vn{hashoutput}, \vn{hash}, \vn{hashoracle}, \vn{qH}\texttt{).}$\\
   $\texttt{expand CollisionResistant\_hash\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand HiddenKeyCollisionResistant\_hash\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand SecondPreimageResistant\_hash\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand HiddenKeySecondPreimageResistant\_hash\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand FixedSecondPreimageResistant\_hash\_$N$(}\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand PreimageResistant\_hash\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand PreimageResistant\_hash\_all\_args\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hash}'$, $\vn{hashoracle}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand HiddenKeyPreimageResistant\_hash\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand HiddenKeyPreimageResistant\_hash\_all\_args\_$N$(}\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hash}'$, $\vn{hashoracle}$, $\vn{qH}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand FixedPreimageResistant\_hash\_$N$(}\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{Phash}\texttt{).}$\\
   $\texttt{expand FixedPreimageResistant\_hash\_all\_args\_$N$(}\vn{hashinput1}$, \dots, $\vn{hashinput}N$, $\vn{hashoutput}$, $\vn{hash}$, $\vn{hash}'$, $\vn{Phash}\texttt{).}$\\
   define hash functions with $N$ arguments, with the same properties as above.

   $\vn{hashinput1}$, \dots, $\vn{hashinput}N$ are the types of the inputs of the hash function and
   $\vn{hash}(\vn{key}$, $\vn{hashinput1}$, \dots, $\vn{hashinput}N):$ $\vn{hashoutput}$ is the hash function, except for $\texttt{FixedSecondPreimageResistant\_hash\_}N$ and $\texttt{FixedPreimageResistant\_hash\_}N$, where $\vn{hash}(\vn{hashinput1}$, \dots, $\vn{hashinput}N):$ $\vn{hashoutput}$ is the hash function.


\item $\texttt{expand OW\_trapdoor\_perm(}\vn{seed}, \vn{pkey}, \vn{skey}, \vn{D}, \vn{pkgen}, \vn{skgen}, \vn{f}, \vn{invf}, \vn{POW}\texttt{).}$ defines a one-way trapdoor permutation.

   $\vn{seed}$ is the type of key seeds, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about
  the runtime of $\vn{pkgen}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{pkey}$ is the type of public keys, must be \texttt{bounded}.

   $\vn{skey}$ is the type of secret keys, must be \texttt{bounded}.

   $\vn{D}$ is the type of the input and output of the permutation, must be \texttt{bounded}, typically \texttt{fixed}.

   $\vn{pkgen}(\vn{seed}): \vn{pkey}$ is the public key generation function.

   $\vn{skgen}(\vn{seed}): \vn{skey}$ is the secret key generation function.

   $\vn{f}(\vn{pkey}, \vn{D}):\vn{D}$ is the permutation (taking as argument the public key)

   $\vn{invf}(\vn{skey}, \vn{D}):\vn{D}$ is the inverse permutation of f (taking as argument the secret key,
         i.e. the trapdoor)

   $\vn{POW}(t)$ is the probability of breaking the one-wayness property
   in time $t$, for one key and one permuted value.

   The types $\vn{seed}$, $\vn{pkey}$, $\vn{skey}$, $\vn{D}$, and the probability $\vn{POW}$ must be
   declared before this macro. The functions $\vn{pkgen}$, $\vn{skgen}$, $\vn{f}$, $\vn{invf}$
   are defined by this macro. They must not be declared elsewhere, and
   they can be used only after expanding the macro. 

   This macro defines the equivalences $\texttt{remove\_invf}(f)$,
   which expresses that, for $y$ chosen randomly in $D$, $y$ and
   $\vn{invf}(\vn{skey}, y)$ are distributed like for $x$ chosen
   randomly in $D$, $\vn{f}(\vn{pkey}, x)$ and $x$, and
   $\texttt{ow}(f)$, which corresponds to one-wayness, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

\item $\texttt{expand OW\_trapdoor\_perm\_RSR(}\vn{seed}, \vn{pkey}, \vn{skey}, \vn{D}, \vn{pkgen}, \vn{skgen}, \vn{f}, \vn{invf}, \vn{POW}\texttt{).}$ defines a one-way trapdoor permutation, with random self-reducibility. The arguments are the same as for $\texttt{OW\_trapdoor\_perm}$, but the probability of breaking one-wayness is bounded more precisely. This macro defines the equivalences $\texttt{remove\_invf}(f)$ as above and $\texttt{ow\_rsr}(f)$.

\item $\texttt{expand set\_PD\_OW\_trapdoor\_perm(}\vn{seed}$, $\vn{pkey}$, $\vn{skey}$, $\vn{D}$, $\vn{Dow}$, $\vn{Dr}$, $\vn{pkgen}$, $\vn{skgen}$, $\vn{f}$, $\vn{invf}$, $\vn{concat}$, $\vn{P\_PD\_OW}\texttt{).}$ defines a set partial-domain one-way trapdoor permutation.

   $\vn{seed}$ is the type of key seeds, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about
  the runtime of $\vn{pkgen}$ without mentioning the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{pkey}$ is the type of public keys, must be \texttt{bounded}.

   $\vn{skey}$ is the type of secret keys, must be \texttt{bounded}.

   $\vn{D}$ is the type of the input and output of the permutation, must be \texttt{bounded}, typically \texttt{fixed}.
   The domain $\vn{D}$ consists of the concatenation of bitstrings in $\vn{Dow}$ and $\vn{Dr}$.
   $\vn{Dow}$ is the set of sub-bitstrings of $\vn{D}$ on which one-wayness holds (it is difficult to compute the
   random element $x$ of $\vn{Dow}$ knowing $f(\vn{pk}, \vn{concat}(x,y))$ where $y$ is a random element of $\vn{Dr}$).
   $\vn{Dow}$ and $\vn{Dr}$ must be \texttt{bounded}, typically \texttt{fixed}.
  
   $\vn{pkgen}(\vn{seed}): \vn{pkey}$ is the public key generation function.

   $\vn{skgen}(\vn{seed}): \vn{skey}$ is the secret key generation function.

   $\vn{f}(\vn{pkey}, \vn{D}):\vn{D}$ is the permutation (taking as argument the public key)

   $\vn{invf}(\vn{skey}, \vn{D}):\vn{D}$ is the inverse permutation of f (taking as argument the secret key,
         i.e. the trapdoor)

   $\vn{concat}(\vn{Dow}, \vn{Dr}):\vn{D}$ is bitstring concatenation.

   $\vn{P\_PD\_OW}(t,l)$ is the probability of breaking the set partial-domain one-wayness property
   in time $t$, for one key, one permuted value, and $l$ tries.

   The types $\vn{seed}$, $\vn{pkey}$, $\vn{skey}$, $\vn{D}$, $\vn{Dow}$, $\vn{Dr}$ 
   and the probability $\vn{P\_PD\_OW}$ must be
   declared before this macro. The functions $\vn{pkgen}$, $\vn{skgen}$, $\vn{f}$, $\vn{invf}$, $\vn{concat}$
   are defined by this macro. They must not be declared elsewhere, and
   they can be used only after expanding the macro. 

   This macro defines the equivalences $\texttt{remove\_invf}(f)$,
   which expresses that, for $y$ chosen randomly in $D$, $y$ and
   $\vn{invf}(\vn{skey}, y)$ are distributed like for $x$ chosen
   randomly in $D$, $\vn{f}(\vn{pkey}, x)$ and $x$, and
   $\texttt{pd\_ow}(f)$, which corresponds to set partial-domain one-wayness, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

\item $\texttt{expand OW\_trapdoor\_perm\_all\_args(}\vn{seed}, \vn{pkey}, \vn{skey}, \vn{D}, \vn{pkgen}, \vn{pkgen}', \vn{skgen}, \vn{f}, \vn{f}', \vn{invf}, \vn{POW}\texttt{).}$\\
$\texttt{expand OW\_trapdoor\_perm\_RSR\_all\_args(}\vn{seed}, \vn{pkey}, \vn{skey}, \vn{D}, \vn{pkgen}, \vn{pkgen}', \vn{skgen}, \vn{f}, \vn{f}', \vn{invf}, \vn{POW}\texttt{).}$\\
$\texttt{expand set\_PD\_OW\_trapdoor\_perm\_all\_args(}\vn{seed}$, $\vn{pkey}$, $\vn{skey}$, $\vn{D}$, $\vn{Dow}$, $\vn{Dr}$, $\vn{pkgen}$, $\vn{pkgen}'$, $\vn{skgen}$, $\vn{f}$, $\vn{f}'$, $\vn{invf}$, $\vn{concat}$, $\vn{P\_PD\_OW}\texttt{).}$ are similar to $\texttt{OW\_trapdoor\_perm}$, $\texttt{OW\_trapdoor\_perm\_RSR}$, and
$\texttt{set\_PD\_OW\_trapdoor\_perm\_all\_args}$ respectively, with two additional arguments.

$\vn{pkgen}'$ and $\vn{f}'$ are the symbols that replace $\vn{pkgen}$ and $\vn{f}$ respectively after game transformation.

\item $\texttt{expand PRF(}\vn{key}, \vn{input}, \vn{output}, \vn{f}, \vn{Pprf}\texttt{).}$ 
defines a pseudo-random function.

   $\vn{key}$ is the type of keys, must be \texttt{bounded} (to be able to generate random numbers from it, and to talk about the runtime of $\vn{f}$ without mentioned the length of the key), typically \texttt{fixed} and \texttt{large}.

   $\vn{input}$ is the type of the input of the PRF.

   $\vn{output}$ is the type of the output of the PRF, must be \texttt{bounded}, typically \texttt{fixed}.

   $\vn{f}(\vn{key}, \vn{input}):\vn{output}$ is the PRF function.

   $\vn{Pprf}(t, N, l)$ is the probability of breaking the PRF property
   in time $t$, for one key, $N$ queries to the PRF of length at most $l$.

   The types $\vn{key}$, $\vn{input}$, $\vn{output}$
   and the probability $\vn{Pprf}$ must be declared before this macro
   is expanded. The function $\vn{f}$ is declared by
   this macro. It must not be declared elsewhere, and it can be
   used only after expanding the macro.

   This macro defines the equivalence named $\texttt{prf}(\vn{f})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}).

\item $\texttt{expand PRF\_large(}\vn{key}, \vn{input}, \vn{output}, \vn{f}, \vn{Pprf}\texttt{).}$ 
defines a pseudo-random function with a large output, that is, it optimizes the 
definition by eliminating collisions between random output elements.
Its interface is the same as the one of \texttt{PRF} above.

 \item Similarly, for $N$ from 1 to 10, the macros\\
$\texttt{expand PRF\_$N$(}\vn{key}, \vn{input1}, \dots, \vn{input}N, \vn{output}, \vn{f}, \vn{Pprf}\texttt{).}$ \\
$\texttt{expand PRF\_large\_$N$(}\vn{key}, \vn{input1}, \dots, \vn{input}N, \vn{output}, \vn{f}, \vn{Pprf}\texttt{).}$ \\
define pseudo-random functions with $N$ arguments, 
similarly to \texttt{PRF} and \texttt{PRF\_large} above.
$\vn{input1}$, \dots, $\vn{input}N$ are the types of the inputs of the PRF and
$\vn{f}(\vn{key}, \vn{input1}, \dots, \vn{input}N):\vn{output}$ is the PRF.

 \item The specification of Diffie-Hellman key agreements is typically composed of two or three macro expansions:

   \begin{itemize}
   \item One from the following set of macros, which defines properties of the group:
     \begin{itemize}
     \item $\texttt{expand\ DH\_basic(}G, Z, g, \vn{exp}, \vn{exp}', \vn{mult}\texttt{).}$ defines a group $G$.

       $G$: type of group elements (must be \texttt{bounded} and \texttt{large}).

       $Z$: type of exponents (must be \texttt{bounded} and
       \texttt{large}). 
       
       $g$: an element of the group $G$.

       $\vn{exp}(G, Z): G$: the exponentiation function.  
       
       $\vn{exp}'(G, Z): G$: symbol used to replace $\vn{exp}$ after game transformations.

       $\vn{mult}(Z, Z): Z$: the multiplication function for exponents, commutative.

       The equation $\vn{exp}(\vn{exp}(a,x), y) = \vn{exp}(a,
       \vn{mult}(x,y))$ must be satisfied.

       The private Diffie-Hellman keys are generated by choosing an
       element randomly in $Z$, according to its default distribution
       (which is not necessarily uniform). The public Diffie-Hellman
       keys are generated as $X = \vn{exp}(g,x)$, where $x$ is a
       private Diffie-Hellman key, and similarly $Y =
       \vn{exp}(g,y)$. The Diffie-Hellman shared secret is
       $\vn{exp}(X,y) = \vn{exp}(Y,x) = \vn{exp}(g,\vn{mult}(x,y))$.
       This macro makes no other assumption. In particular, it allows
       $G$ to contain elements other than those generated by $g$.

       The types $G$ and $Z$ must be declared before this macro.  The
       functions $g$, $\vn{exp}$, and $\vn{mult}$ are defined by this
       macro. They must not be declared elsewhere, and they can be used
       only after expanding the macro.

     \item $\texttt{expand\ DH\_proba\_collision(}G, Z, g, \vn{exp},
       \vn{exp}', \vn{mult}, \vn{PCollKey1},
       \vn{PCollKey2}\texttt{).}$ defines a group $G$ like
       \texttt{DH\_basic}, with the following additional properties:
       the probability that $\vn{exp}(g, x) = Y$ where $x$ is random and
       $Y$ is independent of $x$ is at most $\vn{PCollKey1}$, and
       the probability that $\vn{exp}(g, \vn{mult}(x,y)) = Y$ where
       $x$ and $y$ are independent random private keys and 
       $Y$ is independent of $x$ or $y$ is at most
       $\vn{PCollKey2}$. These probabilities are negligible in most
       Diffie-Hellman groups, but need to be evaluated more precisely
       for using this property.
       
       The types $G$ and $Z$ and the probabilities $\vn{PCollKey1}$
       and $\vn{PCollKey2}$ must be declared before this macro.  The
       functions $g$, $\vn{exp}$, and $\vn{mult}$ are defined by this
       macro. They must not be declared elsewhere, and they can be
       used only after expanding the macro.

     \item $\texttt{expand\ square\_DH\_proba\_collision(}G, Z, g, \vn{exp},
       \vn{exp}', \vn{mult}, \vn{PCollKey1},
       \vn{PCollKey2}$, $\vn{PCollKey3}\texttt{).}$ is similar to \texttt{DH\_proba\_collision}, but additionally
   says that the probability that $\vn{exp}(g, \vn{mult}(x,x)) = Y$ where
   $x$ is random and $Y$ is independent of $x$ is at most $\vn{PCollKey3}$, with $\vn{PCollKey3} \geq \vn{PCollKey2}$.
       
       The types $G$ and $Z$ and the probabilities $\vn{PCollKey1}$, $\vn{PCollKey2}$, 
       and $\vn{PCollKey3}$ must be declared before this macro.  The
       functions $g$, $\vn{exp}$, and $\vn{mult}$ are defined by this
       macro. They must not be declared elsewhere, and they can be
       used only after expanding the macro.

     \item $\texttt{expand\ DH\_good\_group(}G, Z, g, \vn{exp}, \vn{exp}', \vn{mult}\texttt{).}$ defines a group $G$ like
       \texttt{DH\_basic}, with the following additional properties:
       $G$ is a group of prime order $q$, with the neutral element excluded, 
       the set of exponents $Z$ is $\{1, \dots, q-1\}$,
       $g$ is a generator of $G$, 
       $\vn{mult}$ is the product modulo $q$ in $\{1, \dots, q-1\}$, i.e. in the group $(\mathbb{Z}/q\mathbb{Z})*$,
       the distributions of random choices in $Z$ and $G$ are uniform.

       It may not be obvious when an element is received on the network
       whether it really belongs to the group $G$ generated by $g$. That should 
       be checked for the properties assumed in this macro to hold.

       This macro defines the following equivalences for use in the
       \texttt{crypto} command (see Section~\ref{sec:interact}):
       \begin{itemize}
       \item $\texttt{group\_to\_exp\_strict}(\vn{exp})$ which allows to replace
         a random $X \in G$ with $\vn{exp}(g,x)$ for a random $x \in Z$, provided
         $\vn{exp}(X,\_)$ occurs in the game.
       \item $\texttt{group\_to\_exp}(\vn{exp})$ which allows to replace
         a random $X \in G$ with $\vn{exp}(g,x)$ for a random $x \in Z$ in any case.
         (This transformation is applied only manually.)
       \item $\texttt{exp\_to\_group}(\vn{exp})$ which allows to replace
         $\vn{exp}(g,x)$ for a random $x \in Z$ with a random $X \in G$.
       \item $\texttt{exp'\_to\_group}(\vn{exp})$ which allows to replace
         $\vn{exp'}(g,x)$ for a random $x \in Z$ with a random $X \in G$.
       \end{itemize}

\newcommand{\F}{\mathbb{F}}%
\newcommand{\red}{\mathrm{red}}%
\newcommand{\repr}{\mathrm{repr}}%
\newcommand{\modop}{\mathbin{\mathrm{mod}}}%
\newcommand{\mul}[2]{{#1}\cdot{#2}}

     \item $\texttt{expand\ DH\_single\_coord\_ladder}(G$, $Z$, $g$, $\vn{exp}$, $\vn{mult}$, $\vn{subG}$, $\vn{Znw}$, $\vn{ZnwtoZ}$, $\vn{g\_k}$, $\vn{exp\_div\_k}$, $\vn{exp\_div\_k}'$, $\vn{pow\_k}$, $\vn{subGtoG}$, $\vn{zero}$, $\vn{sub\_zero}\texttt{).}$ models an elliptic curve defined by the equation
   $Y^2 = X^3 + A X^2 + X$ in the field $\F_p$ of non-zero integers modulo the 
   large prime $p$, where $A^2 - 4$ is not a square modulo $p$.
   This curve must form a commutative group of order $kq$ where $k$ is a 
   small integer and $q$ is a large prime.
   Its quadratic twist must form a commutative group of order $k'q'$ where $k'$
   is a small integer and $q'$ is a large prime.
   $k$ must be a multiple of $k'$.
   We must use a single coordinate ladder defined as follows: we
   consider the elliptic curve $E(\F_{p^2})$ defined by the equation $Y^2 =
   X^3 + A X^2 + X$ in a quadratic extension $\F_{p^2}$ of $\F_p$, we define 
   $X_0 : E(\F_{p^2}) \rightarrow \F_{p^2}$ by $X_0(\infty) = 0$ and $X_0(X,Y) = X$, and 
   for $X \in \F_p$ and $y$ an integer, we define $\mul{y}{X} \in \F_p$ as $\mul{y}{X} = X_0(yQ)$
   for all $Q \in E(\F_{p^2})$ such that $X_0(Q) = X$.
   The value $g = X_0(g_0)$ represents the base point $g_0$, which must have order $q$.
   The public keys (bitstrings) are mapped to elements of $\F_p$ by the function 
   $\red$ and conversely, elements of $\F_p$ are mapped to public keys by
   the function $\repr$, such that $\red \circ \repr$ is the identity.
   The Diffie-Hellman ``exponentiation'' is defined by 
      \[\exp(X,y) = \repr(\mul{y}{\red(X)})\]
   The secret keys are chosen uniformly in $\{ kn \mid n \in [n_{min},n_{max}] \}$
   where $n_{min} < n_{max}$, $n_{max} - n_{min} < q$ and $n_{max} - n_{min} < q'$.
   Therefore the set of secret keys may contain a multiple of $q$ (resp. $q'$).
   Such keys are weak, in the sense that they yield 0 for all public
   keys on the curve (resp. on the twist). We exclude them as a first step
   in the proof, by applying the equivalence $\texttt{exclude\_weak\_keys}(Z)$
   defined by this macro, automatically or with the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

This model is justified in~\cite{LippBlanchetBharagavanInria19}.

       $G$: type of public keys (must be \texttt{bounded} and \texttt{large}).

       $\vn{subG}$: type of $\{ \mul{k}{X} \mid X \in F_p \}$  (must be \texttt{bounded}, \texttt{nonuniform}, and \texttt{large}). 
     Random choices in $\vn{subG}$ are done by choosing uniformly in 
     $\{ \mul{x}{g} \mid x \in \{ 1, \dots, q-1 \} \}$. (This set is not the whole $\vn{subG}$,
     since $\vn{subG}$ also contains elements of the twist.)
     This is important when the DDH assumption or the square DDH assumption
     is used.
       

       $Z$, $\vn{Znw}$: type of exponents (must be \texttt{bounded}, \texttt{nonuniform}, and \texttt{large}). 
   $\vn{Znw}$ is the set of integers multiple of $k$, prime to $qq'$ modulo $kqq'$, that is, exponents without weak keys.
     Random choices in $\vn{Znw}$ are done by choosing uniformly in 
     $\{ kn \mid n \in [n_{min},n_{max}], n$ prime to $qq' \}$.
       $Z$ is the set of integers multiple of $k$ modulo $kqq'$, that is, exponents with weak keys. Random choices in $Z$ are done by choosing uniformly in 
   $\{ kn \mid n \in [n_{min},n_{max}] \}$, hence $\texttt{Pcoll1rand}(Z) = 1/(n_{max}-n_{min}+1)$. 
       
       $\vn{ZnwtoZ}(\vn{Znw}):Z$: injection from $\vn{Znw}$ to $Z$.

       $g: G$: represents the base point.

       $\vn{exp}(G, Z): G$: the exponentiation function.  
       
       $\vn{mult}(\vn{Znw}, \vn{Znw}): \vn{Znw}$: the multiplication function for exponents, defined as
       $\vn{mult}(x,y) = x.y \mod kqq'$. (It remains in $\vn{Znw}$.)

       $\vn{g\_k} = \mul{k}{\red(g)}$. It is an element of $\vn{subG}$.

       $\vn{exp\_div\_k}(\vn{subG},\vn{Znw}): \vn{subG}$ is defined by $\vn{exp\_div\_k}(X,y) = \mul{(y/k)}{X}$.

       $\vn{exp\_div\_k}'$: symbol that replaces $\vn{exp\_div\_k}$ after game transformation,
       with the same definition as $\vn{exp\_div\_k}$.

       $\vn{pow\_k}(G):\vn{subG}$, defined by $\vn{pow\_k}(x) = \mul{k}{\red(x)}$.

       $\vn{subGtoG}(\vn{subG}):G$ is $\repr$ restricted to $\vn{subG}$.

       $\vn{zero}: G$ is the public key 0.
       
       $\vn{sub\_zero}: \vn{subG}$ is 0, as an element of $\vn{subG}$.

       The types $G$, $\vn{subG}$, $Z$, and $\vn{Znw}$ must be declared before this macro.  The
       functions $g$, $\vn{exp}$, $\vn{mult}$, $\vn{ZnwtoZ}$, $\vn{g\_k}$, $\vn{exp\_div\_k}$, $\vn{exp\_div\_k}'$, $\vn{pow\_k}$, $\vn{subGtoG}$,
       $\vn{zero}$, $\vn{sub\_zero}$ are defined by this macro. They must not be declared
       elsewhere, and they can be used only after expanding the macro.

       When this macro is used, the Diffie-Hellman assumptions (detailed below)
       should be applied to the subgroup, that is,
       $\texttt{expand\ }\vn{assumption}\texttt{(}\vn{subG}$, $\vn{Znw}$, $\vn{g\_k}$, $\vn{exp\_div\_k}$, $\vn{exp\_div\_k}'$, $\vn{mult}$, $\dots\texttt{).}$


     \item $\texttt{expand\ DH\_X25519}(G$, $Z$, $g$, $\vn{exp}$, $\vn{mult}$, $\vn{subG}$, $\vn{g\_k}$, $\vn{exp\_div\_k}$, $\vn{exp\_div\_k}'$, $\vn{pow\_k}$, $\vn{subGtoG}$, $\vn{zero}$, $\vn{sub\_zero}\texttt{).}$ models Curve25519 as defined in RFC 7748 (\url{https://tools.ietf.org/html/rfc7748}). It is justified in detail in~\cite{LippBlanchetBharagavanInria19}.
   More generally, it supports the same curves as \texttt{DH\_single\_coord\_ladder}
   with the additional assumption that all secret keys are prime to $qq'$. 
   Therefore, we do not need to exclude weak secret keys, so the
   parameters $\vn{Znw}$ and $\vn{ZnwtoZ}$ are removed, and we use $Z$ instead of $\vn{Znw}$.

   Curve25519 satisfies these assumptions with
   $p = 2^{255}-19$,
   $k = 8$, $k' = 4$, $q = 2^{252} + \delta$ with $0 < \delta < 2^{128}$,
      $q' = 2^{253} - 9 - 2\delta$,
    $\red(X) = (X \modop 2^{255})\modop p$, $\repr(X)$ is the representation 
      of $X$ as an element of $\{0, \dots, p-1\}$,
    $n_{min} = 2^{251}$, and $n_{max} = 2^{252}-1$, so $\texttt{Pcoll1rand}(Z) = 2^{-251}$.
       (For simple examples that use Curve25519, using the macro 
       \texttt{DH\_proba\_collision} may also work.)

     \item $\texttt{expand\ DH\_X448}(G$, $Z$, $g$, $\vn{exp}$, $\vn{mult}$, $\vn{subG}$, $\vn{Znw}$, $\vn{ZnwtoZ}$, $\vn{g\_k}$, $\vn{exp\_div\_k}$, $\vn{exp\_div\_k}'$, $\vn{pow\_k}$, $\vn{subGtoG}$, $\vn{zero}$, $\vn{sub\_zero}\texttt{).}$ models Curve448 as defined in RFC 7748
(\url{https://tools.ietf.org/html/rfc7748}).
   More generally, it supports the same curves as \texttt{DH\_single\_coord\_ladder}
   with the additional assumptions that there is at most one secret key
   multiple of $q$ or $q'$, and that $q = -1 \mod 4$, so $-1$ is not a 
   square modulo $q$. That allows to reduce some probabilities.
   This model is justified in~\cite{LippBlanchetBharagavanInria19}.

     \end{itemize}

   \item Optionally, 
     $\texttt{expand\ DH\_dist\_random\_group\_element\_vs\_exponent(}G,
     Z, g, \vn{exp}, \vn{exp}', \vn{mult}$, $\vn{PDist}\texttt{).}$ This macro says
     that the probability of distinguishing a random group element
     from an exponentiation $\vn{exp}(g,x)$ with a random exponent $x$
     is at most $\vn{PDist}$.  The other arguments are as in
     \texttt{DH\_basic} and all arguments must be defined before 
     expanding the macro.

   This macro defines the following equivalences for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}):
   \begin{itemize}
   \item $\texttt{group\_to\_exp\_strict}(\vn{exp})$ which allows to replace
     a random $X \in G$ with $\vn{exp}(g,x)$ for a random $x \in Z$, provided
     $\vn{exp}(X,\_)$ occurs in the game.
   \item $\texttt{group\_to\_exp}(\vn{exp})$ which allows to replace
     a random $X \in G$ with $\vn{exp}(g,x)$ for a random $x \in Z$ in any case.
     (This transformation is applied only manually.)
   \item $\texttt{exp\_to\_group}(\vn{exp})$ which allows to replace
     $\vn{exp}(g,x)$ for a random $x \in Z$ with a random $X \in G$.
   \item $\texttt{exp'\_to\_group}(\vn{exp})$ which allows to replace
     $\vn{exp'}(g,x)$ for a random $x \in Z$ with a random $X \in G$.
   \end{itemize}

     This macro can be used with any of the previous macros, except
     that it is useless with the macro \texttt{DH\_good\_group}, because this macro
     already includes these properties with $\vn{PDist} = 0$. When the macro 
$\texttt{DH\_single\_coord\_ladder}$, $\texttt{DH\_X25519}$, or $\texttt{DH\_X448}$ is used, this macro should be applied to the subgroup. For instance, with
$\texttt{expand\ DH\_single\_coord\_ladder}(G$, $Z$, $g$, $\vn{exp}$, $\vn{mult}$, $\vn{subG}$, $\vn{Znw}$, $\vn{ZnwtoZ}$, $\vn{g\_k}$, $\vn{exp\_div\_k}$, $\vn{exp\_div\_k}'$, $\vn{pow\_k}$, $\vn{subGtoG}$, $\vn{zero}$, $\vn{sub\_zero}\texttt{).}$, it should be
     $\texttt{expand\ DH\_dist\_random\_group\_element\_vs\_exponent(}\vn{subG}$, $\vn{Znw}$, $\vn{g\_k}$, $\vn{exp\_div\_k}$, $\vn{exp\_div\_k}'$, $\vn{mult}$, $\vn{Pdist}\texttt{).}$
     
   \item One from the following set of macros, which defines the Diffie-Hellman assumption itself:
     \begin{itemize}
     \item $\texttt{expand\ CDH(}G, Z, g, \vn{exp}, \vn{exp}', \vn{mult}, p\texttt{).}$ says that the group $G$ satisfies the computational
  Diffie-Hellman assumption; $p(t)$ is the probability of breaking the CDH assumption, for one pair of exponents, in time $t$.
   This macro defines the equivalence $\texttt{cdh}(\vn{exp})$, whichs corresponds to the CDH property, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

     \item $\texttt{expand\ CDH\_RSR(}G, Z, g, \vn{exp}, \vn{exp}', \vn{mult}, p\texttt{).}$ 
       is similar to \texttt{CDH}, but uses random self reducibility. It may yield lower probabilities but requires the exponents 
       to be chosen uniformly in $(\mathbb{Z}/q\mathbb{Z})^*$ or in $\mathbb{Z}/q\mathbb{Z}$, where $q$ is the order of $g$, 
       so it is not correct for usual implementations of Curve25519 for instance. (The proof is done using uniform choices in $\mathbb{Z}/q\mathbb{Z}$; we add the probability of distinguishing these choices from choices in $(\mathbb{Z}/q\mathbb{Z})^*$ so that the result also applies to choices in $(\mathbb{Z}/q\mathbb{Z})^*$, as assumed in \texttt{DH\_good\_group} and as often done in Diffie-Hellman implementations. Indeed, 0 is a bad secret key, since with a 0 secret key, the Diffie-Hellman shared secret is always the neutral element of the group, independently of the other public key.)

     \item $\texttt{expand\ DDH(}G, Z, g, \vn{exp}, \vn{exp}', \vn{mult}, p\texttt{).}$
       says that the group $G$ satisfies the decisional Diffie-Hellman
       assumption; $p(t)$ is the probability of breaking the DDH
       assumption, for one pair of exponents, in time $t$.
   This macro defines the equivalence $\texttt{ddh}(\vn{exp})$, whichs corresponds to the DDH property, for use in the
   \texttt{crypto} command (see Section~\ref{sec:interact}).

     \item $\texttt{expand\ GDH(}G, Z, g, \vn{exp}, \vn{exp}', \vn{mult}, p\texttt{).}$
       says that the group $G$ satisfies the gap Diffie-Hellman
       assumption (GDH). The probability $p(t,n)$ is the probability of breaking
       the GDH assumption for one pair of exponents in time $t$ with at most $n$ 
       calls to the decisional Diffie-Hellman oracle. This macro defines
       the equivalence $\texttt{gdh}(\vn{exp})$, whichs corresponds to the GDH property, for use in the
       \texttt{crypto} command (see Section~\ref{sec:interact}).

     \item $\texttt{expand\ GDH\_RSR(}G, Z, g, \vn{exp}, \vn{exp}', \vn{mult}, p\texttt{).}$ 
       is similar to \texttt{GDH}, but uses random self reducibility. It may yield lower probabilities but requires the exponents 
       to be chosen uniformly in $(\mathbb{Z}/q\mathbb{Z})^*$ or in $\mathbb{Z}/q\mathbb{Z}$, where $q$ is the order of $g$, 
       so it is not correct for usual implementations of Curve25519 for instance.

     \item
       $\texttt{expand\ square\_CDH(}G, Z, g, \vn{exp}, \vn{exp}',
       \vn{mult}, p, \vn{sqp}\texttt{).}$
       says that the group $G$ satisfies the computational
       Diffie-Hellman assumption and the square computational
       Diffie-Hellman assumption; $p(t)$ is the probability of
       breaking the CDH assumption, for one pair of exponents, in time
       $t$ and $\vn{sqp}(t)$ is the probability of breaking the square
       CDH assumption, for one pair of exponents, in time $t$.  This
       macro defines the equivalence $\texttt{cdh}(\vn{exp})$, whichs
       corresponds to the (square) CDH property, for use in the
       \texttt{crypto} command (see Section~\ref{sec:interact}). When
       the group has prime order, the computational Diffie-Hellman
       assumption is equivalent to the square variant, but CryptoVerif
       can do more proofs using the square variant. (It allows
       transforming $\vn{exp}(g, \vn{mult}(x,x))$.)

     \item
       $\texttt{expand\ square\_CDH\_RSR(}G, Z, g, \vn{exp},
       \vn{exp}', \vn{mult}, \vn{sqp}\texttt{).}$
       says that the group $G$ satisfies the square computational
       Diffie-Hellman assumption; $\vn{sqp}(t)$ is the probability of
       breaking the square CDH assumption, for one pair of exponents,
       in time $t$.  This macro defines the equivalence
       $\texttt{cdh}(\vn{exp})$, whichs corresponds to the square CDH
       property, for use in the \texttt{crypto} command (see
       Section~\ref{sec:interact}). It uses random self
       reducibility. It may yield lower probabilities than
       $\texttt{square\_CDH}$ but requires the exponents to be chosen
       uniformly in $(\mathbb{Z}/q\mathbb{Z})^*$ or in $\mathbb{Z}/q\mathbb{Z}$, where $q$ is the order
       of $g$, so it is not correct for usual implementations of Curve25519 for instance.

     \item
       $\texttt{expand\ square\_DDH(}G, Z, g, \vn{exp}, \vn{exp}',
       \vn{mult}, p, \vn{sqp}\texttt{).}$
       says that the group $G$ satisfies the decisional Diffie-Hellman
       assumption and the square decisional Diffie-Hellman assumption;
       $p(t)$ is the probability of breaking the DDH assumption, for
       one pair of exponents, in time $t$ and $\vn{sqp}(t)$ is the
       probability of breaking the square DDH assumption, for one pair
       of exponents, in time $t$.  This macro defines the equivalence
       $\texttt{ddh}(\vn{exp})$, whichs corresponds to the (square)
       DDH property, for use in the \texttt{crypto} command (see
       Section~\ref{sec:interact}).

     \item
       $\texttt{expand\ square\_GDH(}G, Z, g, \vn{exp}, \vn{exp}',
       \vn{mult}, p, \vn{sqp}\texttt{).}$
       says that the group $G$ satisfies the gap Diffie-Hellman (GDH)
       assumption and the square gap Diffie-Hellman assumption;
       $p(t,n)$ is the probability of breaking the GDH assumption, for
       one pair of exponents, in time $t$ with at most $n$ 
       calls to the decisional Diffie-Hellman oracle and $\vn{sqp}(t,n)$ is the
       probability of breaking the square GDH assumption, for one pair
       of exponents, in time $t$ with at most $n$ 
       calls to the decisional Diffie-Hellman oracle.  This macro defines the equivalence
       $\texttt{gdh}(\vn{exp})$, whichs corresponds to the (square)
       GDH property, for use in the \texttt{crypto} command (see
       Section~\ref{sec:interact}).

     \item $\texttt{expand\ square\_GDH\_RSR(}G, Z, g, \vn{exp}, \vn{exp}',
       \vn{mult}, \vn{sqp}\texttt{).}$
       says that the group $G$ satisfies the square gap Diffie-Hellman assumption;
       $\vn{sqp}(t,n)$ is the
       probability of breaking the square GDH assumption, for one pair
       of exponents, in time $t$ with at most $n$ 
       calls to the decisional Diffie-Hellman oracle.  This macro defines the equivalence
       $\texttt{gdh}(\vn{exp})$, whichs corresponds to the square
       GDH property, for use in the \texttt{crypto} command (see
       Section~\ref{sec:interact}). It uses random self
       reducibility. It may yield lower probabilities than
       $\texttt{square\_GDH}$ but requires the exponents to be chosen
       uniformly in $(\mathbb{Z}/q\mathbb{Z})^*$ or in $\mathbb{Z}/q\mathbb{Z}$, where $q$ is the order
       of $g$, so it is not correct for usual implementations of Curve25519 for instance.

     \item $\texttt{expand\ PRF\_ODH1(}G, Z, \vn{prf\_in}, \vn{prf\_out}, g, \vn{exp}, \vn{exp}', \vn{mult}, \vn{prf}, p\texttt{).}$ says that the group $G$ satisfies the PRF-ODH1 (pseudo-random function oracle Diffie-Hellman) assumption, which corresponds to PRF-ODHnn in~\cite{eprint2017:517}.
       %
       The pseudo-random function $\vn{prf}(G, \vn{prf\_in}): \vn{prf\_out}$ takes as argument a group element in $G$ and an element in $\vn{prf\_in}$, and produces a result in $\vn{prf\_out}$. The type $\vn{prf\_out}$ must be \texttt{bounded} or \texttt{nonuniform}.
       %
   This assumption means that an adversary that has 2 public Diffie-Hellman keys $\vn{exp}(g,a)$ and $\vn{exp}(g,b)$ for random $a$, $b$ cannot distinguish $x \mapsto \vn{prf}(\vn{exp}(g,\vn{mult}(a,b)),x)$ from a random function. A random function returns a fresh random value when it is called with a new argument and the previous result when it is called with the same argument as a previous call. The probability $p(t, n)$ is the probability of breaking the PRF-ODH1 assumption
   in time $t$ with $n$ queries to $\vn{prf}(\vn{exp}(g,\vn{mult}(a,b)),x)$.
This macro defines the equivalence
       $\texttt{prf\_odh}(\vn{prf})$, whichs corresponds to the PRF-ODH1 property, for use in the \texttt{crypto} command (see
       Section~\ref{sec:interact}).
     \item $\texttt{expand\ PRF\_ODH2(}G, Z, \vn{prf\_in}, \vn{prf\_out}, g, \vn{exp}, \vn{exp}', \vn{mult}, \vn{prf}, p\texttt{).}$ says that the group $G$ satisfies the PRF-ODH2 assumption, which corresponds to PRF-ODHmm in~\cite{eprint2017:517}.
       %
       The types $\vn{prf\_in}$ and $\vn{prf\_out}$ and the pseudo-random function $\vn{prf}$ are defined as for \texttt{PRF\_ODH1}.
       %
       This assumption means that an adversary that has 2 public Diffie-Hellman keys $\vn{exp}(g,a)$ and $\vn{exp}(g,b)$ for random $a$, $b$ and has access to the oracles $(Y,x) \mapsto \vn{prf}(\vn{exp}(Y,a),x)$ and $(X,x) \mapsto \vn{prf}(\vn{exp}(X,b),x)$ cannot distinguish $x \mapsto \vn{prf}(\vn{exp}(g,\vn{mult}(a,b)),x)$ from a random function.
The probability $p(t, n, n')$ is the probability of breaking the PRF-ODH2 assumption
   in time $t$ with $n$ queries to $\vn{prf}(\vn{exp}(g,\vn{mult}(a,b)),x)$ and $n'$ queries to $(Y,x) \mapsto \vn{prf}(\vn{exp}(Y,a),x)$ and $(X,x) \mapsto \vn{prf}(\vn{exp}(X,b),x)$ in total.
This macro defines the equivalence
       $\texttt{prf\_odh}(\vn{prf})$, whichs corresponds to the PRF-ODH2 property, for use in the \texttt{crypto} command (see
Section~\ref{sec:interact}).

     \item $\texttt{expand\ square\_PRF\_ODH1(}G, Z, \vn{prf\_in}, \vn{prf\_out}, g, \vn{exp}, \vn{exp}', \vn{mult}, \vn{prf}, p, \vn{sqp}\texttt{).}$ says that the group $G$ satisfies the square PRF-ODH1 assumption and the PRF-ODH1 assumption.
       %
       The types $\vn{prf\_in}$ and $\vn{prf\_out}$ and the pseudo-random function $\vn{prf}$ are defined as for \texttt{PRF\_ODH1}.
       %
       The square PRF-ODH1 assumption means that an adversary that has a public Diffie-Hellman key $\vn{exp}(g,a)$ for random $a$ cannot distinguish $x \mapsto \vn{prf}(\vn{exp}(g,\vn{mult}(a,a)),x)$ from a random function.
       %
       The probability $\vn{sqp}(t, n)$ is the probability of
       breaking the square PRF-ODH1 assumption in time $t$ with $n$
       queries to $\vn{prf}(\vn{exp}(g,\vn{mult}(a,a)),x)$.
       %
   The probability $p(t, n)$ is the probability of breaking the PRF-ODH1 assumption
   in time $t$ with $n$ queries to $\vn{prf}(\vn{exp}(g,\vn{mult}(a,b)),x)$.
   This macro defines the equivalence
       $\texttt{prf\_odh}(\vn{prf})$, whichs corresponds to the square PRF-ODH1 and PRF-ODH1 properties, for use in the \texttt{crypto} command (see
       Section~\ref{sec:interact}).
     \item $\texttt{expand\ square\_PRF\_ODH2(}G, Z, \vn{prf\_in}, \vn{prf\_out}, g, \vn{exp}, \vn{exp}', \vn{mult}, \vn{prf}, p, \vn{sqp}\texttt{).}$ says that the group $G$ satisfies the square PRF-ODH2 assumption and the PRF-ODH2 assumption.
       %
       The types $\vn{prf\_in}$ and $\vn{prf\_out}$ and the pseudo-random function $\vn{prf}$ are defined as for \texttt{PRF\_ODH1}.
       %
       The square PRF-ODH2 assumption means that an adversary that has a public Diffie-Hellman key $\vn{exp}(g,a)$ for random $a$ and has access to the oracle $(Y,x) \mapsto \vn{prf}(\vn{exp}(Y,a),x)$ cannot distinguish $x \mapsto \vn{prf}(\vn{exp}(g,\vn{mult}(a,a)),x)$ from a random function.
The probability $\vn{sqp}(t, n, n')$ is the probability of breaking the square PRF-ODH2 assumption
   in time $t$ with $n$ queries to $\vn{prf}(\vn{exp}(g,\vn{mult}(a,a)),x)$ and $n'$ queries to $(Y,x) \mapsto \vn{prf}(\vn{exp}(Y,a),x)$.
       The probability $p(t, n, n')$ is the probability of breaking the PRF-ODH2 assumption
   in time $t$ with $n$ queries to $\vn{prf}(\vn{exp}(g,\vn{mult}(a,b)),x)$ and $n'$ queries to $(Y,x) \mapsto \vn{prf}(\vn{exp}(Y,a),x)$ and $(X,x) \mapsto \vn{prf}(\vn{exp}(X,b),x)$ in total.
This macro defines the equivalence
       $\texttt{prf\_odh}(\vn{prf})$, whichs corresponds to the square PRF-ODH2 and PRF-ODH2 properties, for use in the \texttt{crypto} command (see
Section~\ref{sec:interact}).
     \end{itemize}
     The argument $\vn{prf}$ of the PRF-ODH macros is defined by these
     macros.  It must not be declared elsewhere, and it can be used
     only after expanding the macro.  All other arguments of these
     macros must be defined before expanding the macro.
     
   \end{itemize}

\iffalse
 \item Another possible set of macros for Diffie-Hellman assumptions is the following.
   \begin{itemize}
   \item $\texttt{expand\ DH\_prime\_subgroup\_secret\_keys\_not\_multiple\_k(}G$, $Z$, $g$, $\vn{exp}$, $\vn{exp}'$, $\vn{expblock}$, $\vn{mult}$, $\vn{subG}$, $\vn{g\_k}$, $\vn{expsub}$, $\vn{expsub}'$, $\vn{pow\_k}$, $\vn{PCollKey1}$, $\vn{PCollKey2}$, $\vn{PCollKey3}$, $\vn{PCollKey4}\texttt{).}$ defines a Diffie-Hellman group with the following properties.

       $G$: type of group elements (must be \texttt{bounded} and \texttt{large}).   
       $G$ is a group of cardinal $kq$, where $q$ is a large prime and $k$ is a small integer.

       $\vn{subG}$: type of subgroup elements (must be \texttt{bounded} and \texttt{large}). 
       $\vn{subG}$ is a subgroup of $G$ of cardinal $q$.

       $Z$: type of exponents (must be \texttt{bounded} and \texttt{large}). 
       $Z$ is the set of integers modulo $kq$.
       
       $g$: an element of the group $G$, which generates the subgroup $\vn{subG}$.

       $\vn{exp}(G, Z): G$: the exponentiation function.  

       $\vn{exp}'$ is a symbol that replaces $\vn{exp}$ after the GDH game transformation.

       $\vn{expblock}$ is a symbol that replaces $\vn{exp}$ after the $\texttt{use\_subgroup}(\vn{exp})$ transformation, explained below.

       $\vn{mult}(Z,Z): Z$ is the product in $Z$.

       $\vn{g\_k} = g^k$. It is an element of $\vn{subG}$, which generates $\vn{subG}$.

       $\vn{expsub}(\vn{subG},Z): \vn{subG}$ is defined by $\vn{expsub}(X,y) = X^y$.
       
       $\vn{expsub}'$ is a symbol that replaces $\vn{expsub}$ after GDH game transformation,
       defined like $\vn{expsub}$.

       $\vn{pow\_k}(G):\vn{subG}$ is defined by $\vn{pow\_k}(x) = x^k$.
   
       $\vn{PCollKey1}$ is the maximum probability that $g^{kx} = Y$ with $x$ random in $Z$ and with $Y$ independent of $x$.

       $\vn{PCollKey2}$ is the maximum probability that $g^{kxy} = Y$ with $x$ random in $Z$ and with $y$ and $Y$ independent of $x$.

       $\vn{PCollKey3}$ is the maximum of $\vn{PCollKey2}$ and 
                the maximum probability that $g^{kxx} = Y$ with $x$ random in $Z$ and with $Y$ independent of $x$.

       $\vn{PCollKey4}$ is the probability that $y = 0$ modulo $q$ for $y$ random in $Z$.


       $\texttt{use\_subgroup}(\vn{exp})$ transforms
       $\vn{exp}(X,a) = Y$ into
       \[(\vn{expblock}(X,a) = Y) \ \&\&\ (\vn{expsub}(\vn{pow\_k}(X),a) =
       \vn{pow\_k}(Y))\]
       $X^a = Y$ implies $(X^a)^k = Y^k$ that is $(X^k)^a = Y^k$, and
       in the latter equality $X^k$ and $Y^k$ are in the subgroup
       generated by $g$, so we can apply more equalities.  Since
       $X^a = Y$ is not equivalent to $(X^k)^a = Y^k$, we keep the
       original equality $X^a = Y$ as well, but replace $\vn{exp}$
       with $\vn{expblock}$ to avoid a loop. The transformation
       $\texttt{use\_subgroup}(\vn{exp})$ should be applied before
       GDH, using \texttt{crypto} command (see
       Section~\ref{sec:interact}).
       
       The types $G$, $\vn{subG}$, and $Z$ and the probabilities $\vn{PCollKey1}$, $\vn{PCollKey2}$, 
       $\vn{PCollKey3}$, $\vn{PCollKey4}$ must be declared before this macro.  The
       functions $g$, $\vn{exp}$, $\vn{exp}'$, $\vn{expblock}$, $\vn{mult}$, $\vn{g\_k}$, $\vn{expsub}$, $\vn{expsub}'$, $\vn{pow\_k}$
       are defined by this macro. They must not be declared
       elsewhere, and they can be used only after expanding the macro.

       For instance, these properties are typically satisfied by Curve25519 when
       the secret keys are not normalized (that is, they may not be multiple of 8).

   \item One of the following two macros:
     \begin{itemize}
     \item $\texttt{expand\ GDH\_subgroup(}G$, $Z$, $g$, $\vn{exp}$, $\vn{exp}'$, $\vn{expblock}$, $\vn{mult}$, $\vn{subG}$, $\vn{g\_k}$, $\vn{expsub}$, $\vn{expsub}'$, $\vn{pow\_k}$, $p\texttt{).}$ says that the group $G$ satisfies the gap Diffie-Hellman
       assumption (GDH). It applies the computational Diffie-Hellman assumption in the subgroup $\vn{subG}$, but allows decisional Diffie-Hellman oracle queries in the whole group $G$. The probability $p(t,n)$ is the probability of breaking
       the GDH assumption for one pair of exponents in time $t$ with at most $n$ 
       calls to the decisional Diffie-Hellman oracle. This macro defines
       the equivalence $\texttt{gdh}(\vn{exp})$, whichs corresponds to the GDH property, for use in the
       \texttt{crypto} command (see Section~\ref{sec:interact}).

     \item $\texttt{expand\ square\_GDH\_subgroup(}G$, $Z$, $g$, $\vn{exp}$, $\vn{exp}'$, $\vn{expblock}$, $\vn{mult}$, $\vn{subG}$, $\vn{g\_k}$, $\vn{expsub}$, $\vn{expsub}'$, $\vn{pow\_k}$, $p$, $\vn{sqp}\texttt{).}$ 
       says that the group $G$ satisfies the gap Diffie-Hellman (GDH)
       assumption and the square gap Diffie-Hellman assumption. It applies the (square) computational Diffie-Hellman assumption in the subgroup $\vn{subG}$, but allows decisional Diffie-Hellman oracle queries in the whole group $G$.
       The probability $p(t)$ is the probability of breaking the GDH assumption, for
       one pair of exponents, in time $t$ with at most $n$ 
       calls to the decisional Diffie-Hellman oracle and $\vn{sqp}(t)$ is the
       probability of breaking the square GDH assumption, for one pair
       of exponents, in time $t$ with at most $n$ 
       calls to the decisional Diffie-Hellman oracle.  This macro defines the equivalence
       $\texttt{gdh}(\vn{exp})$, whichs corresponds to the (square)
       GDH property, for use in the \texttt{crypto} command (see
       Section~\ref{sec:interact}).
     \end{itemize}
     We do not define other properties in this case, because we
     believe that for simpler examples that require only CDH or DDH,
     it should be possible to use \texttt{DH\_proba\_collision}
     together with CDH or DDH, which also applies to this kind of
     groups.

   \end{itemize}
\fi  
\item $\texttt{expand\ Xor(}D, \vn{xor}, \vn{zero}\texttt{).}$ defines the
  function symbol $\vn{xor}$ to be exclusive or on the set of
  bitstrings $D$, where $\vn{zero}$ is the bitstring consisting only
  of zeroes in $D$. $D$ should be \texttt{fixed}.

  The type $D$ must be declared before this macro is expanded. The
  function $\vn{xor}$ and the constant $\vn{zero}$ are declared by
  this macro.  They must not be declared elsewhere, and they can be
  used only after expanding the macro.

   This macro defines the equivalence named $\texttt{remove\_xor}(\vn{xor})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}).

\item $\texttt{expand\ keygen(}\vn{keyseed}, \vn{key}, \vn{kgen}\texttt{).}$
defines a key generation function $\vn{kgen}$. It can be used to add a key
generation function to symmetric cryptographic primitives, if needed.

$\vn{keyseed}$ is the type of key seeds, must be \texttt{bounded} or \texttt{nonuniform} (to be able to generate random numbers from it), typically \texttt{fixed}, and \texttt{large}.

$\vn{key}$ type of keys, must be \texttt{bounded}.

$\vn{kgen}(\vn{keyseed}): \vn{key}$ is the key generation function.

The types $\vn{keyseed}$ and $\vn{key}$ must be declared before this
macro is expanded. The function $\vn{kgen}$ is declared by this
macro. It must not be declared elsewhere, and it can be used only
after expanding the macro.

This macro defines the equivalence named $\texttt{keygen}(\vn{kgen})$
   for use in the \texttt{crypto} command 
   (see Section~\ref{sec:interact}).

\item
  $\texttt{expand\ Auth\_Enc\_from\_Enc\_then\_MAC(}\vn{key}, \vn{cleartext}, \vn{ciphertext}, \vn{enc}, \vn{dec}, \vn{injbot}, \vn{Z}, \vn{Penc}, \vn{Pmac}\texttt{).}$ defines an authenticated encryption scheme, built by encrypt-then-MAC from an IND-CPA encryption scheme and an SUF-CMA deterministic MAC.

  The arguments are the same as for \texttt{IND\_CPA\_INT\_CTXT\_sym\_enc} except that $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property of the underlying encryption scheme in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$, and
  $\vn{Pmac}(t, N, N', \vn{Nu}', l)$ is the probability of breaking the SUF-CMA
   property of the underlying MAC scheme in time $t$ for one key, $N$ MAC queries, $N'$ verification
   queries modified by the transformation and $\vn{Nu}$ verification
   queries left unchanged by the transformation for messages of length at most $l$.

 \item 
   $\texttt{expand\ Auth\_Enc\_from\_AEAD(}\vn{key}, \vn{cleartext},
   \vn{ciphertext}, \vn{enc}, \vn{dec}, \vn{injbot}, \vn{Z},
   \vn{Penc}, \vn{Pencctxt}\texttt{).}$ defines an authenticated
   encryption scheme, built from an AEAD scheme using empty additional
   data.

   The arguments are the same as for
   \texttt{IND\_CPA\_INT\_CTXT\_sym\_enc} except that $\vn{Penc}(t, N,
   l)$ is the probability of breaking the IND-CPA property of the
   underlying AEAD scheme in time $t$ for one key and $N$ encryption
   queries with cleartexts of length at most $l$, and
   $\vn{Pencctxt}(t, N, N', l, l', \vn{ld}, \vn{ld}')$ is the
   probability of breaking the INT-CTXT property of the underlying
   AEAD scheme in time $t$ for one key, $N$ encryption queries, $N'$
   decryption queries with cleartexts of length at most $l$ and
   ciphertexts of length at most $l'$, additional data for encryption
   of length at most $\vn{ld}$, and additional data for decryption of
   length at most $\vn{ld}'$.
   
 \item 
   $\texttt{expand\ Auth\_Enc\_from\_AEAD\_nonce(}\vn{key}, \vn{cleartext},
   \vn{ciphertext}, \vn{enc}, \vn{dec}, \vn{injbot}, \vn{Z},
   \vn{Penc}, \vn{Pencctxt}\texttt{).}$ defines an authenticated
   encryption scheme, built from an AEAD scheme with a nonce
   by choosing the nonce randomly at each encryption and
   using empty additional data.

   The arguments are the same as for
   \texttt{IND\_CPA\_INT\_CTXT\_sym\_enc} except that $\vn{Penc}(t, N,
   l)$ is the probability of breaking the IND-CPA property of the
   underlying AEAD scheme in time $t$ for one key and $N$ encryption
   queries with cleartexts of length at most $l$, and
   $\vn{Pencctxt}(t, N, N', l, l', \vn{ld}, \vn{ld}')$ is the
   probability of breaking the INT-CTXT property of the underlying
   AEAD scheme in time $t$ for one key, $N$ encryption queries, $N'$
   decryption queries with cleartexts of length at most $l$ and
   ciphertexts of length at most $l'$, additional data for encryption
   of length at most $\vn{ld}$, and additional data for decryption of
   length at most $\vn{ld}'$.

\item $\texttt{expand AEAD\_from\_Enc\_then\_MAC(}\vn{key},
  \vn{cleartext}$, $\vn{ciphertext}$, $\vn{add\_data}$, $\vn{enc},
  \vn{dec}$, $\vn{injbot}$, $\vn{Z}$, $\vn{Penc}$, $\vn{Pmac}\texttt{).}$ defines an
authenticated encryption scheme with additional data built by encrypt-then-MAC from an IND-CPA encryption scheme and an SUF-CMA deterministic MAC.

The arguments are the same as for \texttt{AEAD} except that $\vn{Penc}(t, N, l)$ is the probability of breaking the IND-CPA
  property of the underlying encryption scheme in time $t$ for one key and $N$ encryption queries with
  cleartexts of length at most $l$, and
  $\vn{Pmac}(t, N, N', \vn{Nu}', l)$ is the probability of breaking the SUF-CMA
   property of the underlying MAC scheme in time $t$ for one key, $N$ MAC queries, $N'$ verification
   queries modified by the transformation and $\vn{Nu}$ verification
   queries left unchanged by the transformation for messages of length at most $l$.

\item 
   $\texttt{expand\ AEAD\_from\_AEAD\_nonce(}\vn{key}$, $\vn{cleartext},
   \vn{ciphertext}$, $\vn{add\_data}$, $\vn{enc}$, $\vn{dec}$, $\vn{injbot}$, $\vn{Z},
   \vn{Penc}$, $\vn{Pencctxt}\texttt{).}$ defines an authenticated
   encryption scheme with additional data, built from an AEAD scheme with a nonce
   by choosing the nonce randomly at each encryption.

   The arguments are the same as for
   \texttt{AEAD} except that $\vn{Penc}(t, N,
   l)$ is the probability of breaking the IND-CPA property of the
   underlying AEAD scheme in time $t$ for one key and $N$ encryption
   queries with cleartexts of length at most $l$, and
   $\vn{Pencctxt}(t, N, N', l, l', \vn{ld}, \vn{ld}')$ is the
   probability of breaking the INT-CTXT property of the underlying
   AEAD scheme in time $t$ for one key, $N$ encryption queries, $N'$
   decryption queries with cleartexts of length at most $l$ and
   ciphertexts of length at most $l'$, additional data for encryption
   of length at most $\vn{ld}$, and additional data for decryption of
   length at most $\vn{ld}'$.

\item $\texttt{expand\ random\_split\_$N$(}\vn{input\_t}, \vn{part1\_t}, \dots,
\vn{partN\_t}, \vn{tuple\_t}, \vn{tuple}, \vn{split}\texttt{).}$ defines allows to split a random 
value into $N$ values, for $N \leq 10$.
   
  $\vn{input\_t}$: type of the input value

  $\vn{part1\_t}, \dots, \vn{partN\_t}$: types of the output parts.

  $\vn{tuple\_t}$: type of a tuple of the output parts

  $\vn{tuple}(\vn{part1\_t}, \dots, \vn{partN\_t}): \vn{tuple\_t}$: builds a tuple from $N$ parts.

  $\vn{split}(\vn{input\_t}): \vn{tuple\_t}$ splits the input into $N$ parts and returns a tuple of these parts. 
  The macro says that if $y$ is a random value in $\vn{input\_t}$, then
$\vn{split}(y)$ is a tuple $\vn{tuple}(x1, \dots, xN)$ of $N$
independent random values in $\vn{part1\_t}, \dots, \vn{partN\_t}$.


  To split a value $y$ of type $\vn{input\_t}$ into $N$ parts 
  of types $\vn{part1\_t}, \dots, \vn{partN\_t}$, write:
  \[\texttt{let}\ \vn{tuple}(x1, \dots, xN) = \vn{split}(y)\ \texttt{in}\ \dots\]
  Note that a priori, CryptoVerif thinks that the pattern-matching
  with $\vn{tuple}(x1, \dots, xN)$ may fail, and thus requires an
  \texttt{else} branch when the \texttt{let} occurs in a term.
  CryptoVerif realizes that the pattern-matching never fails when
  it expands the definition of $\vn{split}$.
  
This macro defines the equivalence named
$\texttt{splitter}(\vn{split})$ which replaces the splitting of a
random number generation in $\vn{input\_t}$ with $N$ independent
random number generations in $\vn{part1\_t}, \dots, \vn{partN\_t}$.

$\vn{input\_t}$, $\vn{part1\_t}, \dots, \vn{partN\_t}$,
$\vn{tuple\_t}$ must be defined before expanding this macro.
$\vn{tuple}$ and $\vn{split}$ are defined by this macro. They must not
be declared elsewhere, and they can be used only after expanding the
macro.

\end{itemize}

\fussy

\section{Interactive Mode}\label{sec:interact}

In interactive mode, the user specifies transformations to perform.
Some of the instructions take a program point (or occurrence)
in the current game as argument.
One should use the command \texttt{show\string_game occ}
or \texttt{out\string_game $f$ occ} (mentioned below) to
display the game with an occurrence number at each program point.
The program points can then be specified as follows:
\begin{itemize}
\item an integer designates the program point labeled by that integer in
  the displayed game.
\item $\texttt{before "}\mathit{regexp}\texttt{"}$ designates the program
  point at the beginning of the line that matches the regular expression
  $\mathit{regexp}$. Regular expressions follow the syntax of regular expressions in the OCaml Str module, see
  \url{https://caml.inria.fr/pub/docs/manual-ocaml-4.07/libref/Str.html}.
  In regular expressions, blackslash ($\backslash$) must be escaped as $\backslash\backslash$, as in OCaml string literals.
  There must be a single line that matches this
  regular expression, otherwise CryptoVerif shows an error message.
  
\item $\texttt{after "}\mathit{regexp}\texttt{"}$ designates the program
  point at the beginning of the first line that has an occurrence number after 
  the line that matches the regular expression
  $\mathit{regexp}$. 
  There must be a single line that matches this
  regular expression, otherwise CryptoVerif shows an error message.

\item $\texttt{before\_nth }n\texttt{ "}\mathit{regexp}\texttt{"}$ designates the program
  point at the beginning of the $n$-th line that matches the regular expression
  $\mathit{regexp}$.  
  
\item $\texttt{after\_nth }n\texttt{ "}\mathit{regexp}\texttt{"}$
  designates the program point at the beginning of the first line
  that has an occurrence number after 
  the $n$-th line that matches the regular expression
  $\mathit{regexp}$.

\item $\texttt{at }n'\texttt{ "}\mathit{regexp}\texttt{"}$
  designates the program point at the $n'$-th occurrence number
  that occurs inside the string that matches the regular expression
  $\mathit{regexp}$ in the displayed game.
  There must be a single match for this
  regular expression, otherwise CryptoVerif shows an error message.
  (With \texttt{at}, if the same line matches the regular expression
  several times, it counts as several matches.)

\item $\texttt{at\_nth }n\ n'\texttt{ "}\mathit{regexp}\texttt{"}$
  designates the program point at the $n'$-th occurrence number
  that occurs inside the string corresponding to the
  $n$-th match of the regular expression
  $\mathit{regexp}$ in the displayed game.
  (With \texttt{at\_nth}, if the same line matches the regular expression
  several times, it counts as several matches.)

\end{itemize}
Using an explicit integer to designate a program point is very unstable:
it changes if the verified protocol is slightly modified, or
if a new version of CryptoVerif itself is used, which may transform
games in a slightly different way.
The other ways of designating program points are therefore preferable
when possible.

When an identifier is expected in an instruction, it is possible
to put it between quotes. This is useful in particular for identifiers
that clash with proof keywords.

Here is a list of available instructions:
\begin{itemize}

\item \texttt{help} or \texttt{?}: display a list of available commands.

\item \texttt{remove\string_assign useless}: remove useless assignments,
that is, assignments to $x$ when $x$ is unused and assignments
between variables.

\item \texttt{remove\string_assign findcond}: removes useless assignments,
as above, as well as assignments ${\tt let}\ x = M\ {\tt in}$ inside
conditions of {\tt find}. 

\item \texttt{remove\string_assign all}: remove all assignments,
by replacing variables with their values. This is not recommended:
you should try to specify which assignments to remove more precisely.

\item $\texttt{remove\string_assign binder}\ x_1\ \dots\ x_n$: remove assignments
to $x_1, \ldots, x_n$ by replacing $x_i$ with its value. When $x_i$ becomes unused,
its definition is removed. When $x_i$ is used only in \texttt{defined} 
tests after transformation, its definition is replaced with 
a constant. The variables $x_i$ may also be regular expressions, 
following the syntax of regular expressions in the OCaml Str module, see
  \url{https://caml.inria.fr/pub/docs/manual-ocaml-4.07/libref/Str.html}.
In this case, they designate all variables that match the regular expression.
This is particularly helpful to designate all variables that come
from the same initial name but have different numbers:
\texttt{"$\mathit{name}$\_[0-9]*"}. Regular expressions 
need to be put between quotes because they use characters that do
not belong to ordinary identifiers. Blackslash ($\backslash$) must then be escaped 
as $\backslash\backslash$, as in OCaml string literals.

\item $\texttt{move }m$: Try to move instructions as follows:
\begin{itemize}

\item Move random number generations down in the syntax tree as much
  as possible, in order to delay the choice of random numbers. This is
  especially useful when the random number generations can be moved
  under a test {\tt if}, {\tt let}, or {\tt find}, so that we can
  distinguish in which branch of the test the random number is created
  by a subsequent \texttt{SArename} instruction.

\item Move assignments down in the syntax tree but without duplicating
  them. This is especially useful when the assignment can be moved
  under a test, in which the assigned variable is used only in one
  branch. In this case, the assigned term is computed in fewer cases
  thanks to this transformation.
  (Note that only assignments without array accesses can be moved,
  because in the presence of array accesses, the computation would have
  to be kept in all branches of the test, yielding a duplication that 
  we want to avoid.)

\end{itemize}
The argument $m$ specifies which instructions should be moved:
\begin{itemize}
\item \texttt{all}: move random number generations and assignments,
when this is beneficial, that is, when they can be moved under a test.
\item \texttt{noarrayref}: move random number generations and assignments
without array accesses, when this is beneficial.
\item \texttt{random}: move random number generations, when this is beneficial.
\item \texttt{random\string_noarrayref}: move random number generations 
without array accesses, when this is beneficial.
\item \texttt{assign}: move assignments, when this is beneficial.
\item $\texttt{binder }x_1\ \dots\ x_n$: move random number generations and assignments
that define $x_1, \ldots, x_n$ (even when this is not beneficial).
The variables $x_i$ may also be regular expressions.
\item $\texttt{array }x\ [\texttt{"}exp\texttt{", }\dots\texttt{, "}exp\texttt{"}]$: 
move random number generations that define $x$
when $x$ is of a {\tt bounded} or {\tt nonuniform} type and $x$ is not used in
the process that defines it, until the next output after the definition of $x$.
$x$ is then chosen at the point where it is really first used. 
(Since this point may depend on the trace, the uses of $x$ are often
transformed into {\tt find} instructions that test whether $x$ has been 
chosen before, and reuse the previously chosen value if this is true.)

The expressions $\texttt{"}exp\texttt{"}$ allow the user to specify expressions
that do no require the generation of $x$ when it has not been generated before,
because the expression always yields the same result when $x$ is a fresh
random value, up to negligible probability. More precisely, these expressions must be of the form
\[[\texttt{forall }\seq{vartype}\texttt{;}]\ \Resavt\texttt{;}\ \nonterm{simpleterm}\]
The expression can be $\texttt{forall }y_1:T_1, \dots, y_n:T_n\texttt{; new }x':T\texttt{; }M$,
where $T$ is the type of $x$ and $y_1, \dots, y_n, x'$ are the variables of $M$.
CryptoVerif tries to simplify $M$ into a term $M'$ that does not contain $x'$,
assuming that $x'$ is random and $y_1, \dots, y_n$ are independent of $x'$.
If it fails, the \texttt{move array} transformation fails.
If it succeeds, the transformation can be performed, replacing
$M\{x/x'\}$ with $M'$ instead of generating a fresh $x$.

When no expression $\texttt{"}exp\texttt{"}$ is mentioned,
the expressions 
that do no require the generation of $x$ are equality tests with 
$x$, and the type $T$ of $x$ must be large enough, so that 
collisions between $x$ and a value independent of $x$ can be eliminated
($\texttt{Pcoll1rand}(T) \leq 2^{-n'}$, that is, $T$ has option
  \texttt{pcoll$n$} with $n \geq n'$ where $n'$ is set by 
$\texttt{set minAutoCollElim} = \texttt{pest}n'$; the default is $n' = 80$). 
%Internally, this is implemented by calling a cryptographic transformation.

The variables $x$ may also be a regular expression. 
In this case, it designates all variables that match the regular expression;
all these variables must have the same type.
\end{itemize}

\item \texttt{simplify}: simplify the game.

\item $\texttt{simplify coll\_elim(variables:}\ x_1, \ldots, x_n\texttt{; types:}t_1, \ldots, t_{n'}\texttt{; terms:}occ_1, \ldots, occ_{n''}\texttt{)}$: simplify the game,
additionally allowing elimination of collisions on data 
at all occurrences of variables
$x_1, \ldots, x_n$, at all data of types $t_1, \ldots, t_{n'}$,
and at the program points $occ_1, \ldots, occ_{n''}$.
See above for how to specify the program points $occ_i$. 
Some of the lists of variables, types, or terms may be omitted.
In this case, the separating semi-colon \texttt{;} is obviously
omitted as well. It is also possible to reorder or repeat these lists; the lists add up.
(The probability of the collision must still satisfy the
condition given by \texttt{allowed\string_collisions}.)

\item $\texttt{global\_dep\_anal}\ x$ performs global dependency
  analysis on $x$: it computes all variables that depend on $x$, and
  when possible, shows that all output messages are independent of $x$
  and that all tests are independent of $x$ after eliminating
  collisions. The tests are then simplified by eliminating these
  collisions, so that all dependencies on $x$ can be removed.

$\texttt{global\_dep\_anal}\ x\ \texttt{coll\_elim(variables:}\ x_1, \ldots, x_n\texttt{; types:}t_1, \ldots, t_{n'}\texttt{; terms:}occ_1, \ldots, occ_{n''}\texttt{)}$ 
performs global dependency analysis on $x$, 
additionally allowing elimination of collisions on data 
at all occurrences of variables
$x_1, \ldots, x_n$, at all data of types $t_1, \ldots, t_{n'}$,
and at the program points $occ_1, \ldots, occ_{n''}$.
See above for how to specify the program points $occ_i$. 
Some of the lists of variables, types, or terms may be omitted.
In this case, the separating semi-colon \texttt{;} is obviously
omitted as well. It is also possible to reorder or repeat these lists; the lists add up.
(The probability of the collision must still satisfy the
condition given by \texttt{allowed\string_collisions}.)

One must allow elimination on $x$ independently of the program point, 
so if $x$ is not large, $x$ must be mentioned in $x_1, \ldots, x_n$
or its type must be mentioned in $t_1, \ldots, t_n$;
mentioning the occurrences of $x$ in $occ_1, \ldots, occ_{n''}$
is not sufficient.

The variable $x$ may also be a regular expression.
In this case, it designates all variables that match the regular expression,
and the command \texttt{global\_dep\_anal} is executed for each of these variables in
turn.

\item $\texttt{SArename }x$: When $x$ is defined at several places,
rename $x$ to a different name for each definition. This is useful for
distinguishing cases depending on which definition of $x$ is used.
The variable $x$ may also be a regular expression.
In this case, it designates all variables that match the regular expression,
and the command \texttt{SArename} is executed for each of these variables in
turn.

\item \texttt{all\string_simplify}: perform several simplifications 
on the game, as if 
\begin{itemize}
\item \texttt{simplify}, 
\item \texttt{move all} if \texttt{autoMove = true}, 
\item \texttt{remove\string_assign useless} if \texttt{autoRemoveAssignFindCond = false}, \\
\texttt{remove\string_assign findcond} if \texttt{autoRemoveAssignFindCond = true},
\item and \texttt{merge\string_branches} if \texttt{autoMergeBranches = true}
\end{itemize}
had been called.

\item \texttt{expand}: expand \texttt{if}, \texttt{let}, \texttt{find},
\texttt{event}, \texttt{event\_abort}, \texttt{new} terms into processes.
That leads to distinguishing the branches until the end of the process,
which may help the proof by distinguishing more cases, but
may lead to very large games.
This is also needed because some game transformations of CryptoVerif
do not support non-expanded games.
When \texttt{autoExpand = true} (the default), this expansion
is performed automatically in case a game transformation results
in a non-expanded game. 

\item \texttt{crypto} \ldots: applies a cryptographic transformation
that comes from a statement \texttt{equiv}. This command can
have several forms:
\begin{itemize}

\item \texttt{crypto}: list all available \texttt{equiv} statements,
and ask the user to choose which one should be applied, 
with which variables of the game corresponding to random number generations
of the left-hand side of the equivalence.

\item $\texttt{crypto }\nonterm{name}\ \texttt{*}$: apply a cryptographic
transformation determined by the name $\nonterm{name}$. 
This name can be either an identifier $\mathit{id}$ or $\mathit{id}(f)$, 
and corresponds to the name given at the declaration of the 
cryptographic transformation by \texttt{equiv}.
In case the name is not found, CryptoVerif reverts to the
old way of designating cryptographic transformations, in which
$\nonterm{name}$ can be either a
function symbol that occurs in the terms in the left-hand side of the
\texttt{equiv} statement, or a probability function that occurs in the
probability formula of the \texttt{equiv} statement.
When several equivalences correspond, the user is prompted for choice.
The transformation is applied as many times as possible. (In this
case, the advised transformations are applied automatically even when
\texttt{set autoAdvice = false}.)

\item $\texttt{crypto }\nonterm{name}\ \texttt{**}$: similar to 
$\texttt{crypto }\nonterm{name}\ \texttt{*}$, but the game is simplified
only after the last cryptographic transformation instead of simplifying it
after each transformation, for faster execution. This is recommended
only for very simple cryptographic transformations.

\item $\texttt{crypto }\nonterm{name}\ x_1\ \ldots\ x_n$: apply a cryptographic
transformation chosen as above, where $x_1, \ldots, x_n$ are variable
names of the game corresponding to random number generations 
in the left-hand side of the
equivalence. (CryptoVerif may automatically add variables to the list
$x_1, \ldots, x_n$ if needed, except when a dot is added at the end of
the list $x_1, \ldots, x_n$. The transformation is applied only once.
If several disjoint lists $x_1, \ldots, x_n$ are possible and no variable
name is mentioned, CryptoVerif makes a choice. It is better to mention
at least one variable name when the left-hand side of the equivalence
contains a random number generation, to make explicit which transformation 
should be applied.)

In case the command ends with a dot ($\texttt{.}$), CryptoVerif never adds 
other variable names to those already listed. If the dot is absent,
CryptoVerif may add other variable names if that seems necessary to perform
the transformation.

The variables $x_i$ may also be regular expressions.
In this case, they designate all variables that match the regular expression.

\item $\texttt{crypto }\nonterm{name}\ 
\texttt{[variables: }x_1\texttt{->}y_1,\ldots, x_n\texttt{->}y_n
\texttt{; terms: }occ_1\texttt{->}O_1,\ldots,occ_m\texttt{->}O_m\texttt{]}$:
apply a cryptographic transformation chosen as above, where
\begin{itemize}

\item $x_1, \ldots, x_n$ are variable names of the game which
  correspond to random number generations $y_1, \ldots, y_n$
  respectively in the left-hand side of the equivalence. (CryptoVerif
  may automatically add variables to the list
  $x_1\texttt{->}y_1,\ldots, x_n\texttt{->}y_n$ if needed, except when
  a dot is added at the end of this list.)

The variables $x_i$ may also be regular expressions.
In this case, they designate all variables that match the regular expression,
and they are mapped to the same variable $y_i$ in the equivalence.

\item $occ_1, \ldots, occ_m$ are program points at which terms 
  will be transformed using oracles $O_1, \ldots, O_m$ respectively of
  the equivalence. See above for how to specify the program points $occ_i$. 
  (CryptoVerif may automatically add elements to the
  list $occ_1\texttt{->}O_1,\ldots,\ab occ_m\texttt{->}O_m$ if needed, except
  when a dot is added at the end of this list.)

\end{itemize}
When the considered equivalence is defined inside a macro,
macro expansion may add an integer suffix \texttt{\_$k$} to the variable
and oracle names of the equivalence (or may modify that suffix if
they already have one). This suffix must be included in
the variable and oracle names used in this command.
This happens in particular for primitives defined in the
library of primitives of CryptoVerif. The right value of $k$ in the
suffix can be determined by issuing a command \texttt{crypto} without
further indication. This command will display the equivalences
as they are stored by CryptoVerif after macro expansion.

One of the lists of variables or terms may be omitted.
In this case, the separating semi-colon \texttt{;} is obviously
omitted as well. It is also possible to reorder or repeat the
\texttt{variables} and /or \texttt{terms} lists; the lists add up.

\end{itemize}


\item $\texttt{insert\string_event }e\ occ$ replaces the subprocess or term at
program point $occ$ with the event $\texttt{event }e$. The games may
be distinguished if and only if the event $e$ is executed, and CryptoVerif
then tries to find a bound for the probability of executing that event.
See above for how to specify the program point $occ$.
The program point $occ$ must correspond to an output process
(resp. oracle body in the oracles front-end) or to a term not in a
condition of {\tt find} nor in the channel of an input.

When the setting {\tt autoExpand} is true and the occurrence $occ$
corresponds to a term, the game is automatically expanded after
inserting the event, so that after expansion the event occurs in a
process, not in a term.

\item $\texttt{insert}\ occ\ \texttt{"}ins\texttt{"}$ inserts instruction $ins$ at
program point $occ$. The instruction $ins$ can be 
\begin{align*}
&\texttt{new\ }\nonterm{vartype}\\
&\texttt{if }\nonterm{cond}\texttt{ then}\\
&\texttt{event }\nonterm{ident}[\texttt{(}\seq{term}\texttt{)}]\\
&\texttt{let }\nonterm{pattern} \texttt{ = }\nonterm{term}\ \texttt{in}\\
&\texttt{find}[\texttt{[unique]}]\ \nonterm{findbranch}\ (\texttt{orfind }\nonterm{findbranch})^*
\end{align*}
or in the oracles front-end
\begin{align*}
&\nonterm{ident}\texttt{ <-R }\nonterm{ident}\\
&\texttt{if }\nonterm{cond}\texttt{ then}\\
&\texttt{event }\nonterm{ident}[\texttt{(}\seq{term}\texttt{)}]\\
&\nonterm{ident}[\texttt{:}\nonterm{ident}] \texttt{ <- }\nonterm{term}\\
&\texttt{let }\nonterm{pattern} \texttt{ = }\nonterm{term}\ \texttt{in}\\
&\texttt{find}[\texttt{[unique]}]\ \nonterm{findbranch}\ (\texttt{orfind }\nonterm{findbranch})^*
\end{align*}
where $\nonterm{findbranch} ::= \seq{identbound} \texttt{ suchthat }\nonterm{cond}\texttt{ then}$

In contrast to the initial game, the terms {\tt new}, {\tt if}, {\tt
  find}, or {\tt let} are not expanded, so {\tt if}, {\tt find}, {\tt
  let} can occur only in conditions of {\tt find} and {\tt new} must
not occur as a term.
%
The variables of the inserted instruction are not renamed, so one must
be careful when redefining variables with the same name. In
particular, one is not allowed to add a new definition for a variable
on which array accesses are done (because it could change the result
of these array accesses).
%
The obtained game must satisfy the required invariants (each variable
is defined at most once in each branch of {\tt if}, {\tt find}, or {\tt let};
each usage of a variable $x$ must be either $x$ without array index syntactically
under its definition, inside a {\tt defined} condition of a find, or
$x[M_1, \dots, M_n]$ under a {\tt defined} condition that contains $x[M_1, \dots, M_n]$ 
as a subterm). 
%
In case the inserted instruction is not appropriate, an error
message explaining the problem is displayed.

The obtained game is indistinguishable from the initial game.
The main practical usage of this command is to introduce case
distinctions ({\tt if}, {\tt find}, or {\tt let} with a pattern that
is not a variable). In this situation, the process that follows the
insertion point is duplicated in each branch of {\tt if}, {\tt find},
or {\tt let}, and can subsequently be transformed in different ways in
each branch. 
%
It may be useful to disable the merging of branches in simplification
by \texttt{set autoMergeBranches = false} when a case distinction is
inserted, so that the operation is not immediately undone at the next
simplification.

See above for how to specify the program point $occ$. 
The program point $occ$ must
correspond to an output process (resp. oracle body in the oracles
front-end).

\item $\texttt{replace}\ occ\ \texttt{"}term\texttt{"}$ replaces the term at program point
  $occ$ with the term $term$. Obviously, CryptoVerif must be able to
  prove that these two terms are equal.
  These terms must not contain \texttt{if}, \texttt{let},
  \texttt{find}, \texttt{new}, \texttt{event}, \texttt{event\_abort}, \texttt{insert}, \texttt{get}.
See above for how to specify the program point $occ$. 
The program point $occ$ must correspond to a term not containing \texttt{if}, \texttt{let},
  \texttt{find}, \texttt{new}, \texttt{event}, \texttt{event\_abort}, \texttt{insert}, \texttt{get}.

\item \texttt{merge\_branches} merges the branches of {\tt if}, {\tt
    find}, and {\tt let} when they execute equivalent code. Such a
  merging is already done in simplification, but
  \texttt{merge\_branches} goes further. It performs several merges
  simultaneously and takes into account that merges may remove array
  accesses in conditions of {\tt find} and thus allow further
  merges. Moreover, it advises {\tt merge\_arrays} when variables with
  different names and with array accesses are used in the branches
  that we may want to merge.

\item $\texttt{merge\_arrays } x_{11}\ \ldots\ x_{1n} \texttt{ , }
  \ldots \texttt{ , } x_{k1}\ \ldots\ x_{kn}$ takes as argument $k$
  lists of $n$ variables separated by commas. It merges the variables
  $x_{i1}, \ldots, x_{in}$ into $x_{i1}$. This is useful when these
  variables play the same role in different branches of {\tt if}, {\tt
    find}, {\tt let}: merging them into a single variable may allow to
  merge the branches of {\tt if}, {\tt find}, {\tt let} by
  \texttt{merge\_branches}. 

  The $k$ lists to merge must contain the same number of variables $n$
  (at least 2). Variables $x_{ij}$ and $x_{i'j'}$ for $i \neq i'$ must
  never be simultaneously defined for the same value of their array
  indices.  Variables $x_{ij}$ must have the same type and the same
  array indices for all $j$. Each variable $x_{ij}$ must have a single
  definition, and must not be used in queries.

  In general, the variables $x_{i1}$ should preferably belong to the
  \texttt{else} branch of the {\tt if}, {\tt find}, {\tt let} that we
  want to merge later. Indeed, the code of the {\tt else} branch is
  often more general than the code of the other branches (which may
  exploit the conditions that are tested), so merging towards the code
  of the {\tt else} branch works more often.

  The variables $x_{1j}$ should preferably be defined above the
  variables $x_{ij}$ for any $i > 1$. If this is true, we can
  introduce special variables $y_j$ at the definition site of $x_{1j}$
  which are used only for testing that branch $j$ has been executed.
  This allows the merge to succeed more often.

\item \texttt{start\_from\_other\_end}: for proofs of indistinguishability
  only (\texttt{equivalence}), instruct CryptoVerif to start transforming
  from the other game. When your input file contains
  $\texttt{equivalence}\ Q_1\ Q_2$, CryptoVerif initally works on the first  
  process $Q_1$. When you issue the command \texttt{start\_from\_other\_end},
  CryptoVerif stores your current state, and starts working from $Q_2$.
  If you issue \texttt{start\_from\_other\_end} again, it will store
  what you did from $Q_2$, and will restart working from the end of the
  sequence that you built from $Q_1$. This command allows you to
  alternate between the sequence that starts from $Q_1$ and the one that
  starts from $Q_2$. The property is proved when both sequences end with the
  same game (which you can check with the command \texttt{success}, as usual).
  
\item \texttt{quit}: terminate execution.

\item \texttt{success}: test whether the desired properties are
proved in the current game. If yes, display the proof and stop.
Otherwise, wait for further instructions.

\item \texttt{success simplify}: run \texttt{success} then \texttt{simplify}, with the following addition. The command \texttt{success} collects information that is known to be true when the adversary manages to break at least one of the desired properties. The first iteration of \texttt{simplify} removes parts of the game that contradict this information and replaces them with \texttt{event adv\_loses}.

\item \texttt{show\string_game}: display the current game.

\item \texttt{show\string_game occ}: display the current game with
  occurrence numbers. Useful for some commands that require specifying a
  program point; see above for how program point are specified.

\item \texttt{show\string_state}: display the whole sequence
of games until the current game.

\item $\texttt{show\string_facts}\ occ$: show the facts that are proved
by CryptoVerif in the current game, at the program point $occ$. 
See above for how to specify the program point $occ$.
This command is mainly helpful for debugging.

\item \texttt{out\string_game $f$}: output the current game to file $f$.
  (Be careful: file $f$ will be overwritten if it already exists.)

\item \texttt{out\string_game $f$ occ}: output the current game with
  occurrence numbers to file $f$. Useful for some commands that require specifying a
  program point; see above for how occurrences are specified.
  (Be careful: file $f$ will be overwritten if it already exists.)

\item \texttt{out\string_state $f$}: output the whole sequence
of games until the current game to file $f$.
  (Be careful: file $f$ will be overwritten if it already exists.)

\item $\texttt{out\string_facts}\ f\ occ$: output the facts that are proved
  by CryptoVerif in the current game, at the program point $occ$,
  to file $f$. 
See above for how to specify the program point $occ$.
This command is mainly helpful for debugging.
  (Be careful: file $f$ will be overwritten if it already exists.)

\item \texttt{auto}: switch to automatic mode; try to
terminate the proof automatically from the current game.

\item $\texttt{set }\nonterm{parameter}\texttt{ = }\nonterm{value}$:
sets parameters, as the \texttt{set} instruction in input files.

\item \texttt{allowed\string_collisions} determines when to eliminate collisions. This command has two variants:
\begin{itemize}
\item \texttt{allowed\string_collisions} $\nonterm{formulas}$: 
$\nonterm{formulas}$ is 
a comma-separated list of formulas of the form
$\nonterm{psize}_1\texttt{\string^}{n_1} \tttimes \dots \tttimes \nonterm{psize}_k\texttt{\string^}{n_k} / \nonterm{pest}$,
where the exponents $n_i$ can be omitted when equal to 1;
$\nonterm{psize}_i$ is an identifier that determines the size of a
parameter: \texttt{size$n$} for parameters of size $n$, meaning that the parameter is at most $2^n$,
\texttt{small} for size 2, \texttt{passive} or \texttt{default} for size 30,
\texttt{noninteractive} for size 80;
$\nonterm{pest}$ ({\sc p}robability {\sc est}imate) is an identifier 
such that $1/\nonterm{pest}$ estimates a probability. It can take the following values:
\texttt{pest$n$} means that the probability $1/\nonterm{pest}$ is at most $2^{-n}$;
\texttt{password} is equivalent to \texttt{pest20}, i.e. the probability $1/\nonterm{pest}$ is at most $2^{-20}$;
\texttt{large} is equivalent to \texttt{pest160}, i.e. the probability $1/\nonterm{pest}$ is at most $2^{-160}$. (See also the declarations \texttt{param}, \texttt{proba},
and \texttt{type} for explanations of these estimates.)

Collisions are eliminated when their probability 
is at most of the form  $\textit{constant} \times p_1^{n_1} \times \dots \times p_k^{n_k} \times \texttt{Pcoll1rand}(T)$,
where $p_i$ is a parameter of size at most $\nonterm{psize}_i$
and $\texttt{Pcoll1rand}(T)$ is at most the probability estimated by $1/\nonterm{pest}$.
By default, collisions are eliminated for $\textit{anything} \times \texttt{Pcoll1rand}(T)$ when $\texttt{Pcoll1rand}(T) \leq 2^{-160}$ (\texttt{large}),
and for $p \times \texttt{Pcoll1rand}(T)$ when $p \leq 2^2$ (\texttt{small}) and $\texttt{Pcoll1rand}(T) \leq 2^{-20}$ (\texttt{password}).

Additionally, $\nonterm{formulas}$ may also contain elements of the form
$ \texttt{collision} \tttimes \nonterm{psize}_1\texttt{\string^}{n_1} \tttimes \dots \tttimes \allowbreak \nonterm{psize}_k\texttt{\string^}{n_k}$.
These formulas allow the transformation of terms by \texttt{collision} statements, provided 
the number of times the collision statement is applied is at most 
$\textit{constant} \times p_1^{n_1} \times \dots \times p_k^{n_k}$
where $p_i$ is a parameter of size at most $\nonterm{psize}_i$.
By default, \texttt{collision} statements can always be applied.

The default behavior is inspired by what happens in asymptotic security: \texttt{large} means that the probability of collision is asymptotically negligible, while the parameters are always polynomial, so $\textit{constant} \times p_1^{n_1} \times \dots \times p_k^{n_k} \times \texttt{Pcoll1rand}(T)$ is negligible when $T$ is \texttt{large}. Similarly, probabilities given in collision statements are always negligible, while the parameters are always polynomial, so the probability obtained by applying $\textit{constant} \times p_1^{n_1} \times \dots \times p_k^{n_k}$ times a collision statement remains negligible.

\item \texttt{allowed\string_collisions} $\nonterm{pest}$, where $\nonterm{pest}$ estimates a probability: \texttt{pest$n$} means that the probability is at most $2^{-n}$;
\texttt{password} is equivalent to \texttt{pest20}, i.e. probability at most $2^{-20}$;
\texttt{large} is equivalent to \texttt{pest160}, i.e. probability at most $2^{-160}$. Collisions are eliminated when their probability, taking into account how many times they are applied, is at most the probability specified by $\nonterm{pest}$. This behavior fits the exact security framework nicely: we eliminate collisions when they have a small enough probability.

\end{itemize}
\item $\texttt{focus}\ \texttt{"}\nonterm{querydecl}\texttt{"}, \dots, \texttt{"}\nonterm{querydecl}\texttt{"}$ where
  $\nonterm{querydecl} ::= \texttt{query }[\seq{vartypeb}\texttt{;}]\nonterm{query} (\texttt{;}\allowbreak\nonterm{query})^*$
  follows the syntax of query declarations given in Section~\ref{sec:channels} without the final dot:
  tell CryptoVerif to try to prove only the mentioned queries, ignoring all other queries.
  That sometimes allows to simplify the game further (e.g. remove events that are not used in the queries on which we focus),
  and may allow to prove the mentioned queries.
  The queries are considered equal modulo renaming of variables declared in $\seq{vartypeb}$. When there is no ambiguity, the public variables of the queries can be omitted.
  When the queries on which we focus are all proved,
  CryptoVerif goes back to the state before the last \texttt{focus} command, to try
  to prove the other queries.
  \texttt{undo focus}
  also goes back to the state before the last \texttt{focus} command, to try
  to prove remaining queries.

\item $\texttt{tag }t$: tag the current state with tag $t$ (which can be an identifier or a string).
  This is useful to mark the current state and be able to go back to that state with the command $\texttt{undo}\ t$.

\item $\texttt{undo}$: undo the last transformation.

\item $\texttt{undo}\ n$: undo the last $n$ transformations.

\item $\texttt{undo\ focus}$: go back to the state before the last \texttt{focus} command.
  
\item $\texttt{undo}\ t$: undo the transformations until the last state tagged $t$.

\item \texttt{restart}: restart the proof from the beginning.
(Still simplify automatically the first game.)

\item \texttt{interactive}: starts interactive mode.
Allowed in \texttt{proof} environments, but not when one is
already in interactive mode. Useful to start interactive mode
after some proof steps.

\item \texttt{forget\_old\_games}: removes games before the current one
from memory. That allows to save some memory, but prevents \texttt{undo}
and $\texttt{undo}\ n$.
However, tagged states are not removed from memory, so that the command
$\texttt{undo}\ t$ where $t$ is a tag still works.
Similarly, states before \texttt{focus} commands are not removed from 
memory, so that the command $\texttt{undo\ focus}$ still works.
The display of the games is saved into a temporary file to allow
displaying the games at the end of the proof.
You can save more memory by applying this command systematically with
the setting \texttt{set forgetOldGames = true}.

\end{itemize}
Ctrl-C allows to interrupt a command in interactive mode,
and go back to the state before the beginning of this command.
This feature can be helpful when a command is very slow,
to be able to try another command without waiting for the current command 
to terminate. It may not work under Windows.

The following indications can help finding a proof:
\begin{itemize}

\item When a message contains several nested cryptographic primitives,
it is in general better to apply first the security definition of the
outermost primitive.

\item In order to distinguish more cases, one can start by applying
the security of primitives used in the first messages, before applying
the security of primitives used in later messages.

\end{itemize}
Using a text editor such as \texttt{emacs} to look at games output
by \texttt{out\_game} can be
helpful, in order to use the search function to look for definitions
or usages of variables in large games.  For example, when trying to
prove secrecy of $x$, one may look for usages of $x$, for
definitions of $x$, and for usages of other variables used in those
definitions.

\section{Output of the system}

The system outputs the executed transformations when it performs
them. At the end, it outputs the sequence of games that leads to the
proof of the desired properties. Between consecutive games, it prints
the name of the performed transformation and details of what it
actually did, and the formula giving the difference of probability
between these games (if it is not 0).
The description of the transformation between game may refer to 
program points in the previous game. These program points may not be
completely accurate for the following reasons:
\begin{itemize}
\item When a step of the transformations transforms the same part of 
the game as a previous step, the program point in the second step actually
refers to the code generated by the previous step, so it is not found
in the previously displayed game.
\item When a step transforms part of the game that was duplicated by
a previous step of the transformation, the displayed program point
is in fact ambiguous: one does not know which of the copies is actually
transformed.
\end{itemize}
One can usually clarify the ambiguities by looking at the previous and
next games. 

Lines that begin with \texttt{RESULT} give the proved results.
They may indicate that a property is proved and give 
an upper bound of the probability that the adversary breaks
the property. 
%
In the end, they may also list the properties that could not be
proved, if any.

When the \texttt{-tex} command-line option is specified,
CryptoVerif also outputs a {\LaTeX} file containing the 
sequence of games and the proved properties.

\paragraph{Correspondence between ACSII and {\LaTeX} outputs}

To use nicer and more conventional notations, the {\LaTeX} output sometimes
differs from the ASCII output. Here is a table of correspondence:
\begin{center}
\begin{tabular}{l|l}
ASCII&{\LaTeX}\\
\hline
$\texttt{<=(}p\texttt{)=>}$& $\approx_p$\\
\texttt{\&\&}&$\wedge$\\
\texttt{||}&$\vee$\\
\texttt{<>}&$\neq$\\
\texttt{<=}&$\leq$\\
\texttt{orfind}&$\oplus$\\
\texttt{==>}&$\Longrightarrow$\\
\hline
\multicolumn{2}{l}{\textbf{For the \texttt{channels} front-end}}\\
\hline
$\texttt{in(}c\texttt{,}p\texttt{)}$& $c(p)$\\
$\texttt{in(}c\texttt{,(}p_1, \ldots, p_n\texttt{))}$& $c(p_1, \ldots, p_n)$\\
$\texttt{out(}c\texttt{,}M\texttt{)}$& $\overline{c}\langle M\rangle$\\
$\texttt{out(}c\texttt{,(}M_1, \ldots, M_n\texttt{))}$& $\overline{c}\langle M_1, \ldots, M_n\rangle$\\
$\texttt{!}N$&$!^N$\\
\texttt{yield}& $\overline{0}$\\
\texttt{->}& $\rightarrow$\\
\hline
\multicolumn{2}{l}{\textbf{For the \texttt{oracles} front-end}}\\
\hline
\texttt{<-}&$\leftarrow$\\
\texttt{<-R}&$\stackrel{R}{\leftarrow}$\\
\end{tabular}
\end{center}

\section{Implementation}
\input {impl.tex}



\section*{Acknowledgments}

CryptoVerif was partly developed while the authors were at \'Ecole Normale Sup\'erieure, Paris.

\bibliography{../../dev/allbib/biblio}
\bibliographystyle{abbrv} %alpha

\end{document}
