CryptoVerif can generate an OCaml implementation of the protocol
from the CryptoVerif specification, using the option \texttt{-impl}.

CryptoVerif generates the code for the protocol itself, but the code
for the cryptographic primitives and for interacting with the network
and the application has to be manually written in OCaml. 
\begin{itemize}

\item For the cryptographic primitives, one can specify which OCaml 
function corresponds to which CryptoVerif function as explained in
Section~\ref{sec:implopt} below. For the security guarantees to hold, the OCaml
implementation must satisfy the security assumptions mentioned
in the CryptoVerif specification. The subdirectory \texttt{implementation}
provides a basic implementation for some cryptographic primitives,
in the module \texttt{Crypto}. This module has two implementations:
\begin{itemize}

\item \texttt{crypto\_real.ml} corresponds to real cryptographic primitives,
implemented by relying on the OCaml cryptographic library \texttt{Cryptokit}
(\url{http://forge.ocamlcore.org/projects/cryptokit/}). You need to
install this library in order to run the protocol implementations
generated by CryptoVerif. (It is used at least for random number generation
even if you implement the cryptographic primitives by other means.)

\item \texttt{crypto\_dbg.ml} is a debugging implementation, which 
constructs terms instead of applying the real cryptographic primitives.

\end{itemize}
You can choose which implementation to use by linking \texttt{crypto.ml}
to the desired implementation. If you implement your own protocol,
you will probably need to define your own cryptographic primitives.

The module \texttt{Base} contains functions used by code
generated by CryptoVerif. It should not be modified.

\item The network and application code calls the code generated
by CryptoVerif. From the point of view of security, this code can
be considered as part of the adversary. We require that this code
does not use unsafe OCaml functions (such as \texttt{Obj.magic}
or marshalling/unmarshalling with different types) to bypass the
typesystem (in particular to access the environment of closures
and send it on the network).

We also require that this code does not mutate the values received
from or passed to functions generated by CryptoVerif. This can be
guaranteed by using unmutable types, with the previous requirement.
However, OCaml typically uses \texttt{string} for cryptographic
functions and for network input/output, and the type \texttt{string}
is mutable in OCaml. For simplicity and efficiency, the generated 
code uses the type \texttt{string}, with the requirement mentioned above.

We also require that all data structures manipulated by the generated
code are non-circular. This is necessary because we use OCaml
structural equality to compare values, and this equality may not
terminate in the presence of circular data structures. This can easily
be guaranteed by requiring that all OCaml types declared in the
CryptoVerif input file are non-recursive.

We also require that this code does not fork after obtaining but
before calling an oracle that can be called only once (because it is
not under a replication in the CryptoVerif specification). Indeed,
forking at this point would allow the oracle to be called several times.
In practice, forking generally occurs only at the very beginning of the
protocol, when the server starts a new session, so this requirement
should be easily fulfilled.

Finally, we require that the programs do not perform several
simultaneous writes to the same file and do not simultaneously read
and write in the same file. This requirement could be enforced using
locks, but in practice, it is generally obtained for free if the
programs are run as intended. More precisely, we have two categories
of files:
\begin{itemize}

\item Files that are created to store variables defined in a program
and used in another program, for example, long-term keys generated by
a key generation program, then used by the protocol. These files are
written in one program, and read at the beginning of another
program. These two programs should not be run concurrently, and the
program that writes the file should be run once on each machine,
not several times.

\item Files that store tables of keys. The programs that insert elements 
in the table should be run one at a time. The insertion in the table
is actually appending the file, so the system should support reading the
table while inserting elements in it.  (Elements not yet completely
inserted are ignored.)

\end{itemize}

\end{itemize} 
The subdirectories \texttt{implementation/nspk} and
\texttt{implementation/wlsk} provide two complete examples,
with the CryptoVerif specification and the OCaml network and application
code.


\subsection{Restrictions on the processes for implementation}

The following two constraints must be satisfied:
\begin{itemize}
%%% The next restriction may help us in the proof, but is not really necessary
% \item One cannot have two replications directly under an oracle:
%   $\texttt{!} N\ \texttt{!}N'\ \texttt{in(}\ldots$ is forbidden.

\item \texttt{find} must not be used. You can obtain a similar
result using \texttt{insert} and \texttt{get}, which are supported.

\item 
Let us name ``oracles'' the parts of the process that are between an
$\texttt{in}$/$\nonterm{ident}\texttt{(}\seq{pattern}\texttt{) :=
}\ldots$ and an $\texttt{out}$/$\texttt{return}$ statement,
because in the oracle frontend, they correspond exactly to that.

Let us define the signature of an oracle as the pair containing
\begin{itemize}
\item the type
  $T_1\times\ldots\times T_k \rightarrow T'_1\times\ldots\times T'_n$, 
where $T_1\times\ldots\times T_k$ are the types of the
  arguments expected in the
  $\texttt{in}$/$\nonterm{ident}\texttt{(}\seq{pattern}\texttt{) :=}$
  statement, and $T'_1\times\ldots\times T'_n$ are the types of the result
  given in the $\texttt{out}$/$\texttt{return}$ statements, and

\item the list containing for each of the following oracles,
its name and whether it is under a replication or not.

\end{itemize}
  An oracle can have multiple $\texttt{out}$/$\texttt{return}$
  statements.  To be able to implement it, we must be able to define
  the signature above for each oracle, that is, all
  $\texttt{out}$/$\texttt{return}$ must return the same type of
  elements, and the oracles present after each
  $\texttt{out}$/$\texttt{return}$ statement must be the same.
  Moreover, if an oracle with the same name is defined at several
  places, all its definitions must have the same signature.
\end{itemize}

\subsection{Defining modules}

The syntax of the processes is extended to add annotations, described in
Figure~\ref{fig:syntaxext}. The symbol $::+=$ means that we add the rule at
the right-hand side to the non-terminal symbol at the left-hand side.

\begin{figure}
\begin{align*}
&\nonterm{mod\_opt} ::= \nonterm{ident}
(\texttt{<}\mid\texttt{>})\nonterm{string}\\
&\iprocess ::+= \nonterm{ident} [\texttt{[ }\neseq{mod\_opt}\texttt{ ]}]\texttt{ \{ }\iprocess{}\\
&\text{If channel frontend, }\oprocess ::+= \texttt{out(}\nonterm{channel}\texttt{,
}\nonterm{term}\texttt{)}[\texttt{\}}][\texttt{; }\iprocess]\\
&\text{If oracle frontend, }\oprocess ::+= \texttt{return(}\seq{term}\texttt{)}[\texttt{\}}][\texttt{; }\iprocess]
\end{align*}
\caption{Extensions to the syntax}
\label{fig:syntaxext}
\end{figure}

The terminals $\texttt{\{}$ and $\texttt{\}}$ are used to mark the boundary
of a module. Different modules typically correspond to different
programs, for instance, key generation, client, and server of a protocol.
More precisely, the following two constructs define respectively the beginning and the end of a
module:
\begin{itemize}
\item $\mu\texttt{[}x_1\texttt{>"}\mathit{filex}_1\texttt{",} \ldots\texttt{,} x_n\texttt{>"}\mathit{filex}_n\texttt{",} y_1\texttt{<"}\mathit{filey}_1\texttt{",} \ldots\texttt{,} y_m\texttt{<"}\mathit{filey}_m\texttt{"] \{ } Q$:
The module $\mu$ will contain the oracles defined in $Q$.
The implementation of the module $\mu$ will write the contents of the
variables $x_1, \ldots, x_n$ upon instanciation in the files $\mathit{filex}_1$, \ldots, $\mathit{filex}_n$ respectively. The variables
$x_1, \ldots, x_n$ must be defined under no replication inside module $\mu$. 
These variables can then be used in other modules defined after the end of $\mu$;
these modules will read them automatically from the files $\mathit{filex}_1$, \ldots, $\mathit{filex}_n$ respectively.
The module $\mu$ will read at initialization the value
of the variables $y_1, \ldots, y_m$ from the files $\mathit{filey}_1$, \ldots, $\mathit{filey}_m$ respectively.
The variables $y_1, \ldots, y_m$ must be free in $\mu$. (They are defined before the
beginning of $\mu$.)

\item In the channel frontend, $\texttt{out(}c\texttt{,
  }t\texttt{)}\texttt{\}}\texttt{; }Q$, or in the oracle frontend
  $\texttt{return(}t_1,\ldots,t_n\texttt{)}\texttt{\}}\texttt{; }Q$:
The module being defined will not contain $Q$.
\end{itemize}
We transform the oracles present in the module into functions taking the
arguments given to the oracle, and returning a tuple containing 
the result of the oracle and closures corresponding
to the oracles following the current oracle that are in the same module. 
A module implementation
contains only one function: the function $\texttt{init}$, which returns
closures corresponding to the oracles accessible at the beginning of the module.



\subsection{Implementation options}
\label{sec:implopt}

The implementation options declares how the implementation should translate
functions, tables and types, and one must declare them after the
declaration of the element it modifies and before use.  
The syntax is described in 
Figure~\ref{fig:syntaximpl}.

\newcommand{\neseqsemi}[1]{\textrm{seq;}^+\nonterm{#1}}
\begin{figure}
\def\phio{\phantom{\nonterm{impl\_opt} = }\mid}
\begin{align*}
&\neseqsemi{N} ::= N \mid N \texttt{;} \neseqsemi{N}\\
&\nonterm{impl\_block} ::= \texttt{implementation
}\nonterm{impl\_opt}(\texttt{;}\nonterm{impl\_opt})^*\texttt{.}\\
&\nonterm{type\_opt} ::= \nonterm{ident}\texttt{=}\neseq{string}\\
&\nonterm{fun\_opt} ::= \nonterm{ident}\texttt{=}\nonterm{string}\\
&\nonterm{impl\_opt} ::= \texttt{type }\nonterm{ident}\texttt{=}\nonterm{string}
\ [\texttt{[}\neseqsemi{type\_opt}\texttt{]}]\\
&\phio\texttt{type }\nonterm{ident}\texttt{=}
\nonterm{integer}\ [\texttt{[}\neseqsemi{type\_opt}\texttt{]}]\\
&\phio\texttt{table }\nonterm{ident}\texttt{=}\nonterm{string}\\
&\phio\texttt{fun }\nonterm{ident}\texttt{=}\nonterm{string}\ 
[\texttt{[}\neseqsemi{fun\_opt}\texttt{]}]\\
&\phio\texttt{const }\nonterm{ident}\texttt{=}\nonterm{string}
\end{align*}
\caption{Grammar for implementation options}
\label{fig:syntaximpl}
\end{figure}

The available implementation options are described hereafter:
\begin{itemize}
\item $\texttt{type }T\texttt{="ty"}$: Sets the OCaml type $\texttt{ty}$ to
  be the type corresponding to the type $T$. 
%  The type $\texttt{ty}$ must be
%  non recursive, because we may use operators like $\texttt{(=)}$ on
%  elements of this type.

  This also can be followed by options between brackets and separated by
  semicolons. These options are:
  \begin{itemize}
  \item $\texttt{serial="s","d"}$: 
    Sets the serialization/deserialization of the type. There is no
    default, and this is required when a variable of type $T$ is written or
    read to a file/table, or when it is contained in a tuple.
    The serialization function \texttt{s} must be of type $\texttt{ty} \rightarrow {\tt string}$,
    the deserialization function \texttt{d} must be of type ${\tt string} \rightarrow \texttt{ty}$.
    When deserialization fails, it must raise exception ${\tt Match\_fail}$.

  \item $\texttt{pred="p"}$:
    Sets the predicate function, this function must be an OCaml function of
    type $\texttt{ty} \rightarrow \texttt{bool}$. It returns whether an
    element is of type $T$ or not. The default predicate function is a
    function that accepts every element.

  \item $\texttt{random="f"}$:
    Sets the random generation function. This function must be an OCaml
    function of type $\texttt{unit} \rightarrow \texttt{ty}$, and must
    return uniformly a random element of type $\texttt{ty}$. In particular,
    if a predicate function has been defined, the predicate function must
    return $\texttt{true}$ on every element returned by the random
    generation function.
  \end{itemize}
\item $\texttt{type }T\texttt{=}n$: Sets the size of the $\texttt{fixed}$
  type $T$. The size must be a multiple of 8 and then will be represented
  by a string or 1 and then by a boolean.
  This can be followed by options between brackets and separated
  by semicolons. The only allowed option is:
  \begin{itemize}
  \item $\texttt{serial="s","d"}$:
    Modifies the default serialization/deserialization of the type (used
    when a variable of this type is read/written to a file/table).
  \end{itemize}

\item $\texttt{table }tbl\texttt{="file"}$: Sets the file in which the table
  $tbl$ is written.
\item $\texttt{fun }f\texttt{="s"}$: 
  Sets the implementation of the function $f$ to the OCaml function
  $\texttt{s}$.  If the function $f$ takes arguments of type $T_1\times
  \ldots \times T_n$ and returns a result of type $T$, the type of
  $\texttt{s}$ must be $st_1\rightarrow st_2\rightarrow\ldots\rightarrow
  st_n\rightarrow st$, where for all $i$ between $1$ and $n$, $st_i$ must
  be the corresponding type declared using the $\texttt{type}$ declaration
  for the type $T_i$, and $st$ is the corresponding type for $T$. For
  functions $f$ with no arguments, the type of the function $\texttt{s}$
  must be $\texttt{unit}\rightarrow st$, with $st$ the type corresponding
  to $T$.  This can take the following options:
  \begin{itemize}
  \item $\texttt{inverse="s\_inv"}$:
    If $f$ has the $\texttt{compos}$ attribute, this declares
    $\texttt{s\_inv}$ as the inverse function.
    With the previous notations, this function must be of type
    $st \rightarrow st_1\times st_2\times\ldots\times st_n$.
    $\texttt{s\_inv\ }x$ must return a tuple $(x_1, \ldots, x_n)$
    such that $\texttt{s}\ x_1\ \ldots\ x_n = x$. If there is no such element,
    \texttt{s\_inv} must raise \texttt{Match\_fail}.
  \end{itemize}
  CryptoVerif allows one to define macros by \texttt{letfun}. Specifying
  an OCaml implementation for these macros is optional. When the OCaml
  implementation is not specified, CryptoVerif generates code according to 
  the \texttt{letfun} macro. When the OCaml
  implementation is specified, it is used when generating the OCaml code,
  while the CryptoVerif macro defined by \texttt{letfun} is used for
  proving the protocol. This feature can be used, for instance, to define
  probabilistic functions: the OCaml implementation generates the
  random choices inside the function, while the CryptoVerif definition
  by \texttt{letfun} first makes the random choices, then calls a
  deterministic function.

\item $\texttt{const }f\texttt{="s"}$: Sets the implementation of the
  function $f$ that has no arguments to an OCaml constant. If the constant
  is a string, one can write, for example, $\texttt{const }f\texttt{="\char`\\"constant\char`\\""}$.
\end{itemize}
