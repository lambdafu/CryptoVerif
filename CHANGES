This file summarizes the most important changes between versions
of the cryptographic protocol verifier.

Version

- Allow proving [unique] after some game transformations.
- As a consequence, removed setting allowUnprovedUnique.
- Fixed bugs related to the fact that terms may abort.
- Fixed bug: events were not preserved in the initial transformation of
  the RHS in equivalence proofs.

Version 2.06

- Allow saving and showing executed interactive commands
  (command-line option -ocommands, interactive commands show_commands
  and out_commands)
- Extended the "guess" transformation to be able to guess any variable,
  not only replication indices, and to guess the whole sequence of
  replication indices up to a replication. Also extended the "guess"
  transformation to deal with injective correspondences, by proving
  injectivity and leaving a non-injective query to prove.		 
- New setting "set maxGuess = <size>." to limit the size of guessable
  values.
- New command "guess_branch" to guess which branch of a test (if, find, let)
  is taken at a certain program point.
- New probability formula #(O foreach a) (number of calls to oracle O
  for value of a, where a can be random variable or a sequence of replication
  indices).
- Allow common events introduced by insert_event or insert in both sequences
  of games of an indistinguishability proof.
- Improved modelling of Diffie-Hellman in the standard library of primitives:
   - DH_proba_collision and square_DH_proba_collision no longer include
     DH_basic
   - the last 2 arguments of DH_single_coord_ladder, DH_X25519, DH_X448
     are functions is_zero_G, is_zero_subG instead of constants zero, sub_zero
     (that allows prime order groups to satisfy these properties, with
     is_zero_G(X) always false)
   - new macros DH_subgroup, DH_exclude_weak_keys, DH_basic_with_is_neutral,
     DH_subgroup_with_is_neutral, is_neutral_DH_proba_collision
   - fixed (square_)PRF_ODH2 so that they can be applied to both
     full Curve25519/448 and subsets generated by g.
- Allow assignments ("let x = M in", "x <- M;") in queries, equation and
  collision statements.
- Allow nested comments in the input file. All comments must be closed.
  CryptoVerif will raise an error otherwise.
- Fixed bug in merging of branches: branches of find cannot be merged when
  one of them may abort.
- Fixed probability for OW_trapdoor_perm_RSR.
- Fixed internal error due to a forgotten game before focus command.
- Fixed internal error LetEqual terms should have a variable in the left-hand side
- Fixed internal error in success simplify
- Fixed bugs in crypto transformation (in particular, check that variables are
  defined when needed).

Version 2.05

- Allow comparisons between indices and tables (insert, get)
in the right-hand side of equiv declarations.
- Optimize the right-hand side of equiv declarations by removing
useless assignments.
- Allow new and event_abort in conditions of find and get.
- Allow get[unique] (which is transformed into find[unique]).
- CryptoVerif proves that the get[unique] and find[unique] in the initial
game are really unique.
- Added definitions of Diffie-Hellman properties with a single
family of exponents, in the standard library of cryptographic primitives.
- Allow "min(<probability>, ..., <probability>)", "<probability>^<integer>", 
and "optim-if <condition> then <probability> else <probability>"
in probability formulas.
- Improved the computation of the runtime of the context when
adding a replication on top of an "equiv" declaration (using "optim-if").
- In a "proba" declaration, allow the user to specify the dimensions of
the arguments of the probability function.
- CryptoVerif now checks that calls to the same probability function
have the same number of arguments and compatible dimensions.
- Added the "letproba" declaration to define probability functions.
- Nicer probability formulas: write A - B instead of A + -B;
group some time formulas.
- Added a macro for DDH with random self reducibility in the standard
library of cryptographic primitives (it is more limited than other DDH
macros).
- Allow multiple command-line options "-lib <file>".
- Improvement of some error messages (suggestion of Benjamin Lipp).
- Avoid creating duplicate defined conditions in transformation
remove_assign.
- Minor improvement of the precision of the treatment of else
conditions of find.
- Improved test infrastructure: allow setting a timeout on tests.
- Removed option optimizeVars.
- Reimplemented the counting of calls to oracles in the crypto transformation,
to make it more precise and fix two bugs.
- Revised the command "allowed_collisions": the form
"allowed_collisions <formulas>" applies to both collisions between
terms and collision statements without using the "collision" keyword;
the list of formulas may be empty; formulas may be 1/pest when there is
no factor.
- Fixed bug in query_equiv: undone the optimization of the translation
that avoids creating oracles that just generate random values before
a single oracle; this optimization was not sound in general.
- Fixed several bugs in generation of OCaml implementations:
  * a non-existing file is now considered as an empty table (reported
  by Benjamin Lipp).
  * serialization and deserialization functions were swapped for
  types bool and bitstringbot (fixed by Benjamin Lipp).
  * the order of evaluation of terms was sometimes incorrect for terms
  that contain insert/get/event_abort
  * let pat = M in yield else p executed p even when the pattern-matching
  succeeded
  * fixed syntax error in the translation of get terms
  * inside events, do not ignore event_abort as well as insert even when it
  appears via a call to a letfun
- Fixed bug in computation of indices in crypto transformation.
- Fixed bug in update of defined conditions following other
rewritings of the game: it supported only expanded games, but
was sometimes called on non-expanded games.
- Fixed bug with negation in extraction of information from terms containing
if/let/find/new/event_abort.
- Fixed internal error: else case of a let term was missing in transformation
of insert/get into find.
- Fixed probabilities in GDH, square GDH and PRF-ODH.
- Fixed bug in probabilities: when a collision statement was applied
together with a crypto transformation, there was confusion between
the time of the adversary against the collision statement and the one
against the crypto transformation.

Version 2.04

- Allow using #O for the total number of calls to oracle O
(for the oracles front-end), resp. #c for the for total number
of inputs on channel c (for the channels front-end)
in probability formulas computed by CryptoVerif.
- Use "orfind" instead of "else find" in the standard library of
cryptographic primitives, when appropriate.
- query_equiv: optimize the translation to avoid creating oracles
that just generate random values before a single oracle.
- query_equiv: correctly deal with events in the right-hand side
of the equivalence to prove, in coherence with the semantics
of equiv assumptions in CryptoVerif.
- query_equiv: fixed a bug in the oracle front-end, return
instructions should return a unary tuple.
- insert: allow referring to replication indices.
- improved verification of the structure of oracle calls.
- implementation: generate separate OCaml functions for letfun
declarations.
- implementation: optimized treatment of get.
- implementation: make sure the init function of each module
is called at most once.
- implementation: fixed a missing space after begin.
- Do not warn when it is legitimate the reuse the same replication
  bound (that is, before the same oracle).
- Display occurrences of changes even when old games are forgotten.
- Fixed probabilities for IND-CCA2 public-key encryption,
  GDH and square GDH without random-self reducibility.
- Fixed [useful_change] annotations in the definitions of MACs.
- Do not ask for variable/term mapping for ordinary equivalences
in show_equiv and out_equiv.
- Fixed bug in probability computation that could lead to a useless
repetition of replication bounds in products.
- Fixed a counting bug, which could lead to counting several times
the same oracle call occurring at several places in a game, in the
presence of equational theories.
- Fixed bug in dependency analysis (case let).
- Fixed a game transformation bug: in the presence of a find inside a condition
of find, CryptoVerif thought that the inner find required the definition of
the index variables of the outer find, which caused a bug in case the outer
had several index variables.
- Fixed a typing bug in expansion of games.
- Fixed a bug that could cause an internal error in command show_facts
when the considered program point is unreachable.

Version 2.03p11

- Fixed a bug that could cause an internal error.

Version 2.03

- When a proof of equivalence fails, CryptoVerif explains where the
  two games differ.
- When a program point is designated by "before ...", "before_nth ...",
  "after ...", "after_nth ...", the regular expression is now matched
  on a process in which only process occurrences are displayed (not
  term occurrences), so that the regular expression does not contain
  occurrence numbers. (This change may require that you revise some
  of these regular expressions.)
- Display times separately to lighten the display of probability
  formulas.
- Allow x1, ..., xn:T instead of x1:T, ..., xn:T to lighten type declarations
  of variables when they have the same type.
- Added the command "use_variable x1 ... xn".
- Added the command "guess i" to guess the tested session.
- Added the command "assume replace" (variant of "replace" that does
  not check that the replacement is correct, to experiment).
- Extended the "insert" command to insert several tests, assignments
  as well as event_abort in a single command. Inserting
     find ... then/else let x = ...
  allows to test in the defined condition of find whether x is defined,
  and thus which branch of the inserted find was taken.
- Improved probabilities for Diffie-Hellman assumptions that use
  random self reducibility. Introduced a probability of distinguishing
  a rerandomized key from an honestly generated key, so that the
  transformations can also be applied to Curve25519 and Curve448.
- The game equivalences used in crypto transformations for
  ROM, PRF, PRP, SPRP, and ICM are now generated on-demand by CryptoVerif.
  That allows more flexibility to optimize these equivalences.
  (See the documentation for equiv...special and the cryptographic
  library macros ROM_hash*, PRF*, PRP_cipher, SPRP_cipher, ICM_cipher
  in the manual.)
- Added command-line option -oequiv <filename> which appends
  the generated special equivalences to <filename>.
- Added interactive commands show_equiv <crypto_args> to display
  the game equivalence corresponding to <crypto_args>, and
  out_equiv <filename> <crypto_args> to output it to <filename>.
- Added equation
  equation forall x,y,z:bool; ((x || y) && z) = ((x && z) || (y && z)).
  to improve the precision of the treatment of disjunctions.
- Improvements in case distinctions used in the treatment of elsefind
  facts.
- Fixed bug in computation of probabilities for collision statements.
- Fixed bug in transformation of find[unique] inside a branch of
  find[unique]: required "defined" conditions were sometimes missing.
- Fixed several bugs that could cause internal errors.

Version 2.02

- Revised the conditions for eliminating collisions:
    - incompatible change: set minAutoCollElim = size<n> becomes
      set minAutoCollElim = pest<n>
    - incompatible change: in formulas for "allowed_collisions",
      size<n> becomes pest<n>
    - incompatible change: the default size of parameters (declaration
      "param") is now equivalent to "passive" instead of "small".
      If the number of sessions is limited to a very small number,
      you now need to declare that explicitly with "param N [small]."
    - incompatible change: for nonuniform types, the "size<n>" option
      no longer bounds the probability of collision. You need to use the
      "pcoll<n>" option for that.
    - new command "allowed_collisions <proba. estimate>" in proof environment
    - new options for "param": default, small
    - new options for "type": size<min>_<max>, pcoll<n>
    - an estimate of the value of the probability can now be given
      for probabilities declared by the "proba" declaration.
- Renamed the setting mergeBranches into autoMergeBranches
  and the setting mergeArrays into autoMergeArrays.
- Added several variants of the PRF-ODH assumption to the library
  of cryptographic primitives.
- Added several assumptions on hash functions to the library
  of cryptographic primitives: pre-image resistance, second-preimage
  resistance.
- Added several assumptions for symmetric encryption to the library
  of cryptographic primitives: IND-CPA as well as IND-CPA and
  INT-CTXT encryption with a nonce, schemes that satisfy IND$-CPA
  instead of IND-CPA.
- Improved the models for curves 25519 and 448 in the ProVerif
  library of cryptographic primitives, to be closer to what
  CryptoVerif does.
- Added a way to prove the security properties using exactly
  the same syntax as for specifying assumptions on primitives:
  to prove "equiv LHS <=(P)=> RHS", replace the final process
  with "query_equiv LHS <=(?)=> RHS".
- Added command "success simplify".
- Added setting elsefindFactsInSuccessSimplify.
- Added commands "tag t" and "undo t".
- Extended the command "move array" to allow the user to specify expressions
  for which it is not necessary to generate the random value,
  so that the generation of the moved random value can be delayed further.
- Expansion of if, let, find, new, event, event_abort terms into
  processes is now considered as a separate transformation instead
  of being integrated into the "crypto" transformation.
  Added the command "expand" and the setting "set autoExpand = ...".
- Allow inserting find[unique]. CryptoVerif tries to prove that it
  is really unique; the insertion fails if that proof fails.
- Public variables can be omitted in the "focus" command when
  there is no ambiguity.
- Replications (i.e. "! N" or "foreach i <= N do") can be omitted
  at the root of equiv declarations that contain a single group
  of oracles. CryptoVerif adds them internally.
- Revised dependency analyses to eliminate more collisions.
  Fixed some bugs in passing.
- Removed a collision from DH_proba_collision and square_DH_proba_collision
  because it may not hold in case there are weak private keys.
- The files generated by out_game, out_state, and out_facts are
  stored in the directory specified by the command-line option
  -o. (They are stored in the current directory with -o is absent.)
  The file names for these commands are limited to use the
  following characters: 0-9 A-Z a-z % + - . = @ _ ~
  and . is forbidden as first character.
- The default library of cryptographic primitives is now searched
  in the directory that contains the cryptoverif executable,
  in addition to searching it in the current directory.
- Fixed bug in the display of game numbers in the Latex output
  (thanks to Mark Wooding).
- Improved test scripts.

Version 2.01pl1

- Revised models for elliptic curve Diffie-Hellman: removed
  DH_prime_subgroup_secret_keys_multiple_k,
  DH_prime_subgroup_secret_keys_not_multiple_k,
  GDH_subgroup, and square_GDH_subgroup;
  added DH_single_coord_ladder, DH_X25519, and DH_X448.
- Fixed bug that could prevent the application of
  collision statements with independence conditions
  in some cases.
- Fixed bug that could cause an internal error.

Version 2.01

- Allow proving indistinguishability between two games by
  "equivalence G1 G2 [public_vars x1, ..., xn]"
- Completely revised the modeling of Diffie-Hellman assumptions.
  (Your protocol models that use Diffie-Hellman will need to be revised.)
- The macro for random oracles with n arguments is now named
  ROM_hash_n and is defined for n from 1 to 10. It optimizes the
  treatment of terms H(x1) = H(x2).
  (Your protocol models that use random oracles may need to be revised.)
- Defined collision-resistant hash functions and PRFs for up to 10 arguments.
- New macros PRF_large and PRF_large_n for n from 1 to 10,
  representing a PRF with a large output, that is, it optimizes the 
  definition by eliminating collisions between random output elements.
- New macros random_split_n for n up to 10, to split a random
  value into n independent random values.
- Optimized treatment of enc(..) = .. in PRP, SPRP, and ICM. 
- Added optional side conditions in equation and collision statements.
- When a variable x is defined at several places by the same
  "let x = M in" and x has array accesses, remove_assign can now
  replace x with M without performing "SArename x" first.
- Revised parsing of proof commands. Incompatibilities:
  * Variables and terms mappings should now be between brackets,
    not between quotes in "crypto" commands, e.g.
    crypto <equiv> [variables: ...; terms: ...]
  * The formulas in "allowed_collisions" should not be between quotes
  * The syntax for "coll_elim" indications in "simplify" and
    "global_dep_anal" is now:
    coll_elim(variables: x1,...,xn; types: t1, ..., tn; terms: occ1, ..., occn)
  * Instructions in "insert", terms in "replace" must be
    between quotes
  * Identifiers in proof commands can optionally be between quotes
    (useful for instance when they clash with a proof keyword)
  * Regular expressions in occurrences (see next item) must be between quotes
  * These are now the only allowed usages of quotes in proofs.
- Program points in proof instructions can now be designated
  by "before <regexp>", "before_nth <n> <regexp>", "after <regexp>",
  "after_nth <n> <regexp>", "at <n in regexp> <regexp>",
  "at_nth <n> <n in regexp> <regexp>" in addition to occurrence numbers.
- New proof indication "crypto <equivalence> **" which applies repeatedly
  the equivalence <equivalence>, simplifying only the final game
  (while "crypto <equivalence> *" simplifies after each transformation).
- Allow several variables in commands "remove_assign binder <variables>"
  and "move binder <variables>".
- Allow designating several variables by a regular expression
  in most proof commands.
- New command
    focus "query 1", ..., "query n"
  to try to prove only the mentioned queries. When they are all proved,
  CryptoVerif goes back to the state before the last focus command, to try
  to prove the other queries.
    undo focus
  also goes back to the state before the last focus command, to try
  to prove remaining queries.
- New setting useKnownEqualitiesWithFunctionsInMatching.
- Allow several occurrences of the same injective event in the same
  branch of if/let/find and under different replications. 
- When "set inferUnique = true." is present, CryptoVerif
  infers that "find" is unique, when possible.
- In a "find[unique]", when a branch succeeds, the other branches must
  fail. We modified CryptoVerif to use that information.
- Improve a bit the way CryptoVerif infers information for
  "find"s that fails; can be disabled by
  "set elsefindAdditionalDisjunct = false." See the documentation
  of that setting in the manual for more details.
- In interactive mode, Ctrl-C interrupts the current command.
  (May not work under Windows.)
- Option "set forgetOldGames = true" and command "forget_old_games"
  to save memory. (However, it prevents undo.)

Version 2.00

- Improved simplification of terms, in particular in the presence
  of boolean variables.
- Exploit the information of complex conditions of find
  (themselves containing let, if, or find).
- During the crypto transformation, do not transform a random variable
  that appears in an event and that is marked [unchanged] in the
  transformation using an oracle with priority > priorityEventUnchangedRand
  (default: 5), prefer leaving it unchanged.
- New front-end, for improved compatibility with ProVerif.
  The main syntax changes are as follows:
  - "define" becomes "def"
  - "[compos]" becomes "[data]"
  - "[decompos]" becomes "[projection]"
  - "equation structure(id1, ..., idn)." becomes
    "equation builtin structure(id1, ..., idn)."
  - "forall x1:t1, ..., xn:tn; M." becomes
    "equation forall x1:t1, ..., xn:tn; M."
  - "query secret1 x." becomes "query secret x [cv_onesession]."
  - The syntax of correspondences is now the ProVerif syntax:
    For instance, "query event e1(...) ==> e2(...)."
    becomes "query event(e1(...)) ==> event(e2(...))."
    and "query event inj:e1(...) ==> inj:e2(...)."
    becomes "query inj-event(e1(...)) ==> inj-event(e2(...))."
    If there are public variables, they must be explicitly indicated
    in the correspondences, by adding "public_vars x1,...,xn" at the
    end of the query. (In previous versions, CryptoVerif
    implicitly considered as public variables in correspondences
    the variables on which secrecy queries were present.)
  - Equivalences use the syntax of the oracles front-end,
    even in the channels front-end.
    (Oracles must always be named; oracles must conclude with
    return(M) instead of just M; oracles are separated by
    parallel compositions, not by commas.)
    The names of equivalences must be between parentheses:
    "equiv(name) ..." or "equiv(name(f)) ..."
  - Collisions use the syntax of the oracles front-end,
    even in the channels front-end:
    "collision new x1:T1; ... new xn:Tn; forall y1:T1', ..., ym:Tm'; M1 <=(p)=> M2."
    becomes
    "collision new x1:T1; ... new xn:Tn; forall y1:T1', ..., ym:Tm'; return(M1) <=(p)=> return(M2)."
  - Processes are parametric: if a process macro P, defined by
    "let P = ..." uses variables defined before the usage of P,
    then these variables must now be passed as argument to P:
    "let P(x1:T1,...,xn:Tn) = ...", used by "P(M1,...,Mn)" in the
    channels front-end and by "run P(M1,...,Mn)" in the oracles
    front-end.
  - Both front-ends allow the synonym constructs
    "! i<=N" and "forall i <= N do" for replication,
    "new x:T" and "x <-R T" for random-number generation, and
    "let x = M in N" and "x <-M; N" for assignment.
    The oracle front-end now uses "yield" instead of "end"
    (like the channels front-end).
- The library of cryptographic primitives has been revised:
  - Symmetric-key primitives no longer use a key generation
  function.
  - Probabilistic primitives choose random coins internally
  (using "letfun"), so the user does not have to choose them
  explicitly.
  - IND-CCA2 public-key encryption may leak the length of the cleartext.
  - Added equivalences that allow to transform manually only some
  occurrences of encryption for IND-CCA2 encryption,
  of decryption for INT-PTXT encryption,
  of MAC verification for MACs,
  of signature verification for signatures.
  - Added probabilistic MACs, deterministic signatures,
  and renamed the macros as a consequence.
  - Added AEAD, possibly with a nonce (e.g. AES-GCM).
  - Added square_CDH, square_DDH, square_GDH, and
  square_GDH_prime_order.
  - Added macros for combinations of primitives,
  building authenticated encryption from encrypt-then-MAC,
  from AEAD, or from AEAD_nonce, and AEAD from encrypt-then-MAC
  or from AEAD_nonce.
- An automatic converter from CryptoVerif 1.28 to CryptoVerif 2.00
  is provided. It converts the front-end changes, but not the changes
  in the cryptographic library. As a consequence, converted
  examples need to be run using a converted version of the old
  cryptographic library.

  Usage:
  ./convert [-lib <lib_filename>] [-in channels|-in oracles] [-olib <lib_output_filename>] -o <output_filename> <filename>
  This command converts the <filename> into <output_filename>.
  (This command should be run in the main CryptoVerif directory.)
  The setting "-in channels" or "-in oracles" chooses the front-end to
  use. It allows the user to override the default ("channels" when
  <filename> ends in .cv and "oracles" when <filename> ends in .ocv).
  If "-lib <lib_filename>" is present, it uses <lib_filename> as
  CryptoVerif 1.28 library of cryptographic primitives.  Otherwise, it
  uses the default CryptoVerif 1.28 library of cryptographic
  primitives.
  If "-olib <lib_output_filename>" is present, it outputs the
  converted library of primitives into <lib_output_filename>.
  The suffix ".cvl" or ".ocvl" is automatically added to all library
  filenames (depending on the front-end in use), the user should not
  include it.

  The converted examples can be run by
  ./cryptoverif -lib converter/default-converted <converted_filename>
  when they use the default CryptoVerif 1.28 library.
  (This command should be run in the main CryptoVerif directory.)
  Otherwise, use the converted library built by ./convert.
- Option -oproof <filename> to output the proof in <filename>
  instead of displaying it on the standard output.

Version 1.28

- Allow get, insert, and event in terms. (New, insert, event and event_abort
  are forbidden in conditions of find and get.)
- To prove an injective correspondence e1 ==> e2, also use the
  variables defined after e1, in the same input...output block as e1.
- Explain why the proof of correspondences fails
- Allow using replication indices in arguments of events
- Fixed several bugs (bad display of "insert" and "get"; missing occurrence
  for user-specified transformations; type of the condition of get was not
  checked; ...).

Version 1.27

- Simplify the game on-the-fly during expansion.
- Added option "set useEqualitiesInSimplifyingFacts = true."
  to improve simplification of facts using known equalities.
- Modified the parsing of interactive commands so that one can copy-paste
  commands of the "proof" part of a file.
- Improved the simplification of "let pat = t in ..." when pat
  contains nested tuples and/or several equality tests.
- Fixed bug in the simplification of "let pat = t in ..."
  when pat is a tuple: some variables of pat could erroneously
  be defined when the pattern matching failed.
- Fixed bug that could cause an internal error
  "LetEqual terms should have a variable in the left-hand side"

Version 1.26

- Use compatibility between defined variables and
between defined variables and executed program points
to improve the precision of the proof of secrecy.
- Fixed "Internal error: Invalid_argument("List.iter2")"
when the number of arguments of insert does not match the arity
of the table.
- Fixed error message with events.

Version 1.25

- Use elsefind facts to prove that indices are distinct in
the proof of secrecy.
- Fixed "Internal error: Invalid_argument("List.map2")"
in merging of branches.
- Fixed stack overflow in the computation of probabilities
in the cryptographic transformation.

Version 1.24

- Queries:
  query secret x public_vars x1, ..., xn.
  query secret1 x public_vars x1, ..., xn.
to show (one-session) secrecy of x when the variables x1, ..., xn
are public. This query is useful to show that several variables
are independent secrets, with a single input file.
- Added a specialised version of the Gap Diffie-Hellman assumption
for prime order groups and random oracles with 2, 3, and 4 arguments
in the library of cryptographic primitives.
- Use elsefind facts to prove correspondences:
1/ to prove injectivity (useful for protocols with a replay cache,
for instance)
2/ to infer more facts by making case distinctions depending on 
the order of definition of variables.
- Use facts inferred from the simultaneous definition of several
variables in the proof of correspondences.
- Improved collection of facts: when CryptoVerif collects the
facts that hold at each program point, it can also take into account
variables that cannot be defined at a certain program point, variables
that cannot be simultaneously defined, and elsefind facts. (This is a
bit costly, so it is disabled by default. You can enable it by 
"set improvedFactCollection = true".)
- Setting "set casesInCorresp = false" to disable the case distinction
in the proof of correspondence properties, in case it is too slow.
- Improved collection of facts and defined variables: take into
account more often that the variables after the current program
point in the current input-output block are defined; take into
account the current program point and the order of definition
of variables to eliminate some cases and to infer new facts
(inequalities between indices of variables).
- More precise treatment of elsefind facts: when a new variable x
is defined, the elsefind facts that test the definition of x are
not removed but updated.
- When a "find" has a single branch that always succeeds,
and the indices are not used, keep its "then" branch.
- Simplify terms "if M then M1 else M2" inside conditions of find
into (M && M1) || (not(M) && M2). 
- New commands out_game, out_state, ... to output the current game,
state, ... to a file instead of displaying them to the standard output.
- Decreased memory usage
- Fixed bug in the removal of assignments, which sometimes lead to an
incorrect update of defined conditions of find.
- Fixed bug in the update of "defined" conditions of find after
simplification, which could lead to an internal error.
- Fixed bug that could cause an internal error
"equational theory has no neutral element in Terms.get_neutral"
- Fixed infinite loop in replacement of a variable with its value
- Fixed infinite loop in testing of the equality between terms
taking into account known equalities.

Version 1.23

- By default, automatically remove assignments on variables defined 
by "let" in conditions of find.
- Definitions for IND-CCA2 symmetric encryption and INT-PTXT 
symmetric encryption added to the cryptographic library;
definition of IND-CCA2 and INT-PTXT symmetric encryption made
more flexible by allowing the two properties to be applied in 
any order.
- Fixed bug in definition of IND-CCA2, INT-PTXT symmetric encryption,
which could cause an infinite loop.

Version 1.22

- Improved global dependency analysis for find with complex
  find conditions (containing themselves find, if, or let).
- Allow variables that depend on b0 without characterizing
  b0 in global dependency analysis.
- Allow the user to specify the mapping from variables of the
  game to variables of the equivalence, and the mapping from terms
  of the game to oracles of equivalence, in the cryptographic
  transformation.
- Apply simplifications of booleans terms to all subterms, not only
  to the root.
- Fixed bug in cryptographic transformation, which could make it
  fail unexpectedly.
- Fixed bug in cryptographic transformation: when using known equalities
  to transform terms, the defined conditions of find were not
  correctly updated.

Version 1.21

- Display an explanation when a cryptographic transformation
  fails (when it needs no random variable or at least one
  random variable was provided)
- Reimplemented the test of compatibility between definitions
  of variables and between program points, to make it cleaner,
  more precise, and faster
- In expand, remove the find completely when all branches are removed
- Improved display of long mathematical formulas in latex
- Improved model of the Gap Diffie-Hellman assumption
- Fixed bug that could cause an internal error in merging of branches,
  when CryptoVerif did not manage to build a MergeArrays advised instruction.
  It now gives no advice in this case.
- Fixed missing update of defined conditions of find in
  global dependency analysis
- Fixed display bug for find with no branch at all

Version 1.20

- added modeling of the Gap Diffie-Hellman assumption
- improved proof of secrecy, in particular for forward secrecy
- improved merging of branches of if/find/let, to allow variables
  with array accesses to be renamed between the branches (with
  additional conditions so that this is sound).
  Useful in particular for proving indistinguishability of
  P1 and P2 by showing secrecy of b in the process
  "if b then P1 else P2".
  The merging of branches is no longer done within simplify;
  it is done as a separate transformation after simplify.
- improved collection of facts that hold at each program point,
  by taking into account that certain definition points of variables
  are not compatible.
- improved the proof of correspondence assertions by distinguishing
  cases depending on the definition points of variables. Removed the display
  of advice since it is replaced by these case distinctions.
- extended the command 'insert' to allow references to variables
  known to be defined but not explicitly included in the 'defined'
  conditions of 'find's above the inserted instruction. The 'defined'
  conditions of these 'find's are updated accordingly.
- improved case distinctions on the order in which variables
  are defined: now both cases can be proved using "elsefind" facts,
  in addition to proving one case via "elsefind" facts and the other
  one by elimination of collisions.
- improved elimination of collisions between terms t1 = t2
  when t1 characterizes a large random value b[l] and
  t2 contains b[l'] with l <> l'.
- improved dependency analysis in conditions of find
- improved the simplification of terms. More precisely,
  improved usage of known equalities to test equality of
  two given terms
- use known equalities to determine the values of variables
  in the cryptographic transformation (can be disabled with
  "set useKnownEqualitiesInCryptoTransform = false.")
- check that the defined variables are compatible also after
  each "if". This is useful in case the condition of the "if" 
  allows to simplify array indices of variables.
- fixed two bugs in global dependency analysis
- fixed bug that could lead to an internal error in the cryptographic 
  transformation (some terms were incorrectly forbidden in the computation 
  of the length of a term)

Version 1.19

- improved simplification by orienting equations f(...) = f'(...)
  with function symbols at the root of both sides.
- improved display of terms (parentheses omitted when useless,
  added when useful for clarity)
- fixed bug that could lead to Internal error: File
  "transf_crypto.ml", line 824, characters 8-14: Assertion failed

Version 1.18

- allow length(t) in probability formulas, where t is a bounded type.
- replace random choices with constant assignments when their value is not
  used.
- improved again the "replace" transformation, in particular to take into
  when one knows that constants are pairwise distinct.
- fixed bug in transformation "move binder x" when x is defined by
  let and has array references.
- fixed termination problem in simplification.
- fixed bug that could lead to Internal error: LetEqual terms should have a
  variable in the left-hand side
- separated the setting "set uniqueBranch = ..." into two:
  a) "set uniqueBranch = ..." determines whether, when a branch of a 
  find[unique] succeeds, we remove the other branches.
  b) "set uniqueBranchReorganize = ..." determines whether, when a find[unique]
  is in the condition / branch of another find, we reorganize the find.

Version 1.17

- support for equational theories using the declaration "equation".
This new declaration leads to two incompatible changes:
   - the declaration "fun f(T,T):T' [commut]." should now be written
     	fun f(T,T):T'. 
	equation commut(f).
   - the declaration "expand Xor(T, xor)." should now be written
   "expand Xor(T, xor, zero)." where zero designates the neutral element
   for xor, a bitstring consisting only of zeroes.
- the construct "event_abort e" replaces "event e; abort".
- improved the "replace" transformation, so that it succeeds more often.
The search depth for this transformation can be set by
"set maxReplaceDepth = ..."
- optimized the game simplification
- documented the construct find[unique] in the manual.
- warnings when one uses a replication above another replication or
a parallel composition. Changed priorities in the parser, so that
(!N P1 | !N P2) is interpreted as ((!N P1) | (!N P2)) and not as
(!N (P1 | !N P2)).
- generation of OCaml implementations: 
   - check that the oracle above the beginning of a role has
   a single return.
   - check that oracle above a role are also included in a role.
- fixed minor bugs in SSH example.
- fixed bug that allowed declaring two oracles of the same name
one after the other: O():= ... return(); O():= ...
- fixed subtle bug that could lead to an incorrect computation
of the facts that hold at a certain point in the game, due to
some terms being physically equal inside the game.
- fixed bug in which applying a collision statement may lead to
storing links in it, which interfere with a subsequent application of the
same collision statement.

Version 1.16

- improved explanation of probability computations
- cleaned up the semantics of "find", by using temporary variables for
the lookup.
- channels must be identifiers in the initial game; indices of channels
are always implicitly the current replication indices.
- allow approximately uniform distributions for finite sets (bounded types),
and non-uniform distributions for all typs (all random elements chosen by 
"new" in the same type are chosen using the same distribution, called
standard distribution for that type). 
- simplify terms while expanding games, to reduce the size of the
expanded game
- removed bad advice sometimes given by the crypto transformation
- when the instruction "success" fails to prove a correspondence,
it may display user advice "SArename b", when it thinks that this
instruction may help doing the proof.
- removed setting "set minManualCollElim"
- added a warning when identifiers are rebound in the input file.
- fixed internal error "Game not found", which sometimes occurred
when backtracking in the proof.
- fixed bug that caused an internal error when a "new" occurred in the 
condition of a "get"; this construct is now rejected with a correct error 
message. 
- fixed bug that could cause an internal error with option
"set optimizeVars = true".
- fixed bugs that could lead to a wrong transformed game or to an internal
error when there were array accesses to variables bound by "get";
such array accesses are now forbidden.
- fixed bug that could cause useless renamings of variables defined
in conditions of find and not used.
- fixed bug that could cause an internal error when referring to 
find indices in the right-hand side of an equivalence; such references are 
now rejected with a correct error message.
- fixed bug that caused an internal error in auto_sa_rename when
there were array accesses to variables defined inside terms
(but not conditions of find)

Version 1.15

- in the replace command, make case distinctions depending on the
order of definition of variables, and take into account facts coming
from conjunctions and disjunctions, to prove more facts, by David
Cadé and Bruno Blanchet.
- similar case distinctions in simplify.
- when a fact is known, replace it by "true" elsewhere, by David Cadé.
- implementation of the SSH Transport Layer Protocol, as an example
(without key re-exchange, IGNORE and DISCONNECT messages, and with
only one algorithm for each scheme), by David Cadé and Bruno Blanchet.
- fixed bug that could cause an internal error in the crypto
transformation.

Version 1.14

- after events inserted by insert_event, one aborts the game.
- fixed bug: uf_cma_corrupt transformations must be manual,
  this was omitted in default.ocvl

Version 1.13

- compilation of CryptoVerif specifications to Caml implementations,
by David Cadé
- specific constructs for key tables (insert/get), by David Cadé
- function macros (letfun), by David Cadé
- the global dependency analysis is now a separate transformation
- in the "else" branch of let, record that the pattern-matching failed
- in proofs, equivalences can now be designated by a name 
  (either just an identifier, or name(f), where f is for instance a function symbol)
  The old way of designating equivalences is kept for backward compatibility, 
  but should be avoided. Since a new equivalence has been added for
  (S)UF-CMA signatures, "crypto sign" is now ambiguous and should be replaced
  with "crypto uf_cma(sign)".
- extended the specification of MACs and signatures to allow the
  corruption of secret keys.
- when the input file name ends with ".ocv", CryptoVerif uses the oracles
  front-end by default.
- detailed explanation of the transformation performed between 2 games
- minor changes so that the cryptographic transformation works more often
- the option of find [unique] is back
- fixed bug in the computation of probabilities
- fixed bug that could prevent "simplify coll_elim <occurrences>" from
  working
- fixed bug: insert <occ> "let pat = M in" is now correctly rejected
  when pat binds several times the same variable. 
- the function option [decompos] is now ignored (it had bad effects)
- removed the tricks that allowed to count the same eliminated collisions
  only once in the whole sequence of games; they are hard to justify formally.

Version 1.12

- added flags [unchanged] and [computational], to specify when random
choices are preserved by cryptographic transformations
- instruction allowed_collisions to specify precisely the probabilities of
collisions that can be eliminated
- redone improvement of computation of probabilities when using 
Shoup's lemma
- basic emacs mode with coloring

Version 1.11

- change of license: CryptoVerif is now available under the 
CeCILL-B license (BSD-style license)
- modified definition of the random oracle model to use a keyed
hash function; you will need to update your scripts that use 
"expand ROM_hash".
- doubled probabilities for secrecy properties (CryptoVerif previously
displayed the probability of distinguishing the initial game from a
game that perfectly preserves secrecy, which is half the probability of
breaking secrecy).
- support for the Decisional Diffie-Hellman assumption; 
allow events in right-hand side of equivalences
- merging of variables; improved merging of branches of
if/let/find
- option [noninteractive] for parameters, to optimize 
computed probability bounds.
- when no query is present in the input file, try to simplify the game
as much as possible (instead of stopping immediately).
- "collision" now considers independent random choices.
- removed "otheruses" and "[unique]" (still accepted for backward compatibility 
but ignored)
- undone improvement of computation of probabilities when using 
Shoup's lemma
- improved simplification of boolean terms, by trying to reach
a contradiction
- tried to remove "let x = cst_type" when possible
- allow floating point constants in probability formulas
- specification of xor added to the library of primitives

Version 1.10pl1

- fixed TeX display bug

Version 1.10

- support for the Computational Diffie-Hellman assumption:
  - support for array indices as inputs in equivalences
  - support for if/let/find/new inside conditions of find
- possibility to designate the number of different calls to an oracle
in probability formulas, for expressing more precise bounds.
- manual insertion of events, which are proved later to have negligible
probability
- manual insertion of instructions, in particular case distinctions
- manual replacement of a term with a equal term
- manually guided elimination of collisions, in particular for passwords
- exploit that the value of the successful branch/indices of certain 
finds is unique
- extended the "otheruses" condition to be able to replace new y:T; 
x = enc(y,k) with new x: T; y = dec(x,k) for SPRP/ICM encryption
and then remove the computation of y when it is not used (and conversely)
- verification of well-formedness invariants after each game
transformation (to make it easier to detect some bugs)
- fixed bug in simplification that could cause missing "defined" conditions
- fixed bug in expansion of terms that could cause references to variables
before the corresponding "defined" condition
- fixed bug in checking of equivalences that could lead to an
internal error instead of a normal error message
- fixed bug in cryptographic transformations, in which the transformation
was applied for terms in conditions of find even when these terms should
have been evaluated at most once for each choice of random coins.
- fixed bug in the computation of probabilities for cryptographic 
transformations when the transformed expression appears in the condition 
of find, and in some cases when transformed expressions appear in different 
branches of if/let/find.
- fixed bug in the cryptographic transformation that allowed to 
transform an expression that occurred several times in the game,
when there was no replication at all in the equivalence.
- fixed bug in the cryptographic transformation: a recheck of the
arguments of oracles was missing.
- fixed bug in the verification of probability formulae; improved
probability formulae for primitives defined in default.cvl/default.ocvl.
- fixed bug that prevented the use of "set" commands in proof environments.
- fixed two bugs in removal of assignments, one that could lead to removing
the definition of a variable while keeping a "defined" condition on it,
one that could lead to incorrectly changing the meaning of "defined" conditions.
- renamed the executable program to cryptoverif

Version 1.09

- move "new x" even when x has array references, but only inside
the same output process.
- move "let x = t in" when x has no array references and the let
can be moved under a if/let/find in which x is used in a single branch.
(The term t is then computed in fewer cases.)
- minor improvements in the proof strategy (in particular, after SArename,
rename variables defined by several random choices and without array
references).
- possible to deactivate the merging of if/let/find branches by
"set mergeBranches = false."
- fixed bug in cryptographic transformation that could lead to referencing
variables that were not defined.
- fixed bug in cryptographic transformation that could lead to missing
defined conditions.
- fixed display bug that could lead to a confusion between different 
variables when the input file contains variable names of the form
XXX_nnn where nnn is a number.

Version 1.08

- merging of branches of if/let/find when they execute the same code.
- fixed a call to "List.for_all2" in which the two lists could have different
lengths and a missing renaming of "otheruses" conditions in cryptotransf.ml 
(thanks to Yoshikazu Hanatani for reporting these bugs).
- improved again treatment of "elsefind" facts.

Version 1.07pl1

Minor bug fixes and improvements:
- fixed bug in the definition of collision-resistant hash functions in
the library of cryptographic primitives.
- fixed bug in the simplification of "find" inside "else" branches 
of "let".
- fixed a call to "List.for_all2" in which the two lists could have different
lengths.
- improved treatment of "elsefind" facts.
- improved proof of Needham-Schroeder public-key when the key is
the hash of Na and Nb (see authexamples/needham-schroeder-pkcorr3BlockKeyHash).
- the type must be explicitly given when a variable is defined in a tuple
pattern (i.e., in "let (...,x:T,...) = ... in ...", the type T cannot be 
omitted).
- various display improvements.

Version 1.07

- Possibility to include proof indications in the CryptoVerif input
file itself (instead of always entering them interactively).
- Macro mechanism, used to define a library of standard cryptographic
primitives that can easily be reused when writing new protocols.
- Improvements in the proof strategy, in particular to automate the
proof of public-key protocols.
(The changes in the proof strategy may require updates in manual
proofs. It is recommended to update your scripts to take advantage
of the new features. However, if you wish to ensure maximal compatibility
with previous versions of CryptoVerif, you can add the settings:
  set simplifyAfterSARename = false.
  set noAdviceSimplify = true.
)

Version 1.06pl3

- Added priorities among the various functions of an equivalence
- Check that all pairs of variables that must be defined at a certain
program point can be simultaneously defined.
- When an advised transformation renames a variable (e.g. SArename), 
rename this variable accordingly in the transformations to do next.

Versions 1.06pl1 and 1.06pl2

- Minor bug fixes.

Version 1.06

- Allow injective events to occur several times in a process, but in
different branches of if/let/find and under replications of the same type.

Version 1.05

- Improvements in the proof of correspondence assertions

Version 1.04

- Improvements in the computation of probabilities of collisions
- Available under the CeCILL license

Version 1.03

- Improvements in simplification.
- Improvements in the computation of probabilities;
computation of the runtime of the games.
- Proof of injective correspondence assertions
- New front-end with a syntax closer to cryptographic games.
(The old front-end is still available.)

Version 1.02

- Renamed SSArename to SArename, secrecy to one-session secrecy,
and semantic security to secrecy, to be coherent with the research
papers.
- First version of the user manual.

Version 1.01

- Improved simplification, to remove else branches of find more often.
- Support for commutative function symbols
- Proof of non-injective correspondence assertions
- Extensions for one-way trapdoor permutations:
	* In the left-hand side of equivalences, allow functions that
	do not use all random variables above them.
	* Allow applying a cryptographic transformation when some
	transformed terms occur in conditions of find.
- Exact security: bound the probability of an attack.

Version 1.00

First release.
