(* PRF-ODH assumption
   We propose two variants of PRF-ODH; these are preliminary models.
   PRF-ODH1 is a consequence of CDH and ROM or of DDH and PRF. It corresponds to nnPRF-ODH in https://eprint.iacr.org/2017/517, but with several challenge queries using the same or different DH pairs and argument of the PRF.
   PRF-ODH2 is a consequence of GDH and ROM. It corresponds to mmPRF-ODH in https://eprint.iacr.org/2017/517, but again with several challenge queries using the same or different DH pairs and argument of the PRF.

   G, Z, g, exp, exp', mult are as in DH_basic.
   prf: pseudo-random function that takes as argument a group
   element (in G) and an element in prf_in, and produces a result in 
   prf_out.
   The type prf_out must be "bounded" or "nonuniform", and "large".

   pPRF_ODH(t, n): probabibility of breaking the PRF-ODH assumption
   in time t with n queries to the PRF (prf(g^ab, m)).

   The function prf is defined by this macro. It must not be declared
   elsewhere, and it can be used only after expanding the macro.
   All other arguments must be declared before this macro.
  *)

def PRF_ODH1(G, Z, prf_in, prf_out, g, exp, exp', mult, prf, pPRF_ODH) {

fun prf(G, prf_in): prf_out.

(* The PRF-ODH assumption *)

event ev_abort.

param na, na1, na2, nb, nb1, nb2. 

equiv(prf_odh(prf))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach ia2 <= na2 do Oa2(jb <= nb, xa2: prf_in) [useful_change] := return(prf(exp(g, mult(b[jb], a)), xa2))
    ) |
    foreach ib <= nb do b <-R Z; (
      OB() := return(exp(g,b)) |
      Ob() [10] := return(b) |
      foreach ib2 <= nb2 do Ob2(ja <= na, xb2: prf_in) := return(prf(exp(g, mult(a[ja], b)), xb2))
    )
<=(na * nb * pPRF_ODH(time +
     #OA*time(exp)+#Oa2*(time(exp)+time(prf, maxlength(xa2))) +
     #OB*time(exp)+#Ob2*(time(exp)+time(prf, maxlength(xb2))),
     na2 + nb2))=>
    foreach ia <= na do a <-R Z; (
      OA() := return(exp'(g,a)) |
      Oa() :=
      	 (* Abort when a must not be compromised *)
         find uaDH <= na2 suchthat defined(ka'[uaDH]) then event_abort ev_abort else
	 find ubDH <= nb2, ub <= nb suchthat defined(kb'[ubDH, ub], a'[ubDH, ub]) && a'[ubDH, ub] = a then event_abort ev_abort else
         let ka:bool = true in return(a) |
      foreach ia2 <= na2 do Oa2(jb <= nb, xa2: prf_in) :=
      	 let b': Z = b[jb] in
	 find u <= nb suchthat defined(kb[u],b[u]) && b' = b[u] then (* b' compromised *) return(prf(exp'(g, mult(b[jb], a)), xa2)) else
         if defined(ka) then (* a compromised *) return(prf(exp'(g, mult(b[jb], a)), xa2)) else
	 (* At this point, a and b' are not compromised, and must never be compromised in the future *)
	 let ka': bool = true in
         find vaDH <= na2 suchthat defined(b'[vaDH],xa2[vaDH],ca2[vaDH]) && b' = b'[vaDH] && xa2 = xa2[vaDH] then return(ca2[vaDH]) else
         find vbDH <= nb2, vb <= nb suchthat defined(b[vb], a'[vbDH, vb], xb2[vbDH, vb], cb2[vbDH, vb]) && b' = b[vb] && a = a'[vbDH, vb] && xa2 = xb2[vbDH, vb] then return(cb2[vbDH, vb]) else
         ca2 <-R prf_out; return(ca2)) |
    foreach ib <= nb do b <-R Z; (
      OB() := return(exp'(g,b)) |
      Ob() :=
      	 (* Abort when b must not be compromised *)
         find ubDH <= nb2 suchthat defined(kb'[ubDH]) then event_abort ev_abort else
	 find uaDH <= na2, ua <= na suchthat defined(ka'[uaDH, ua], b'[uaDH, ua]) && b'[uaDH, ua] = b then event_abort ev_abort else
         let kb:bool = true in return(b) |
      foreach ib2 <= nb2 do Ob2(ja <= na, xb2: prf_in) :=
      	 let a': Z = a[ja] in
	 find u <= na suchthat defined(ka[u],a[u]) && a' = a[u] then (* a' compromised *) return(prf(exp'(g, mult(a[ja], b)), xb2)) else
         if defined(kb) then (* b compromised *) return(prf(exp'(g, mult(a[ja], b)), xb2)) else
	 (* At this point, b and a' are not compromised, and must never be compromised in the future *)
	 let kb': bool = true in
         find vbDH <= nb2 suchthat defined(a'[vbDH],xb2[vbDH],cb2[vbDH]) && a' = a'[vbDH] && xb2 = xb2[vbDH] then return(cb2[vbDH]) else
         find vaDH <= na2, va <= na suchthat defined(a[va], b'[vaDH, va], xa2[vaDH, va], ca2[vaDH, va]) && a' = a[va] && b = b'[vaDH, va] && xb2 = xa2[vaDH, va] then return(ca2[vaDH, va]) else
         cb2 <-R prf_out; return(cb2)).
	 
}


(* PRF-ODH2 is a consequence of GDH and ROM. It corresponds to mmPRF-ODH in https://eprint.iacr.org/2017/517, but again with several challenge queries using the same or different DH pairs and argument of the PRF.

   G, Z, g, exp, exp', mult are as in DH_basic.
   prf: pseudo-random function that takes as argument a group
   element (in G) and an element in prf_in, and produces a result in 
   prf_out.
   The type prf_out must be "bounded" or "nonuniform", and "large".

   pPRF_ODH(t, n, n'): probabibility of breaking the PRF-ODH assumption
   in time t with n queries to the PRF (prf(g^ab, m)) 
   and n' queries to prf(X^a, m) or prf(X^b, m).

   The function prf is defined by this macro. It must not be declared
   elsewhere, and it can be used only after expanding the macro.
   All other arguments must be declared before this macro.

   WARNING! PRF_ODH2 cannot be used with 
   DH_prime_subgroup_secret_keys_multiple_k
   (incorrect comparison ma1 = exp'(g, b[j']) ) *)

def PRF_ODH2(G, Z, prf_in, prf_out, g, exp, exp', mult, prf, pPRF_ODH) {

fun prf(G, prf_in): prf_out.

(* The PRF-ODH assumption *)

event ev_abort.

param na, na1, na2, nb, nb1, nb2. 

equiv(prf_odh(prf))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach ia1 <= na1 do Oa1(ma1:G, xa1:prf_in) := return(prf(exp(ma1, a), xa1)) |
      foreach ia2 <= na2 do Oa2(jb <= nb, xa2: prf_in) [useful_change] := return(prf(exp(g, mult(b[jb], a)), xa2))
    ) |
    foreach ib <= nb do b <-R Z; (
      OB() := return(exp(g,b)) |
      Ob() [10] := return(b) |
      foreach ib1 <= nb1 do Ob1(mb1:G, xb1:prf_in) := return(prf(exp(mb1, b), xb1)) |
      foreach ib2 <= nb2 do Ob2(ja <= na, xb2: prf_in) := return(prf(exp(g, mult(a[ja], b)), xb2))
    )
<=(na * nb * pPRF_ODH(time +
     #OA*time(exp)+#Oa1*(time(exp)+time(prf, maxlength(xa1)))+#Oa2*(time(exp)+time(prf, maxlength(xa2))) +
     #OB*time(exp)+#Ob1*(time(exp)+time(prf, maxlength(xb1)))+#Ob2*(time(exp)+time(prf, maxlength(xb2))),
     na1 + nb1 + na2 + nb2,
     na1 + nb1))=>
    foreach ia <= na do a <-R Z; (
      OA() := return(exp'(g,a)) |
      Oa() :=
      	 (* Abort when a must not be compromised *)
         find uaDH <= na2 suchthat defined(ka'[uaDH]) then event_abort ev_abort else
         find uaDH <= na1 suchthat defined(ka''[uaDH]) then event_abort ev_abort else
	 find ubDH <= nb2, ub <= nb suchthat defined(kb'[ubDH, ub], a'[ubDH, ub]) && a'[ubDH, ub] = a then event_abort ev_abort else
	 find ubDH <= nb1, ub <= nb suchthat defined(kb''[ubDH, ub], a''[ubDH, ub]) && a''[ubDH, ub] = a then event_abort ev_abort else
         let ka:bool = true in return(a) |
      foreach ia1 <= na1 do Oa1(ma1:G, xa1:prf_in) :=
      	 find j' <= nb suchthat defined(b[j']) && ma1 = exp'(g, b[j']) then
	 (
	    (* In this case, that's the same as Oa2 *)
	    let b'': Z = b[j'] in
	    find u <= nb suchthat defined(kb[u],b[u]) && b'' = b[u] then (* b'' compromised *) return(prf(exp'(ma1, a), xa1)) else
            if defined(ka) then (* a compromised *) return(prf(exp'(ma1, a), xa1)) else
	    (* At this point, a and b'' are not compromised, and must never be compromised in the future *)
	    let ka'': bool = true in
            find vaDH <= na1 suchthat defined(b''[vaDH],xa1[vaDH],ca1[vaDH]) && b'' = b''[vaDH] && xa1 = xa1[vaDH] then return(ca1[vaDH]) else
            find vaDH <= na2 suchthat defined(b'[vaDH],xa2[vaDH],ca2[vaDH]) && b'' = b'[vaDH] && xa1 = xa2[vaDH] then return(ca2[vaDH]) else
            find vbDH <= nb1, vb <= nb suchthat defined(b[vb], a''[vbDH, vb], xb1[vbDH, vb], cb1[vbDH, vb]) && b'' = b[vb] && a = a''[vbDH, vb] && xa1 = xb1[vbDH, vb] then return(cb1[vbDH, vb]) else
            find vbDH <= nb2, vb <= nb suchthat defined(b[vb], a'[vbDH, vb], xb2[vbDH, vb], cb2[vbDH, vb]) && b'' = b[vb] && a = a'[vbDH, vb] && xa1 = xb2[vbDH, vb] then return(cb2[vbDH, vb]) else
	    ca1 <-R prf_out; return(ca1)
	 )
	 else
	    return(prf(exp'(ma1, a), xa1)) |
      foreach ia2 <= na2 do Oa2(jb <= nb, xa2: prf_in) :=
      	 let b': Z = b[jb] in
	 find u <= nb suchthat defined(kb[u],b[u]) && b' = b[u] then (* b' compromised *) return(prf(exp'(g, mult(b[jb], a)), xa2)) else
         if defined(ka) then (* a compromised *) return(prf(exp'(g, mult(b[jb], a)), xa2)) else
	 (* At this point, a and b' are not compromised, and must never be compromised in the future *)
	 let ka': bool = true in
         find vaDH <= na1 suchthat defined(b''[vaDH],xa1[vaDH],ca1[vaDH]) && b' = b''[vaDH] && xa2 = xa1[vaDH] then return(ca1[vaDH]) else
         find vaDH <= na2 suchthat defined(b'[vaDH],xa2[vaDH],ca2[vaDH]) && b' = b'[vaDH] && xa2 = xa2[vaDH] then return(ca2[vaDH]) else
         find vbDH <= nb1, vb <= nb suchthat defined(b[vb], a''[vbDH, vb], xb1[vbDH, vb], cb1[vbDH, vb]) && b' = b[vb] && a = a''[vbDH, vb] && xa2 = xb1[vbDH, vb] then return(cb1[vbDH, vb]) else
         find vbDH <= nb2, vb <= nb suchthat defined(b[vb], a'[vbDH, vb], xb2[vbDH, vb], cb2[vbDH, vb]) && b' = b[vb] && a = a'[vbDH, vb] && xa2 = xb2[vbDH, vb] then return(cb2[vbDH, vb]) else
         ca2 <-R prf_out; return(ca2)) |
    foreach ib <= nb do b <-R Z; (
      OB() := return(exp'(g,b)) |
      Ob() :=
      	 (* Abort when b must not be compromised *)
         find ubDH <= nb2 suchthat defined(kb'[ubDH]) then event_abort ev_abort else
         find ubDH <= nb1 suchthat defined(kb''[ubDH]) then event_abort ev_abort else
	 find uaDH <= na2, ua <= na suchthat defined(ka'[uaDH, ua], b'[uaDH, ua]) && b'[uaDH, ua] = b then event_abort ev_abort else
	 find uaDH <= na1, ua <= na suchthat defined(ka''[uaDH, ua], b''[uaDH, ua]) && b''[uaDH, ua] = b then event_abort ev_abort else
         let kb:bool = true in return(b) |
      foreach ib1 <= nb1 do Ob1(mb1:G, xb1:prf_in) :=
      	 find j' <= na suchthat defined(a[j']) && mb1 = exp'(g, a[j']) then
	 (
	    (* In this case, that's the same as Oa2 *)
	    let a'': Z = a[j'] in
	    find u <= na suchthat defined(ka[u],a[u]) && a'' = a[u] then (* a'' compromised *) return(prf(exp'(mb1, b), xb1)) else
            if defined(kb) then (* b compromised *) return(prf(exp'(mb1, b), xb1)) else
	    (* At this point, b and a'' are not compromised, and must never be compromised in the future *)
	    let kb'': bool = true in
            find vbDH <= nb1 suchthat defined(a''[vbDH],xb1[vbDH],cb1[vbDH]) && a'' = a''[vbDH] && xb1 = xb1[vbDH] then return(cb1[vbDH]) else
            find vbDH <= nb2 suchthat defined(a'[vbDH],xb2[vbDH],cb2[vbDH]) && a'' = a'[vbDH] && xb1 = xb2[vbDH] then return(cb2[vbDH]) else
            find vaDH <= na1, va <= na suchthat defined(a[va], b''[vaDH, va], xa1[vaDH, va], ca1[vaDH, va]) && a'' = a[va] && b = b''[vaDH, va] && xb1 = xa1[vaDH, va] then return(ca1[vaDH, va]) else
            find vaDH <= na2, va <= na suchthat defined(a[va], b'[vaDH, va], xa2[vaDH, va], ca2[vaDH, va]) && a'' = a[va] && b = b'[vaDH, va] && xb1 = xa2[vaDH, va] then return(ca2[vaDH, va]) else
	    cb1 <-R prf_out; return(cb1)
	 )
	 else
	    return(prf(exp'(mb1, b), xb1)) |
      foreach ib2 <= nb2 do Ob2(ja <= na, xb2: prf_in) :=
      	 let a': Z = a[ja] in
	 find u <= na suchthat defined(ka[u],a[u]) && a' = a[u] then (* a' compromised *) return(prf(exp'(g, mult(a[ja], b)), xb2)) else
         if defined(kb) then (* b compromised *) return(prf(exp'(g, mult(a[ja], b)), xb2)) else
	 (* At this point, b and a' are not compromised, and must never be compromised in the future *)
	 let kb': bool = true in
         find vbDH <= nb1 suchthat defined(a''[vbDH],xb1[vbDH],cb1[vbDH]) && a' = a''[vbDH] && xb2 = xb1[vbDH] then return(cb1[vbDH]) else
         find vbDH <= nb2 suchthat defined(a'[vbDH],xb2[vbDH],cb2[vbDH]) && a' = a'[vbDH] && xb2 = xb2[vbDH] then return(cb2[vbDH]) else
         find vaDH <= na1, va <= na suchthat defined(a[va], b''[vaDH, va], xa1[vaDH, va], ca1[vaDH, va]) && a' = a[va] && b = b''[vaDH, va] && xb2 = xa1[vaDH, va] then return(ca1[vaDH, va]) else
         find vaDH <= na2, va <= na suchthat defined(a[va], b'[vaDH, va], xa2[vaDH, va], ca2[vaDH, va]) && a' = a[va] && b = b'[vaDH, va] && xb2 = xa2[vaDH, va] then return(ca2[vaDH, va]) else
         cb2 <-R prf_out; return(cb2)).
	 
}


(* square PRF-ODH1 and PRF-ODH2
   These are "square" variants of PRF_ODH1 and PRF_ODH2 respectively. *)

def square_PRF_ODH1(G, Z, prf_in, prf_out, g, exp, exp', mult, prf, pPRF_ODH) {

fun prf(G, prf_in): prf_out.

(* The (square) PRF-ODH assumption *)

event ev_abort.

param na, na1, na2.

equiv(prf_odh(prf))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) [useful_change] := return(prf(exp(g, mult(a[ja], a)), xa2))
    )
<=(0(*TO DO*))=>
    foreach ia <= na do a <-R Z; (
      OA() := return(exp'(g,a)) |
      Oa() :=
      	 (* Abort when a must not be compromised *)
         find uaDH <= na2 suchthat defined(ka'[uaDH]) then event_abort ev_abort else
	 find uaDH <= na2, ua <= na suchthat defined(ka'[uaDH, ua], a'[uaDH, ua]) && a'[uaDH, ua] = a then event_abort ev_abort else
         let ka:bool = true in return(a) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) :=
      	 let a': Z = a[ja] in
	 find u <= na suchthat defined(ka[u],a[u]) && a' = a[u] then (* a' compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
         if defined(ka) then (* a compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
	 (* At this point, a and a' are not compromised, and must never be compromised in the future *)
	 let ka': bool = true in
         find vaDH <= na2 suchthat defined(a'[vaDH],xa2[vaDH],ca2[vaDH]) && a' = a'[vaDH] && xa2 = xa2[vaDH] then return(ca2[vaDH]) else
         find vaDH <= na2, va <= na suchthat defined(a[va], a'[vaDH, va], xa2[vaDH, va], ca2[vaDH, va]) && a' = a[va] && a = a'[vaDH, va] && xa2 = xa2[vaDH, va] then return(ca2[vaDH, va]) else
         ca2 <-R prf_out; return(ca2)).
	 
}


def square_PRF_ODH2(G, Z, prf_in, prf_out, g, exp, exp', mult, prf, pPRF_ODH) {

fun prf(G, prf_in): prf_out.

(* The (square) PRF-ODH assumption *)

event ev_abort.

param na, na1, na2.

equiv(prf_odh(prf))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach ia1 <= na1 do Oa1(ma1:G, xa1:prf_in) := return(prf(exp(ma1, a), xa1)) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) [useful_change] := return(prf(exp(g, mult(a[ja], a)), xa2))
    )
<=(0(*TO DO*))=>
    foreach ia <= na do a <-R Z; (
      OA() := return(exp'(g,a)) |
      Oa() :=
      	 (* Abort when a must not be compromised *)
         find uaDH <= na2 suchthat defined(ka'[uaDH]) then event_abort ev_abort else
         find uaDH <= na1 suchthat defined(ka''[uaDH]) then event_abort ev_abort else
	 find uaDH <= na2, ua <= na suchthat defined(ka'[uaDH, ua], a'[uaDH, ua]) && a'[uaDH, ua] = a then event_abort ev_abort else
	 find uaDH <= na1, ua <= na suchthat defined(ka''[uaDH, ua], a''[uaDH, ua]) && a''[uaDH, ua] = a then event_abort ev_abort else
         let ka:bool = true in return(a) |
      foreach ia1 <= na1 do Oa1(ma1:G, xa1:prf_in) :=
      	 find j' <= na suchthat defined(a[j']) && ma1 = exp'(g, a[j']) then
	 (
	    (* In this case, that's the same as Oa2 *)
	    let a'': Z = a[j'] in
	    find u <= na suchthat defined(ka[u],a[u]) && a'' = a[u] then (* a'' compromised *) return(prf(exp'(ma1, a), xa1)) else
            if defined(ka) then (* a compromised *) return(prf(exp'(ma1, a), xa1)) else
	    (* At this point, a and a'' are not compromised, and must never be compromised in the future *)
	    let ka'': bool = true in
            find vaDH <= na1 suchthat defined(a''[vaDH],xa1[vaDH],ca1[vaDH]) && a'' = a''[vaDH] && xa1 = xa1[vaDH] then return(ca1[vaDH]) else
            find vaDH <= na2 suchthat defined(a'[vaDH],xa2[vaDH],ca2[vaDH]) && a'' = a'[vaDH] && xa1 = xa2[vaDH] then return(ca2[vaDH]) else
            find vaDH <= na1, va <= na suchthat defined(a[va], a''[vaDH, va], xa1[vaDH, va], ca1[vaDH, va]) && a'' = a[va] && a = a''[vaDH, va] && xa1 = xa1[vaDH, va] then return(ca1[vaDH, va]) else
            find vaDH <= na2, va <= na suchthat defined(a[va], a'[vaDH, va], xa2[vaDH, va], ca2[vaDH, va]) && a'' = a[va] && a = a'[vaDH, va] && xa1 = xa2[vaDH, va] then return(ca2[vaDH, va]) else
	    ca1 <-R prf_out; return(ca1)
	 )
	 else
	    return(prf(exp'(ma1, a), xa1)) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) :=
      	 let a': Z = a[ja] in
	 find u <= na suchthat defined(ka[u],a[u]) && a' = a[u] then (* a' compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
         if defined(ka) then (* a compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
	 (* At this point, a and a' are not compromised, and must never be compromised in the future *)
	 let ka': bool = true in
         find vaDH <= na1 suchthat defined(a''[vaDH],xa1[vaDH],ca1[vaDH]) && a' = a''[vaDH] && xa2 = xa1[vaDH] then return(ca1[vaDH]) else
         find vaDH <= na2 suchthat defined(a'[vaDH],xa2[vaDH],ca2[vaDH]) && a' = a'[vaDH] && xa2 = xa2[vaDH] then return(ca2[vaDH]) else
         find vaDH <= na1, va <= na suchthat defined(a[va], a''[vaDH, va], xa1[vaDH, va], ca1[vaDH, va]) && a' = a[va] && a = a''[vaDH, va] && xa2 = xa1[vaDH, va] then return(ca1[vaDH, va]) else
         find vaDH <= na2, va <= na suchthat defined(a[va], a'[vaDH, va], xa2[vaDH, va], ca2[vaDH, va]) && a' = a[va] && a = a'[vaDH, va] && xa2 = xa2[vaDH, va] then return(ca2[vaDH, va]) else
         ca2 <-R prf_out; return(ca2)).
	 
}

