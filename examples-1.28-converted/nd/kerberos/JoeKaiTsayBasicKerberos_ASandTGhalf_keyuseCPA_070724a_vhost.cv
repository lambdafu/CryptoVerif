(* First round and a half of Basic Kerberos, key usability *)


(* Now, the proof is automatic; one just has to conclude manually
on the last game as explained below.

Proof is
	auto
	SArename AK_18
	simplify
	auto
	show_game
Concluding manually is trivial:
	Z(menc) = Z(test(b1,m1,m2)) = Z(m1) = Z(m2) since m1 and m2 have same length
	so actually the game does not depend on b1.
(CryptoVerif cannot make the case distinction b1=true/b1=false 
when "test" is used. It could with "if", but then it would not be 
able to merge both branches of the "if" when they execute the 
same code.)
*)

param N.
param N2.
param N3.
param qC.
param qD.
param qE.

type nonce [large,fixed].
			(* type host [bounded].*)
type client [bounded].
type kas [bounded].
type tgs [bounded].
type server [bounded].
type mkey [bounded].
type mkeyseed [fixed].
type key [fixed].
type keyseed [fixed].
type seed [fixed].
type macs [fixed].
type maxenc [bounded].
type maxmac [bounded].
type timest [fixed].									(* needed in particular for CS_reply *)

(* following functions are needed to set the type of a list of elements to `bitstring', so that the list can be encrypted: *)
fun concat1(key, mkey, nonce, tgs):maxenc [data]. 					(* needed for {AK, mAK, n1, T}_Kc in AS_reply  *)
fun concat2(key, mkey, client):maxenc [data].  						(* needed for TGT and ST *)
(* fun concat3(key, mkey, nonce, server):maxenc [compos]. *)   		       		(*for {SK, mSK, n2, S}_AK in TG_reply *)
fun pad(client, timest):maxenc [data].

equation forall y:key, w:mkey, z:client, t2:key, w2:mkey, y2:nonce, z2:tgs;  concat2(y,w,z) <> concat1(t2,w2,y2,z2).
equation forall z:client,t: timest, t2:key, w2:mkey, y2:nonce, z2:tgs;  pad(z, t) <> concat1(t2,w2,y2,z2).
equation forall y:key, w:mkey, z:client, t2: timest,  z2: client;    concat2(y,w,z) <> pad(z2,t2).


(* Shared-key encryption (CPA Stream cipher) *)

proba Penc.

fun enc(maxenc, key, seed): maxmac.
fun kgen(keyseed):key.
fun dec(maxmac, key): bitstringbot.

fun enc2(maxenc, key, seed): maxmac.
fun kgen2(keyseed):key.

fun injbot(maxenc):bitstringbot [data].
(* The function Z returns for each bitstring, a bitstring of the same length, consisting only of zeroes. *)
fun    Z(maxenc):maxenc.
const  Zconcat1:maxenc.
const  Zconcat2:maxenc.
(*const  Zconst3: maxenc.*)
const  Zpad:maxenc.

equation forall m:maxenc, r:keyseed, r2:seed; 
	dec(enc(m, kgen(r), r2), kgen(r)) = injbot(m).
equation forall y:nonce, z:tgs, t:key, u:mkey;
	Z(concat1(t, u, y, z)) = Zconcat1.
equation forall y:key, w:mkey, z:client; 
	Z(concat2(y, w, z)) = Zconcat2.
(*forall  y:nonce, z:server, t:key, u:mkey;
	Z(concat3(t, u, y, z)) = Zconcat3.*)
equation forall z:client, t:timest;
        Z(pad(z,t)) = Zpad. 
					    

equiv
  ! N2 new r: keyseed; ! N new r2: seed; gen_Oracle(x: maxenc) := return(enc(x, kgen(r), r2))
<=(N2 * Penc(time, N))=>
  ! N2 new r: keyseed; ! N new r2: seed; gen_Oracle(x: maxenc) := return(enc2(Z(x), kgen2(r), r2)).

(* Weakly Unforgeable MAC *)

proba Pmac.

fun mac(maxmac, mkey):macs.
fun check(maxmac, mkey, macs): bool.
fun mkgen(mkeyseed):mkey.

fun mac2(maxmac, mkey):macs.
fun check2(maxmac, mkey, macs): bool.
fun mkgen2(mkeyseed):mkey.

equation forall m:maxmac, r:mkeyseed;
	check(m, mkgen(r), mac(m, mkgen(r))).
equation forall m:maxmac, r:mkeyseed;
	check2(m, mkgen2(r), mac2(m, mkgen2(r))).

						   
equiv
  ! N3 new r: mkeyseed; (
    ! N gen_Oracle_1(x: maxmac) := return(mac(x, mkgen(r))) |
    ! N2 gen_Oracle_2(m: maxmac, ma: macs) := return(check(m, mkgen(r), ma)))
<=(N3 * Pmac(time, N, N2))=>
  ! N3 new r: mkeyseed; (
    ! N gen_Oracle_1(x: maxmac) := return(mac2(x, mkgen2(r))) |
    ! N2 gen_Oracle_2(m: maxmac, ma: macs) := find j <= N suchthat defined(x[j]) && (m = x[j]) &&  (* (ma = mac2(x[j], mkgen2(r)))*) check2(x[j], mkgen2(r), ma) then return(true) else return(false)).



(* Queries *)

channel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20,c21, c22, c23, c24,c25, start, finish, cC, cT.
const C : client.
const T : tgs.
const K : kas.
const S : server.						

fun acceptC(tgs,server):bitstring.
fun acceptK(client):bitstring. 
fun acceptT(client):bitstring.



event fullKC(client, tgs,nonce, maxmac, maxmac).
event fullCK(tgs, nonce,maxmac, maxmac).		
event partCT(tgs,  maxmac, maxmac).
event fullCT(tgs, server,  nonce, maxmac, maxmac, maxmac). 			
event partTC(client, maxmac, maxmac).    		
event fullTC(client,server,  nonce, maxmac, maxmac, maxmac).		
      		


(* authentication queries : *)

query z: maxmac, y: maxmac, x: maxmac, N: nonce;
  inj-event(fullCK(T, N, x, y)) ==> inj-event(fullKC(C, T, N, z, y)) public_vars b1.
		 
query y': maxmac, N: nonce, x': maxmac, y: maxmac, x: maxmac;
  event(partTC(C, x, y)) ==> (event(partCT(T, x', y)) && event(fullKC(C, T, N, x, y'))) public_vars b1.	


(* Secrecy of the coin b1 *)
query secret b1 [onesession].




	(*OK 
	in(finish, ());
	if h = T then
	(
	let keyAK:key = AK in
	let mkeyAK: mkey = mAK	
	)
	else out(cC, (AK, mAK)). *)

	



      







(* Key Usability : we want to check if the key AK is still good for CPA secure encryption *)
(* Implementing a test as a function.
   Useful to avoid expanding if, which is necessary for this proof. *)

fun test(bool, maxenc, maxenc):maxenc.
equation forall x:maxenc,y:maxenc; test(true,x,y) = x.
equation forall x:maxenc,y:maxenc; test(false,x,y) = y.





(* let processOD =
        in(c23, (a: maxmac, b:macs));
    	find j5<= qE suchthat defined (aT[j5], bT[j5]) && a=aT[j5] && b=bT[j5] then yield else
    	if check(a, mk1, b) then
    	let m = dec(a, k1) in
    	out(c24, m). *)

process
	in(start, ());
new rKc: keyseed;
let Kc: key = kgen(rKc) in
new rmKc: mkeyseed;
let mKc: mkey = mkgen(rmKc) in
new rKt: keyseed;
let Kt: key = kgen(rKt) in
new rmKt: mkeyseed;
let mKt: mkey = mkgen(rmKt) in
out(c20, ());
((
  ! i_1 <= N
  in(c1[i_1], (h: tgs, h2: server));
  new Nc: nonce;
  out(c2[i_1], (C, h, Nc));
  in(c3[i_1], (=C, m: maxmac, mac1: macs, m2_1: maxmac, mac2_1: macs));
  if check(m2_1, mKc, mac2_1) then
  let injbot(concat1(AK: key, mAK: mkey, =Nc, =h)) = dec(m2_1, Kc) in
  event fullCK(h, Nc, m, m2_1);
  new Nt: nonce;
  new ts: timest;
  new r1: seed;
  let e5: maxmac = enc(pad(C, ts), AK, r1) in
  let mac5: macs = mac(e5, mAK) in
  event partCT(h, m, e5);
  out(c4[i_1], (m, mac1, e5, mac5, h2, Nt))
) | (
  ! i_2 <= N
  in(c14[i_2], (hc: client, ht: tgs, n: nonce));
  find j1 = j1_1 <= N2 suchthat defined(Khost[j1_1], Rkey[j1_1], Rmkey[j1_1]) && (Khost[j1_1] = hc) then
  find j2 = j2_1 <= N2 suchthat defined(Lhost[j2_1], Qkey[j2_1], Qmkey[j2_1]) && (Lhost[j2_1] = ht) then
  new rAK: keyseed;
  let AK_1: key = kgen(rAK) in
  new rmAK: mkeyseed;
  let mAK_1: mkey = mkgen(rmAK) in
  new r3: seed;
  let e3: maxmac = enc(concat2(AK_1, mAK_1, hc), Qkey[j2], r3) in
  let mac3: macs = mac(e3, Qmkey[j2]) in
  new r4: seed;
  let e4: maxmac = enc(concat1(AK_1, mAK_1, n, ht), Rkey[j1], r4) in
  let mac4: macs = mac(e4, Rmkey[j1]) in
  event fullKC(hc, ht, n, e3, e4);
  out(c15[i_2], (hc, e3, mac3, e4, mac4))
) | (
  ! i_3 <= N
  in(c7[i_3], (m8: maxmac, mac8: macs, m9: maxmac, mac9: macs, h3: server, n2_1: nonce));
  if check(m8, mKt, mac8) then
  let injbot(concat2(AK1: key, mAK1: mkey, h4: client)) = dec(m8, Kt) in
  if check(m9, mAK1, mac9) then
  let injbot(pad(=h4, t: timest)) = dec(m9, AK1) in
  event partTC(h4, m8, m9);
  out(c8[i_3], acceptT(h4));
  in(c9[i_3], ());
  if h4 = C then
  (
    let keyTAK: key = AK1
  )
  else
    out(cT[i_3], (AK1, mAK1))
) | (
  ! i_4 <= N2
  in(c13[i_4], (Khost: client, Kkey: key, Kmkey: mkey));
  let Rkey: key = (if Khost = C then Kc else Kkey) in
  let Rmkey: mkey = (if Khost = C then mKc else Kmkey)
) | (
  ! i_5 <= N2
  in(c10[i_5], (Lhost: tgs, Lkey: key, Lmkey: mkey));
  let Qkey: key = (if Lhost = T then Kt else Lkey) in
  let Qmkey: mkey = (if Lhost = T then mKt else Lmkey)
) | (
  in(c24, ());
  new b1: bool;
  find j3 = j3_1 <= N suchthat defined(keyTAK[j3_1]) then
  let k1: key = keyTAK[j3] in
  out(c25, ());
  ! i_6 <= qE
  in(c21[i_6], (m1: maxenc, m2_2: maxenc));
  if Z(m1) = Z(m2_2) then
  let menc: maxenc = test(b1, m1, m2_2) in
  new r: seed;
  let aT: maxmac = enc(menc, k1, r) in
  out(c22[i_6], aT)
))



(* EXPECTED
RESULT Could not prove one-session secrecy of b1.
0.488s (user 0.468s + system 0.020s), max rss 73600K
END *)
