(* 3 rounds  of Basic Kerberos, consider key usability of AK after client completes 2nd round, client and tgs are restricted not to take outputs by the encryption oracle, authentication will partly fail as expected, vhost *)

proof {
auto;
show_game
}

(* The proof for 1secrecy of b1 can then be concluded by seeing that menc 
occurs only as Z(menc), or in find branches that will never be executed 
-- Those find branches are now removed automatically by CryptoVerif. *)


param N.
param N2.
param N3.
param N4.
param N5.
param qE.
param qD.

type nonce [large,fixed].
type kas [bounded].
type client [bounded].
type tgs [bounded].
type server [bounded].
type mkey [bounded].
type mkeyseed [fixed].
type key [fixed].
type keyseed [fixed].
type seed [fixed].
type macs [fixed].
type maxenc [bounded].
type maxmac [bounded].
type timest [large,fixed].								(* needed in particular for CS_reply *)

(* following functions are needed to set the type of a list of elements to `bitstring', so that the list can be encrypted: *)
fun concat1(key, mkey, nonce, tgs):maxenc [data]. 					(* needed for {AK, mAK, n1, T}_Kc in AS_reply *)
fun concat2(key, mkey, client):maxenc [data].  					(* needed for TGT and ST *)
fun concat3(key, mkey, nonce, server):maxenc [data]. 		       			(*for {SK, mSK, n2, S}_AK in TG_reply *)
fun pad(client, timest):maxenc [data].
fun padts(timest): maxenc [data].

forall y:key, w:mkey, z:client, t2:key, w2:mkey, y2:nonce, z2:tgs;  concat2(y,w,z) <> concat1(t2,w2,y2,z2).
forall t:key, w: mkey, y: nonce, z: server, t2:key, w2:mkey, y2:nonce, z2:tgs;  concat3(t,w,y,z) <> concat1(t2,w2,y2,z2).
forall z:client,t: timest, t2:key, w2:mkey, y2:nonce, z2:tgs;  pad(z,t) <> concat1(t2,w2,y2,z2).
forall t: timest, t2:key, w2:mkey, y2:nonce, z2:tgs;  padts(t) <> concat1(t2,w2,y2,z2).
forall y:key, w:mkey, z:client, t2: key, w2: mkey, y2: nonce, z2: server;    concat2(y,w,z) <> concat3(t2,w2,y2,z2).
forall y:key, w:mkey, z:client, t2: timest,  z2:client;    concat2(y,w,z) <> pad(z2,t2). 
forall y:key, w:mkey, z:client, t2: timest;    concat2(y,w,z) <> padts(t2). 
forall t:key, w: mkey, y: nonce, z: server, t2:timest, z2:client;  concat3(t,w,y,z) <> pad(z2, t2).
forall t:key, w: mkey, y: nonce, z: server, t2:timest;  concat3(t,w,y,z) <> padts( t2).
forall t: timest, z: client, t2: timest;  pad(z,t)<> padts(t2).

(* Shared-key encryption (CPA Stream cipher) *)

proba Penc.

fun enc(maxenc, key, seed): maxmac.
fun kgen(keyseed):key.
fun dec(maxmac, key): bitstringbot.

fun enc2(maxenc, key, seed): maxmac.
fun kgen2(keyseed):key.

fun injbot(maxenc):bitstringbot [data].
(* The function Z returns for each bitstring, a bitstring of the same length, consisting only of zeroes. *)
fun    Z(maxenc):maxenc.
const  Zconcat1:maxenc.
const  Zconcat2:maxenc.
const  Zconcat3: maxenc.
const  Zpad:maxenc.
const  Zpadts: maxenc.

forall m:maxenc, r:keyseed, r2:seed; 
	dec(enc(m, kgen(r), r2), kgen(r)) = injbot(m).
forall y:nonce, z:tgs, t:key, u:mkey;
	Z(concat1(t, u, y, z)) = Zconcat1.
forall y:key, w:mkey, z:client; 
	Z(concat2(y, w, z)) = Zconcat2.
forall  y:nonce, z:server, t:key, u:mkey;
	Z(concat3(t, u, y, z)) = Zconcat3.
forall z:client, t:timest;
        Z(pad(z,t)) = Zpad.
forall t: timest;
        Z(padts(t)) = Zpadts.
					    

equiv
  ! N2 new r: keyseed; ! N new r2: seed; gen_Oracle(x: maxenc) := return(enc(x, kgen(r), r2))
<=(N2 * Penc(time, N))=>
  ! N2 new r: keyseed; ! N new r2: seed; gen_Oracle(x: maxenc) := return(enc2(Z(x), kgen2(r), r2)).

(* Weakly Unforgeable MAC *)

proba Pmac.

fun mac(maxmac, mkey):macs.
fun check(maxmac, mkey, macs): bool.
fun mkgen(mkeyseed):mkey.

fun mac2(maxmac, mkey):macs.
fun check2(maxmac, mkey, macs): bool.
fun mkgen2(mkeyseed):mkey.

forall m:maxmac, r:mkeyseed;
	check(m, mkgen(r), mac(m, mkgen(r))).
forall m:maxmac, r:mkeyseed;
	check2(m, mkgen2(r), mac2(m, mkgen2(r))).

						   
equiv
  ! N3 new r: mkeyseed; (
    ! N gen_Oracle_1(x: maxmac) := return(mac(x, mkgen(r))) |
    ! N2 gen_Oracle_2(m: maxmac, ma: macs) := return(check(m, mkgen(r), ma)))
<=(N3 * Pmac(time, N, N2))=>
  ! N3 new r: mkeyseed; (
    ! N gen_Oracle_1(x: maxmac) := return(mac2(x, mkgen2(r))) |
    ! N2 gen_Oracle_2(m: maxmac, ma: macs) := find j <= N suchthat defined(x[j]) && (m = x[j]) &&  (* (ma = mac2(x[j], mkgen2(r)))*) check2(x[j], mkgen2(r), ma) then return(true) else return(false)).



(* Queries *)

channel c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19,c20, c21, c22, c23, c24, c25, start, finish, cC, cS.
const C : client.
const K : kas.
const T : tgs.
const S : server.						

fun acceptC1(kas):bitstring.
fun acceptC2(tgs, server):bitstring.
fun acceptC3(tgs, server):bitstring.
fun acceptT(client, server):bitstring.
fun acceptS(client): bitstring.

event fullKC(client, tgs,nonce, maxmac, maxmac).
event fullCK(tgs, nonce,maxmac, maxmac).		
event partCT(tgs,  maxmac, maxmac).
event fullCT(tgs, server,  nonce, maxmac, maxmac, maxmac). 			
event partTC(client, maxmac, maxmac).    		
event fullTC(client,server, nonce, maxmac, maxmac, maxmac, maxmac).
			

event partCS(server,tgs, maxmac, maxmac).
event fullCS(server,tgs,  maxmac, maxmac, maxmac).
event partSC(client, maxmac, maxmac).
event fullSC(client, maxmac, maxmac, maxmac).      		


(* authentication queries : *)

query z: maxmac, y: maxmac, x: maxmac, N: nonce;
  inj-event(fullCK(T, N, x, y)) ==> inj-event(fullKC(C, T, N, z, y)) public_vars b1.
		 
query y': maxmac, N: nonce, x': maxmac, y: maxmac, x: maxmac;
  event(partTC(C, x, y)) ==> (event(partCT(T, x', y)) && event(fullKC(C, T, N, x, y'))) public_vars b1.
						  	
(* query x: maxmac, x':maxmac,z: maxmac, z':maxmac, y:maxmac, w:maxmac, N:nonce, N': nonce;
      	event fullCT(T,S, N,x,z,y) ==> fullTC(C,S, N,x',z',y) && fullKC(C,T,N',x',w). *)
query v: maxmac, z': maxmac, x': maxmac, y: maxmac, z: maxmac, x: maxmac, N: nonce;
  inj-event(fullCT(T, S, N, x, z, y)) ==> inj-event(fullTC(C, S, N, x', z', v, y)) public_vars b1.

query w: maxmac, v': maxmac, v: maxmac, N: nonce, x: maxmac, y: maxmac, z: maxmac;
  event(partSC(C, z, y)) ==> (event(partCS(S, T, x, y)) && event(fullTC(C, S, N, v, v', z, w))) public_vars b1.
query y': maxmac, x: maxmac, w: maxmac, y: maxmac, z: maxmac;
  event(fullCS(S, T, z, y, w)) ==> event(fullSC(C, x, y', w)) public_vars b1.	 

(* Secrecy of the coin b1 *)
query secret b1 [onesession].




(*channels c1, c2, c3, c4, c6, c9, c10, c17, c18, c19, c20 *)



	
	(* (! N4 processC3).*)



		
(*channels c13, c16, c21 *)





	
					
(*channels c14, c15*)


(*channels c7, c8 *)
	

(*channels c11, c12*)	

	

(* Key Usability : we want to check if the encrypt-then-mac scheme is still CCA2 secure when using the key pair (AK,mAK) *)
(* Implementing a test as a function.
   Useful to avoid expanding if, which is necessary for this proof. *)

fun test(bool, maxenc, maxenc):maxenc.
forall x:maxenc,y:maxenc; test(true,x,y) = x.
forall x:maxenc,y:maxenc; test(false,x,y) = y.





									


process
	in(start, ());
new rKc: keyseed;
let Kc: key = kgen(rKc) in
new rmKc: mkeyseed;
let mKc: mkey = mkgen(rmKc) in
new rKt: keyseed;
let Kt: key = kgen(rKt) in
new rmKt: mkeyseed;
let mKt: mkey = mkgen(rmKt) in
new rKs: keyseed;
let Ks: key = kgen(rKs) in
new rmKs: mkeyseed;
let mKs: mkey = mkgen(rmKs) in
out(c25, ());
((
  ! i_1 <= N
  in(c1[i_1], h: tgs);
  new Nc: nonce;
  out(c2[i_1], (C, h, Nc));
  in(c3[i_1], (=C, m_1: maxmac, mac1: macs, m2_1: maxmac, mac2_1: macs));
  if check(m2_1, mKc, mac2_1) then
  let injbot(concat1(AK: key, mAK: mkey, =Nc, =h)) = dec(m2_1, Kc) in
  event fullCK(h, Nc, m_1, m2_1);
  out(c18[i_1], acceptC1(K));
  ! i_2 <= N3
  in(c17[i_2, i_1], (hT: tgs, h2: server));
  if hT = h then
  new Nt: nonce;
  new ts_1: timest;
  new r1: seed;
  let e5: maxmac = enc(pad(C, ts_1), AK, r1) in
  let mac5: macs = mac(e5, mAK) in
  event partCT(h, m_1, e5);
  out(c4[i_2, i_1], (m_1, mac1, e5, mac5, h2, Nt));
  in(c5[i_2, i_1], (=C, m6: maxmac, mac6: macs, m7: maxmac, mac7: macs));
  find j8 = j8_1 <= qE suchthat defined(aT[j8_1]) && (m7 = aT[j8_1]) then
    yield
  else
    if check(m7, mAK, mac7) then
    let injbot(concat3(SK: key, mSK: mkey, =Nt, =h2)) = dec(m7, AK) in
    event fullCT(h, h2, Nt, m_1, e5, m7);
    out(c19[i_2, i_1], acceptC2(h, h2));
    in(c9[i_2, i_1], ());
    if hT = T then
    (
      let keyCAK: key = AK in
      let mkeyCAK: mkey = mAK
    )
    else
      out(cC[i_2, i_1], (AK, mAK))
) | (
  ! i_3 <= N
  in(c14[i_3], (hc: client, ht: tgs, n: nonce));
  find j1 = j1_1 <= N2 suchthat defined(Khost[j1_1], Rkey[j1_1], Rmkey[j1_1]) && (Khost[j1_1] = hc) then
  find j2 = j2_1 <= N2 suchthat defined(Lhost[j2_1], Qkey[j2_1], Qmkey[j2_1]) && (Lhost[j2_1] = ht) then
  new rAK: keyseed;
  let AK_1: key = kgen(rAK) in
  new rmAK: mkeyseed;
  let mAK_1: mkey = mkgen(rmAK) in
  new r3: seed;
  let e3: maxmac = enc(concat2(AK_1, mAK_1, hc), Qkey[j2], r3) in
  let mac3: macs = mac(e3, Qmkey[j2]) in
  new r4: seed;
  let e4: maxmac = enc(concat1(AK_1, mAK_1, n, ht), Rkey[j1], r4) in
  let mac4: macs = mac(e4, Rmkey[j1]) in
  event fullKC(hc, ht, n, e3, e4);
  out(c15[i_3], (hc, e3, mac3, e4, mac4))
) | (
  ! i_4 <= N
  in(c7[i_4], (m8: maxmac, mac8: macs, m9: maxmac, mac9: macs, h3: server, n2_1: nonce));
  find j9 = j9_1 <= qE suchthat defined(aT[j9_1]) && (m9 = aT[j9_1]) then
    yield
  else
    if check(m8, mKt, mac8) then
    let injbot(concat2(AK_2: key, mAK_2: mkey, h4: client)) = dec(m8, Kt) in
    if check(m9, mAK_2, mac9) then
    let injbot(pad(=h4, ts_2: timest)) = dec(m9, AK_2) in
    event partTC(h4, m8, m9);
    find j3_3 = j3_1 <= N2 suchthat defined(Mhost1[j3_1], Mhost2[j3_1], Pmkey[j3_1], Pkey[j3_1]) && (Mhost1[j3_1] = T) && (Mhost2[j3_1] = h3) then
    new rSK: keyseed;
    let SK_1: key = kgen(rSK) in
    new rmSK: mkeyseed;
    let mSK_1: mkey = mkgen(rmSK) in
    new r10: seed;
    let e10: maxmac = enc(concat2(SK_1, mSK_1, h4), Pkey[j3_3], r10) in
    let mac10: macs = mac(e10, Pmkey[j3_3]) in
    new r11: seed;
    let e11: maxmac = enc(concat3(SK_1, mSK_1, n2_1, h3), AK_2, r11) in
    let mac11: macs = mac(e11, mAK_2) in
    event fullTC(h4, h3, n2_1, m8, m9, e10, e11);
    out(c8[i_4], (h4, e10, mac10, e11, mac11, acceptT(h4, h3)))
) | (
  ! i_5 <= N2
  in(c13[i_5], (Khost: client, Kkey: key, Kmkey: mkey));
  let Rkey: key = (if Khost = C then Kc else Kkey) in
  let Rmkey: mkey = (if Khost = C then mKc else Kmkey)
) | (
  ! i_6 <= N2
  in(c21[i_6], (Lhost: tgs, Lkey: key, Lmkey: mkey));
  let Qkey: key = (if Lhost = T then Kt else Lkey) in
  let Qmkey: mkey = (if Lhost = T then mKt else Lmkey)
) | (
  ! i_7 <= N2
  in(c16[i_7], (Mhost1: tgs, Mhost2: server, Mkey: key, Mmkey: mkey));
  let Pkey: key = (if (Mhost1 = T) && (Mhost2 = S) then Ks else Mkey) in
  let Pmkey: mkey = (if (Mhost1 = T) && (Mhost2 = S) then mKs else Mmkey)
) | (
  in(c24, ());
  new b1: bool;
  find j3_4 = j3_2 <= N, j4 = j4_1 <= N3 suchthat defined(keyCAK[j4_1, j3_2], mkeyCAK[j4_1, j3_2]) then
  let k1: key = keyCAK[j4, j3_4] in
  let mk1: mkey = mkeyCAK[j4, j3_4] in
  out(c25, ());
  ((
    ! i_8 <= qE
    in(c21[i_8], (m1: maxenc, m2_2: maxenc));
    if Z(m1) = Z(m2_2) then
    let menc: maxenc = test(b1, m1, m2_2) in
    new r: seed;
    let aT: maxmac = enc(menc, k1, r) in
    let bT: macs = mac(aT, mk1) in
    out(c22[i_8], (aT, bT))
  ) | (
    ! i_9 <= qD
    in(c23[i_9], (a: maxmac, b: macs));
    find j5 = j5_1 <= qE suchthat defined(aT[j5_1]) && (a = aT[j5_1]) then
      yield
    else
      if check(a, mk1, b) then
      let m_2: bitstringbot = dec(a, k1) in
      out(c24[i_9], m_2)
  ))
))




(* EXPECTED
RESULT Could not prove one-session secrecy of b1.
5.524s (user 5.468s + system 0.056s), max rss 137408K
END *)
