(* ARINC 823 
AMS protocol using a shared secret key
described in Attachment 8 of the ARINC specification 823 Part I. 

CryptoVerif model by Bruno Blanchet, INRIA Paris-Rocquencourt. *)

(**** Manual indications for the proof ****)

proof {
      set useKnownEqualitiesInCryptoTransform = false;
      auto;
      out_game "g1.out" occ;
      replace 2029 "MAC2(K_UV_1, TBP_AMS_Init_REQ_3[ri_35])"; (*MAC0_U_3[ri_35]*)
      out_game "g2.out" occ;
      replace 2027 "MAC2(K_UV_1, TBP_AMS_Init_REQ_2)"; (*MAC0_U_2*)
      replace 1116 "MAC2(K_UV_1, TBP_AMS_Init_REQ_3[ri_45])"; (*MAC0_U_3[ri_45]*)
      replace 1114 "MAC2(K_UV_1, TBP_AMS_Init_REQ_1)"; (*MAC0_U_1*)
      replace 195 "MAC2(K_UV_1, TBP_AMS_Init_REQ_3[ri_55])"; (*MAC0_U_3[ri_55]*)
      replace 193 "MAC2(K_UV_1, TBP_AMS_Init_REQ)"; (*MAC0_U*)
      auto
}

(**** Declarations of types, constants, and function symbols ****)

(* Type for session ids, used internally in the model to distinguish
   each session of the protocol. *)

type session_ids [large, fixed].

(* Type of 32 bits numbers *)

type t_Rand32 [large, fixed]. 

(* Ids 
U = aircraft
V = ground entity *)

type t_id [fixed]. (* 8 bytes = 64 bits entity type, AMS_EntityType *)
const U, V: t_id.

(* AMS Message elements *)

type t_AMS_elem.
type t_software_part_number.
type t_policy_id.
type t_algo_bits [fixed].

fun buildAMS10_s_init_info(t_software_part_number, t_policy_id, t_id, t_id): t_AMS_elem [data].
fun buildAMS40_entity_id(t_id, t_id): t_AMS_elem [data].
fun buildAMS41_comp_algo_id(t_algo_bits): t_AMS_elem [data].
fun buildAMS42_comp_algo_sel(t_algo_bits): t_AMS_elem [data].
    (* The first bit is 1 when DMC level 0 is supported.
       The second bit is 1 when DMC level 1 is supported.
       The third bit is 1 when DEFLATE is supported.
       We ignore algorithms reserved for future use. *)

fun payload_with_1_element(t_AMS_elem): bitstring [data].
fun concat_AMS_element(t_AMS_elem, bitstring): bitstring [data].

(* Encoding algorithms *)

type t_encode_algo [fixed]. (* 2 bits *)

const encode_OFF, encode_B64, encode_B64PAD, encode_B128: t_encode_algo.

fun encode(t_encode_algo, bitstring): bitstring.
fun decode(t_encode_algo, bitstring): bitstring.

equation forall encode_algo: t_encode_algo, payload:bitstring; 
      decode(encode_algo, encode(encode_algo, payload)) = payload.

(* encode is injective *)
equation forall encode_algo: t_encode_algo, payload1:bitstring, payload2:bitstring; 
      (encode(encode_algo, payload1) = encode(encode_algo, payload2)) = (payload1 = payload2).

(* Compression *)

type t_comp_algo [fixed]. (* 4 bits, Value of the CompMode field *)

const comp_OFF, comp_DMC0, comp_DMC1, comp_DEFLATE: t_comp_algo.

fun compress(t_comp_algo, bitstring): bitstring.
fun decompress(t_comp_algo, bitstring): bitstring.

equation forall comp_algo: t_comp_algo, payload:bitstring; 
      decompress(comp_algo, compress(comp_algo, payload)) = payload.

fun bool_and(t_algo_bits, t_algo_bits): t_algo_bits.
fun select_common_compression(t_AMS_elem, t_comp_algo): t_comp_algo.

(* Algorithms *)

type t_AMS_AlgID [bounded].
type t_MAClen [bounded].
type t_AuthAlgo [bounded].
type t_EncAlgo [bounded].

fun algo(t_MAClen, t_AuthAlgo, t_EncAlgo): t_AMS_AlgID [data].

const MAClen32, MAClen64, MAClen128: t_MAClen.
const HMAC_SHA256: t_AuthAlgo.
const NULL_enc, AES128_CFB128: t_EncAlgo.

(* Policy types *)

type t_AMS_Policy [fixed]. (* 2 bits *)

const NONE, AUTH, BOTH: t_AMS_Policy.

fun get_policy(t_policy_id, bitstring): t_AMS_Policy.
     (* The definition of the policy is left implicit in this model.
     	get_policy(policy_id, msg) is supposed to 
	determine the expected policy to apply to the message msg 
	from the message msg itself and the policy identifier policy_id. *)

letfun get_protect_mode(policy: t_AMS_Policy, enc_algo: t_EncAlgo) =
       if enc_algo = NULL_enc && policy = BOTH then AUTH else policy.
(* If the security policy specifies the BOTH protection mode
   and the selected encryption is NULL, then ProtectMode is set to AUTH.
   In all other cases, ProtectMode is the protection mode
   specified in the security policy. *)

(* Protocol ids *)

type t_AMS_PID [bounded]. (* 1 byte, "1" or "2" *)

const ams_pid1 (* public-key protocol *), ams_pid2 (* shared-key protocol *): t_AMS_PID.

(* Commands *)

type t_Cmd [fixed]. (* 4 bits *)

const Data_IND, Info_IND, DataCnf_IND, Release_REQ, Release_RSP_Minus, 
      Release_RSP_Plus, Init_IND, Init_REQ, Init_RSP_Minus, Init_RSP_Plus,
      Abort_IND: t_Cmd.

(* Counter *)

type t_Count [fixed].

const Count1: t_Count.
const Count_unspecified: t_Count. 
      (* Used as a dummy value to fill the count argument
      	 of event recv_msg when the message is sent unprotected. *)

(* MAC *)

type mac_key [large, fixed].

type t_SHA256_out [large, fixed]. (* 256 bits, output of SHA256 *)

fun MAC(mac_key, bitstring): t_SHA256_out.

fun sessionMAC(t_MAClen, mac_key, bitstring): bitstring.

(* sessionMAC is SUF-CMA for each of the 3 lengths *)

fun sessionMAC2(t_MAClen, mac_key, bitstring): bitstring.
param N, N2, N3.
type mac_32bits [fixed].
type mac_64bits [fixed].
type mac_128bits [fixed].

proba PPRF. 
      (* PPRF(t, qMAC, l, qKDF256, qKDF128) is the probability of 
         distinguishing MAC, KDF256, and KDF128 from independent pseudo-random
	 functions in time t, with qMAC, qKDF256, qKDF128 queries to
	 MAC, KDF256, and KDF128 respectively, with MAC queries of length
	 at most l. *)

equiv(suf_cma_truncated32_mac )
  ! N3 new k: mac_key; (
    ! N Omac(x: bitstring) := return(sessionMAC(MAClen32, k, x)) |
    ! N2 Ocheck(m: bitstring, ma: bitstring) := return(ma = sessionMAC(MAClen32, k, m)))
<=(N3 * (4*N2/|mac_32bits| + 2*PPRF(time + (N3-1)*(N+N2)*time(sessionMAC,maxlength(x)), N + N2, max(maxlength(x), maxlength(m)), 0, 0)))=> [computational]
  ! N3 new k: mac_key [unchanged]; (
    ! N Omac(x: bitstring) := return(sessionMAC2(MAClen32, k, x)) |
    ! N2 Ocheck(m: bitstring, ma: bitstring) := find j <= N suchthat defined(x[j]) && (m = x[j]) && ma = sessionMAC2(MAClen32, k, m) then return(true) else return(false)).

equiv(suf_cma_truncated64_mac )
  ! N3 new k: mac_key; (
    ! N Omac(x: bitstring) := return(sessionMAC(MAClen64, k, x)) |
    ! N2 Ocheck(m: bitstring, ma: bitstring) := return(ma = sessionMAC(MAClen64, k, m)))
<=(N3 * (4*N2/|mac_64bits| + 2*PPRF(time + (N3-1)*(N+N2)*time(sessionMAC,maxlength(x)), N + N2, max(maxlength(x), maxlength(m)), 0, 0)))=> [computational]
  ! N3 new k: mac_key [unchanged]; (
    ! N Omac(x: bitstring) := return(sessionMAC2(MAClen64, k, x)) |
    ! N2 Ocheck(m: bitstring, ma: bitstring) := find j <= N suchthat defined(x[j]) && (m = x[j]) && ma = sessionMAC2(MAClen64, k, m) then return(true) else return(false)).

equiv(suf_cma_truncated128_mac )
  ! N3 new k: mac_key; (
    ! N Omac(x: bitstring) := return(sessionMAC(MAClen128, k, x)) |
    ! N2 Ocheck(m: bitstring, ma: bitstring) := return(ma = sessionMAC(MAClen128, k, m)))
<=(N3 * (4*N2/|mac_128bits| + 2*PPRF(time + (N3-1)*(N+N2)*time(sessionMAC,maxlength(x)), N + N2, max(maxlength(x), maxlength(m)), 0, 0)))=> [computational]
  ! N3 new k: mac_key [unchanged]; (
    ! N Omac(x: bitstring) := return(sessionMAC2(MAClen128, k, x)) |
    ! N2 Ocheck(m: bitstring, ma: bitstring) := find j <= N suchthat defined(x[j]) && (m = x[j]) && ma = sessionMAC2(MAClen128, k, m) then return(true) else return(false)).

(* Encryption *)

type enc_key [large, fixed]. (* 128 bits *)
type t_IVdata [fixed].

type byte [fixed]. (* 1 byte = 8 bits *)
const CstDN: byte. (* 0x00 *)
const CstUP: byte. (* 0x01 *)
fun buildIVdata(byte, t_Count): t_IVdata [data].

fun E'(enc_key, t_IVdata, bitstring): bitstring.
fun D'(enc_key, t_IVdata, bitstring): bitstring.

equation forall k: enc_key, IVdata: t_IVdata, msg: bitstring;
      D'(k, IVdata, E'(k, IVdata, msg)) = msg.

(* encryption is IND-CPA provided IVdata is distinct
   for each encryption --- This property is needed only for
   secrecy. *)

(* Hash function HASH is collision resistant *)

type hash_key [large,fixed].
proba Phash.
expand CollisionResistant_hash(hash_key, bitstring, t_SHA256_out, HASH, Phash).

fun concat_hash(bitstring, t_Rand32): bitstring [data].

fun KDF256(mac_key, t_SHA256_out, t_id, t_id): mac_key.
fun KDF128(mac_key, t_SHA256_out, t_id, t_id): enc_key.

(* MAC is HMAC_SHA256, it is SUF-CMA;
   KDF256, KDF128 are PRFs, even when they share the same key as the MAC *)

param qMAC, qVer, qKDF256, qKDF128, qColl.
fun MAC2(mac_key, bitstring): t_SHA256_out.

equiv
  ! N new k: mac_key; (
    ! qMAC O_mac(m: bitstring) := return(MAC(k, m)) |
    ! qVer O_Ver(mv: bitstring, mac: t_SHA256_out) := return(mac = MAC(k, mv)) |
    ! qKDF256 O_KDF256(X2: t_SHA256_out, U2: t_id, V2: t_id) := return(KDF256(k, X2, U2, V2)) |
    ! qKDF128 O_KDF128(X3: t_SHA256_out, U3: t_id, V3: t_id) := return(KDF128(k, X3, U3, V3)))
<=(N * (4 * qVer / |t_SHA256_out| + 
PPRF(time + (N-1)*(qMAC * time(MAC, maxlength(m)) + qVer * time(MAC, maxlength(mv)) + qKDF256 * time(KDF256) + qKDF128 * time(KDF128)), qMAC + qVer, max(maxlength(m), maxlength(mv)), qKDF256, qKDF128) +
PPRF(time + (N-1)*(qMAC * time(MAC, maxlength(m)) + qVer * time(MAC, maxlength(mv)) + qKDF256 * time(KDF256) + qKDF128 * time(KDF128)), qMAC + qVer, max(maxlength(m), maxlength(mv)), 0, 0)))=>
  ! N new k: mac_key; (
    ! qMAC O_mac(m: bitstring) := return(MAC2(k, m)) |
    ! qVer O_Ver(mv: bitstring, mac: t_SHA256_out) := find j <= qMAC suchthat defined(m[j]) && mv = m[j] && mac = MAC2(k, mv) then return(true) else return(false) |
    ! qKDF256 O_KDF256(X2: t_SHA256_out, U2: t_id, V2: t_id) := find [unique] j2 <= qKDF256 suchthat defined(X2[j2], U2[j2], V2[j2], r2[j2]) && X2 = X2[j2] && U2 = U2[j2] && V2 = V2[j2] then return(r2[j2]) else new r2: mac_key; return(r2) |
    ! qKDF128 O_KDF128(X3: t_SHA256_out, U3: t_id, V3: t_id) := find [unique] j3 <= qKDF128 suchthat defined(X3[j3], U3[j3], V3[j3], r3[j3]) && X3 = X3[j3] && U3 = U3[j3] && V3 = V3[j3] then return(r3[j3]) else new r3: enc_key; return(r3)).

(* MAC is HMAC_SHA256, it is collision resistant *)

equiv
  ! N new k: mac_key; (
    ! qMAC O_mac(m: bitstring) := return(MAC2(k, m)) |
    ! qColl O_coll(m1: bitstring, m2: bitstring) [useful_change] := return(MAC2(k, m1) = MAC2(k, m2)))
<=((6 * qColl + 2 * qColl * qColl + 2 * qMAC * qColl + 0.5 * qMAC * qMAC) / |t_SHA256_out| + 
   2 * PPRF(time, qMAC + 2 * qColl, max(maxlength(m), maxlength(m2), maxlength(m1)), 0, 0))=>
  ! N new k: mac_key; (
    ! qMAC O_mac(m: bitstring) := return(MAC2(k, m)) |
    ! qColl O_coll(m1: bitstring, m2: bitstring) := return(m1 = m2)).
	

(* Time *)

type t_AMS_Time [fixed].

fun check_time(t_AMS_Time, t_AMS_Time): bool.
     (* check_time(tU, tV) is supposed to check that 
     	tV - 60 seconds <= tU <= tV + 120 seconds. *)

(* Supplementary address type *)

type t_AMS_SuppAddr.

(* Session identifiers *)

type t_SID [fixed]. (* 3 bits *)
const SID0, SID1, SID2, SID3, SID4, SID5: t_SID.

(* Building AMS messages *)

type t_AMS_IMI. (* empty or "PM1." *)
type t_AMS_ID.

(* t_AMS_SuppAddr has variable length, but starts with / and ends with .
   so it can be distinguished from the PID, and its length can be determined. *)
fun buildAMS_id1(t_AMS_SuppAddr, t_AMS_IMI, t_AMS_PID): t_AMS_ID [data].
fun buildAMS_id2(t_AMS_PID): t_AMS_ID [data].

type t_AMS_Header. (* 2 bytes = 16 bits *)

fun buildAMS_Header(bool (*R1 parameter, ignored*), t_AMS_Policy, t_encode_algo, t_SID, t_comp_algo, t_Cmd): t_AMS_Header [data].

fun buildAMS_msg_prefix_Init(t_AMS_ID, t_AMS_Header, bitstring, t_AMS_AlgID, t_AMS_Time): bitstring [data].
fun buildAMS_msg_prefix_Rest(t_AMS_ID, t_AMS_Header, bitstring, t_Count): bitstring [data].
fun buildAMS_RSP(bitstring, t_AMS_AlgID, t_AMS_Time, t_Rand32): bitstring [data].

fun buildMAC_arg(t_id, t_id, bitstring): bitstring [data].
fun build_msg_Init(bitstring, t_SHA256_out): bitstring [data].
fun buildAMS_appendix_Init(t_AMS_AlgID, t_AMS_Time, t_SHA256_out): bitstring [data].
fun concat(bitstring, bitstring): bitstring. (* concatenation; it is NOT compos, because the
    		      		  	     	lengths of the two concatenated bitstrings is not known. *)
fun split_message(t_MAClen, bitstring): bitstring.
    			    		(* split_message(l, m) returns a pair (m1, m2) such that
					   m is the concatenation of m1 and m2, and m2 has length l.
					   In this protocol, m2 is the MAC, m1 is the rest of the message. *)

(* Tables of message counters
   We simulate a distinct table for each session by
   adding a unique session identifier as first argument. *)

table received_count_table(session_ids, t_Count).
table sent_count_table(session_ids, t_Count).

(**** Security properties ****)

(* Authenticity of the payload messages, when the policy is not NONE *)

event send_msg(t_id, t_id, t_AMS_Time, t_Rand32, t_policy_id, t_AMS_Policy, t_EncAlgo, t_Count, bitstring).
event recv_msg(t_id, t_id, t_AMS_Time, t_Rand32, t_policy_id, t_AMS_Policy, t_EncAlgo, t_Count, bitstring).

query msg: bitstring, count: t_Count, enc: t_EncAlgo, policy: t_AMS_Policy, policy_id: t_policy_id, randV: t_Rand32, tU: t_AMS_Time, y: t_id, x: t_id;
  event(recv_msg(x, y, tU, randV, policy_id, policy, enc, count, msg)) ==> ((policy = get_policy(policy_id, msg)) && (event(send_msg(y, x, tU, randV, policy_id, policy, enc, count, msg)) || (policy = NONE))).

(* Freshness of the AMS_Init_REQ message *)

event send_Init_REQ(bitstring, t_AMS_Time).
event recv_Init_REQ(bitstring, t_AMS_Time, t_AMS_Time).

query tV: t_AMS_Time, tU: t_AMS_Time, x: bitstring;
  event(recv_Init_REQ(x, tU, tV)) ==> (check_time(tU, tV) && event(send_Init_REQ(x, tU))).

(* Freshness of the AMS_Init_IND message (ground-initiated trigger) *)

event send_Init_IND(bitstring, t_AMS_Time).
event recv_Init_IND(bitstring, t_AMS_Time, t_AMS_Time).

query tU: t_AMS_Time, tV: t_AMS_Time, x: bitstring;
  event(recv_Init_IND(x, tV, tU)) ==> (check_time(tV, tU) && event(send_Init_IND(x, tV))).

(* Secrecy -- see arinc823-secret-key.SECRECY.ENC_SUPPORTED.cv *)

(**** The protocol ****)

param Naircraft, Nground, Nground_init, Nground_init_react, Nmessage.
channel c_gen1, c_gen2, c_aircraft0, c_aircraft0', c_aircraft1, c_aircraft2, c_aircraft3, c_aircraft4, 
	c_ground1, c_ground2, c_ground_initiated_trigger1, c_ground_initiated_trigger2,
	c_aircraft_react_ground_initiated_trigger1, c_aircraft_react_ground_initiated_trigger2,
	choicechannel, pub.

(* The process tunnel_protocol models the secure session data exchange
   (Attachment 8, Section 8.3) *)



(* Secure session initiation, aircraft-initiated (Attachement 8, Section 8.2.1) *)


    (*tunnel_protocol(ams_pid2, common_comp_algo_id, policy_id,
      KMAC_UV, KENC_UV, MAClen, common_enc_algo, sid, CstDN, CstUP, U, V)*)

 

 (* tunnel_protocol(ams_pid2, common_comp_algo_id, policy_id,
      KMAC_UV, KENC_UV, MAClen, common_enc_algo, sid, CstUP, CstDN, V, U)*)

(* Ground-initiated trigger (Attachment 8, Section 8.2.2). *)




    (* We let the adversary schedule the aircraft;
       no need to put it explicitly here. *)


(* Putting the whole system together *)

process 
	in(c_gen1, ());
new K_UV: mac_key;
new hk: hash_key;
out(c_gen2, hk);
((
  ! i_1 <= Naircraft
  ((
    in(c_aircraft0[i_1], ());
    let MAClen: t_MAClen = MAClen32 in
    out(c_aircraft0'[i_1], ());
    in(c_aircraft1[i_1], (software_part_number_1: t_software_part_number, policy_id_1: t_policy_id, algo_bits_1: t_algo_bits, encode_alg_1: t_encode_algo, ams_dstaddr_1: t_AMS_SuppAddr, ams_imi_1: t_AMS_IMI, sid_1: t_SID, tU_1: t_AMS_Time));
    new current_session_id_1: session_ids;
    let s_init_info: t_AMS_elem = buildAMS10_s_init_info(software_part_number_1, policy_id_1, U, V) in
    let comp_algo_id: t_AMS_elem = buildAMS41_comp_algo_id(algo_bits_1) in
    let ams_payload: bitstring = concat_AMS_element(s_init_info, payload_with_1_element(comp_algo_id)) in
    let encoded_payload: bitstring = encode(encode_alg_1, ams_payload) in
    let ams_id: t_AMS_ID = buildAMS_id1(ams_dstaddr_1, ams_imi_1, ams_pid2) in
    let ams_header: t_AMS_Header = buildAMS_Header(false, AUTH, encode_alg_1, sid_1, comp_OFF, Init_REQ) in
    let alg_ID_U: t_AMS_AlgID = algo(MAClen, HMAC_SHA256, AES128_CFB128) in
    let AMS_Init_REQ_prefix: bitstring = buildAMS_msg_prefix_Init(ams_id, ams_header, encoded_payload, alg_ID_U, tU_1) in
    let TBP_AMS_Init_REQ: bitstring = buildMAC_arg(U, V, AMS_Init_REQ_prefix) in
    let MAC0_U: t_SHA256_out = MAC(K_UV, TBP_AMS_Init_REQ) in
    let AMS_Appendix: bitstring = buildAMS_appendix_Init(alg_ID_U, tU_1, MAC0_U) in
    let AMS_Init_REQ: bitstring = build_msg_Init(AMS_Init_REQ_prefix, MAC0_U) in
    event send_Init_REQ(AMS_Init_REQ, tU_1);
    out(c_aircraft2[i_1], AMS_Init_REQ);
    in(c_aircraft3[i_1], AMS_Init_RSP_1: bitstring);
    let (AMS_Init_RSP_prefix_1: bitstring, mac2_2: bitstring) = split_message(MAClen, AMS_Init_RSP_1) in
    let buildAMS_msg_prefix_Rest(ams_id2: t_AMS_ID, ams_header2: t_AMS_Header, buildAMS_RSP(compressed_payload2: bitstring, AlgSel: t_AMS_AlgID, =tU_1, RandV: t_Rand32), MsgCount: t_Count) = AMS_Init_RSP_prefix_1 in
    let buildAMS_Header(R1: bool, =AUTH, encode_alg2: t_encode_algo, sid2: t_SID, compression2: t_comp_algo, cmd2: t_Cmd) = ams_header2 in
    let encoded_payload2: bitstring = decompress(compression2, compressed_payload2) in
    let AMS_payload2: bitstring = decode(encode_alg2, encoded_payload2) in
    let concat_AMS_element(common_comp_algo_id: t_AMS_elem, app_data2: bitstring) = AMS_payload2 in
    let X_UV: t_SHA256_out = HASH(hk, concat_hash(AMS_Appendix, RandV)) in
    let algo(MAClen': t_MAClen, =HMAC_SHA256, common_enc_algo: t_EncAlgo) = AlgSel in
    let KMAC_UV: mac_key = KDF256(K_UV, X_UV, U, V) in
    let KENC_UV: enc_key = KDF128(K_UV, X_UV, U, V) in
    let TBP_AMS_Init_RSP: bitstring = buildMAC_arg(V, U, AMS_Init_RSP_prefix_1) in
    if MsgCount = Count1 then
    if mac2_2 = sessionMAC(MAClen, KMAC_UV, TBP_AMS_Init_RSP) then
    if cmd2 = Init_RSP_Plus then
    insert received_count_table(current_session_id_1, Count1);
    let ams_pid: t_AMS_PID = ams_pid2 in
    let dir_send: byte = CstDN in
    let dir_recv: byte = CstUP in
    let my_id: t_id = U in
    let other_id: t_id = V in
    out(c_aircraft4[i_1], ());
    ((
      ! i_9 <= Nmessage
      in(choicechannel[i_9, i_1], (AMS_payload_1: bitstring, encode_alg_2: t_encode_algo, comp_algo_1: t_comp_algo, ams_dstaddr_2: t_AMS_SuppAddr, ams_imi_2: t_AMS_IMI, count_1: t_Count, cmd_1: t_Cmd));
      get sent_count_table(=current_session_id_1, =count_1) in
        yield
      else
        let policy_req: t_AMS_Policy = get_policy(policy_id_1, AMS_payload_1) in
        event send_msg(my_id, other_id, tU_1, RandV, policy_id_1, policy_req, common_enc_algo, count_1, AMS_payload_1);
        if policy_req = NONE then
          out(pub[i_9, i_1], AMS_payload_1)
        else
          let encoded_payload_1: bitstring = encode(encode_alg_2, AMS_payload_1) in
          let actual_comp_algo: t_comp_algo = select_common_compression(common_comp_algo_id, comp_algo_1) in
          let compressed_payload: bitstring = compress(actual_comp_algo, encoded_payload_1) in
          insert sent_count_table(current_session_id_1, count_1);
          let protect_mode: t_AMS_Policy = (let policy: t_AMS_Policy = policy_req in (let enc_algo: t_EncAlgo = common_enc_algo in if (enc_algo = NULL_enc) && (policy = BOTH) then AUTH else policy)) in
          let encrypted_AMS_payload: bitstring = (if protect_mode = AUTH then compressed_payload else E'(KENC_UV, buildIVdata(dir_send, count_1), compressed_payload)) in
          let ams_id_1: t_AMS_ID = buildAMS_id1(ams_dstaddr_2, ams_imi_2, ams_pid) in
          let ams_header_1: t_AMS_Header = buildAMS_Header(false, protect_mode, encode_alg_2, sid_1, actual_comp_algo, cmd_1) in
          let AMS_Data_IND_prefix: bitstring = buildAMS_msg_prefix_Rest(ams_id_1, ams_header_1, encrypted_AMS_payload, count_1) in
          let TBP_AMS_Data_IND: bitstring = buildMAC_arg(my_id, other_id, AMS_Data_IND_prefix) in
          let mac_1: bitstring = sessionMAC(MAClen, KMAC_UV, TBP_AMS_Data_IND) in
          let AMS_Data_IND: bitstring = concat(AMS_Data_IND_prefix, mac_1) in
          out(pub[i_9, i_1], AMS_Data_IND)
    ) | (
      ! i_10 <= Nmessage
      in(pub[i_10, i_1], (clear_1: bool, AMS_Data_IND_1: bitstring));
      if clear_1 then
      (
        if get_policy(policy_id_1, AMS_Data_IND_1) = NONE then
        event recv_msg(my_id, other_id, tU_1, RandV, policy_id_1, NONE, common_enc_algo, Count_unspecified, AMS_Data_IND_1)
      )
      else
        let (AMS_Data_IND_prefix_1: bitstring, mac_2: bitstring) = split_message(MAClen, AMS_Data_IND_1) in
        let TBP_AMS_Data_IND_1: bitstring = buildMAC_arg(other_id, my_id, AMS_Data_IND_prefix_1) in
        if mac_2 = sessionMAC(MAClen, KMAC_UV, TBP_AMS_Data_IND_1) then
        let buildAMS_msg_prefix_Rest(ams_id_2: t_AMS_ID, ams_header_2: t_AMS_Header, encrypted_AMS_payload_1: bitstring, MsgCount_1: t_Count) = AMS_Data_IND_prefix_1 in
        let buildAMS_Header(R1_1: bool, protect_mode_1: t_AMS_Policy, encode_alg_3: t_encode_algo, sid_2: t_SID, compression: t_comp_algo, cmd_2: t_Cmd) = ams_header_2 in
        get received_count_table(=current_session_id_1, =MsgCount_1) in
          yield
        else
          insert received_count_table(current_session_id_1, MsgCount_1);
          let compressed_payload_1: bitstring = (if protect_mode_1 = AUTH then encrypted_AMS_payload_1 else D'(KENC_UV, buildIVdata(dir_recv, MsgCount_1), encrypted_AMS_payload_1)) in
          let encoded_payload_2: bitstring = decompress(compression, compressed_payload_1) in
          let AMS_payload_2: bitstring = decode(encode_alg_3, encoded_payload_2) in
          let policy_req_1: t_AMS_Policy = get_policy(policy_id_1, AMS_payload_2) in
          if protect_mode_1 = (let policy_1: t_AMS_Policy = policy_req_1 in (let enc_algo_1: t_EncAlgo = common_enc_algo in if (enc_algo_1 = NULL_enc) && (policy_1 = BOTH) then AUTH else policy_1)) then
          event recv_msg(my_id, other_id, tU_1, RandV, policy_id_1, policy_req_1, common_enc_algo, MsgCount_1, AMS_payload_2)
    ))
  ) | (
    in(c_aircraft0[i_1], ());
    let MAClen_1: t_MAClen = MAClen64 in
    out(c_aircraft0'[i_1], ());
    in(c_aircraft1[i_1], (software_part_number_2: t_software_part_number, policy_id_2: t_policy_id, algo_bits_2: t_algo_bits, encode_alg_4: t_encode_algo, ams_dstaddr_3: t_AMS_SuppAddr, ams_imi_3: t_AMS_IMI, sid_3: t_SID, tU_2: t_AMS_Time));
    new current_session_id_2: session_ids;
    let s_init_info_1: t_AMS_elem = buildAMS10_s_init_info(software_part_number_2, policy_id_2, U, V) in
    let comp_algo_id_1: t_AMS_elem = buildAMS41_comp_algo_id(algo_bits_2) in
    let ams_payload_1: bitstring = concat_AMS_element(s_init_info_1, payload_with_1_element(comp_algo_id_1)) in
    let encoded_payload_3: bitstring = encode(encode_alg_4, ams_payload_1) in
    let ams_id_3: t_AMS_ID = buildAMS_id1(ams_dstaddr_3, ams_imi_3, ams_pid2) in
    let ams_header_3: t_AMS_Header = buildAMS_Header(false, AUTH, encode_alg_4, sid_3, comp_OFF, Init_REQ) in
    let alg_ID_U_1: t_AMS_AlgID = algo(MAClen_1, HMAC_SHA256, AES128_CFB128) in
    let AMS_Init_REQ_prefix_1: bitstring = buildAMS_msg_prefix_Init(ams_id_3, ams_header_3, encoded_payload_3, alg_ID_U_1, tU_2) in
    let TBP_AMS_Init_REQ_1: bitstring = buildMAC_arg(U, V, AMS_Init_REQ_prefix_1) in
    let MAC0_U_1: t_SHA256_out = MAC(K_UV, TBP_AMS_Init_REQ_1) in
    let AMS_Appendix_1: bitstring = buildAMS_appendix_Init(alg_ID_U_1, tU_2, MAC0_U_1) in
    let AMS_Init_REQ_1: bitstring = build_msg_Init(AMS_Init_REQ_prefix_1, MAC0_U_1) in
    event send_Init_REQ(AMS_Init_REQ_1, tU_2);
    out(c_aircraft2[i_1], AMS_Init_REQ_1);
    in(c_aircraft3[i_1], AMS_Init_RSP_2: bitstring);
    let (AMS_Init_RSP_prefix_2: bitstring, mac2_3: bitstring) = split_message(MAClen_1, AMS_Init_RSP_2) in
    let buildAMS_msg_prefix_Rest(ams_id2_1: t_AMS_ID, ams_header2_1: t_AMS_Header, buildAMS_RSP(compressed_payload2_1: bitstring, AlgSel_1: t_AMS_AlgID, =tU_2, RandV_1: t_Rand32), MsgCount_2: t_Count) = AMS_Init_RSP_prefix_2 in
    let buildAMS_Header(R1_2: bool, =AUTH, encode_alg2_1: t_encode_algo, sid2_1: t_SID, compression2_1: t_comp_algo, cmd2_1: t_Cmd) = ams_header2_1 in
    let encoded_payload2_1: bitstring = decompress(compression2_1, compressed_payload2_1) in
    let AMS_payload2_1: bitstring = decode(encode_alg2_1, encoded_payload2_1) in
    let concat_AMS_element(common_comp_algo_id_1: t_AMS_elem, app_data2_1: bitstring) = AMS_payload2_1 in
    let X_UV_1: t_SHA256_out = HASH(hk, concat_hash(AMS_Appendix_1, RandV_1)) in
    let algo(MAClen'_1: t_MAClen, =HMAC_SHA256, common_enc_algo_1: t_EncAlgo) = AlgSel_1 in
    let KMAC_UV_1: mac_key = KDF256(K_UV, X_UV_1, U, V) in
    let KENC_UV_1: enc_key = KDF128(K_UV, X_UV_1, U, V) in
    let TBP_AMS_Init_RSP_1: bitstring = buildMAC_arg(V, U, AMS_Init_RSP_prefix_2) in
    if MsgCount_2 = Count1 then
    if mac2_3 = sessionMAC(MAClen_1, KMAC_UV_1, TBP_AMS_Init_RSP_1) then
    if cmd2_1 = Init_RSP_Plus then
    insert received_count_table(current_session_id_2, Count1);
    let ams_pid_1: t_AMS_PID = ams_pid2 in
    let dir_send_1: byte = CstDN in
    let dir_recv_1: byte = CstUP in
    let my_id_1: t_id = U in
    let other_id_1: t_id = V in
    out(c_aircraft4[i_1], ());
    ((
      ! i_9 <= Nmessage
      in(choicechannel[i_9, i_1], (AMS_payload_3: bitstring, encode_alg_5: t_encode_algo, comp_algo_2: t_comp_algo, ams_dstaddr_4: t_AMS_SuppAddr, ams_imi_4: t_AMS_IMI, count_2: t_Count, cmd_3: t_Cmd));
      get sent_count_table(=current_session_id_2, =count_2) in
        yield
      else
        let policy_req_2: t_AMS_Policy = get_policy(policy_id_2, AMS_payload_3) in
        event send_msg(my_id_1, other_id_1, tU_2, RandV_1, policy_id_2, policy_req_2, common_enc_algo_1, count_2, AMS_payload_3);
        if policy_req_2 = NONE then
          out(pub[i_9, i_1], AMS_payload_3)
        else
          let encoded_payload_4: bitstring = encode(encode_alg_5, AMS_payload_3) in
          let actual_comp_algo_1: t_comp_algo = select_common_compression(common_comp_algo_id_1, comp_algo_2) in
          let compressed_payload_2: bitstring = compress(actual_comp_algo_1, encoded_payload_4) in
          insert sent_count_table(current_session_id_2, count_2);
          let protect_mode_2: t_AMS_Policy = (let policy_2: t_AMS_Policy = policy_req_2 in (let enc_algo_2: t_EncAlgo = common_enc_algo_1 in if (enc_algo_2 = NULL_enc) && (policy_2 = BOTH) then AUTH else policy_2)) in
          let encrypted_AMS_payload_2: bitstring = (if protect_mode_2 = AUTH then compressed_payload_2 else E'(KENC_UV_1, buildIVdata(dir_send_1, count_2), compressed_payload_2)) in
          let ams_id_4: t_AMS_ID = buildAMS_id1(ams_dstaddr_4, ams_imi_4, ams_pid_1) in
          let ams_header_4: t_AMS_Header = buildAMS_Header(false, protect_mode_2, encode_alg_5, sid_3, actual_comp_algo_1, cmd_3) in
          let AMS_Data_IND_prefix_2: bitstring = buildAMS_msg_prefix_Rest(ams_id_4, ams_header_4, encrypted_AMS_payload_2, count_2) in
          let TBP_AMS_Data_IND_2: bitstring = buildMAC_arg(my_id_1, other_id_1, AMS_Data_IND_prefix_2) in
          let mac_3: bitstring = sessionMAC(MAClen_1, KMAC_UV_1, TBP_AMS_Data_IND_2) in
          let AMS_Data_IND_2: bitstring = concat(AMS_Data_IND_prefix_2, mac_3) in
          out(pub[i_9, i_1], AMS_Data_IND_2)
    ) | (
      ! i_10 <= Nmessage
      in(pub[i_10, i_1], (clear_2: bool, AMS_Data_IND_3: bitstring));
      if clear_2 then
      (
        if get_policy(policy_id_2, AMS_Data_IND_3) = NONE then
        event recv_msg(my_id_1, other_id_1, tU_2, RandV_1, policy_id_2, NONE, common_enc_algo_1, Count_unspecified, AMS_Data_IND_3)
      )
      else
        let (AMS_Data_IND_prefix_3: bitstring, mac_4: bitstring) = split_message(MAClen_1, AMS_Data_IND_3) in
        let TBP_AMS_Data_IND_3: bitstring = buildMAC_arg(other_id_1, my_id_1, AMS_Data_IND_prefix_3) in
        if mac_4 = sessionMAC(MAClen_1, KMAC_UV_1, TBP_AMS_Data_IND_3) then
        let buildAMS_msg_prefix_Rest(ams_id_5: t_AMS_ID, ams_header_5: t_AMS_Header, encrypted_AMS_payload_3: bitstring, MsgCount_3: t_Count) = AMS_Data_IND_prefix_3 in
        let buildAMS_Header(R1_3: bool, protect_mode_3: t_AMS_Policy, encode_alg_6: t_encode_algo, sid_4: t_SID, compression_1: t_comp_algo, cmd_4: t_Cmd) = ams_header_5 in
        get received_count_table(=current_session_id_2, =MsgCount_3) in
          yield
        else
          insert received_count_table(current_session_id_2, MsgCount_3);
          let compressed_payload_3: bitstring = (if protect_mode_3 = AUTH then encrypted_AMS_payload_3 else D'(KENC_UV_1, buildIVdata(dir_recv_1, MsgCount_3), encrypted_AMS_payload_3)) in
          let encoded_payload_5: bitstring = decompress(compression_1, compressed_payload_3) in
          let AMS_payload_4: bitstring = decode(encode_alg_6, encoded_payload_5) in
          let policy_req_3: t_AMS_Policy = get_policy(policy_id_2, AMS_payload_4) in
          if protect_mode_3 = (let policy_3: t_AMS_Policy = policy_req_3 in (let enc_algo_3: t_EncAlgo = common_enc_algo_1 in if (enc_algo_3 = NULL_enc) && (policy_3 = BOTH) then AUTH else policy_3)) then
          event recv_msg(my_id_1, other_id_1, tU_2, RandV_1, policy_id_2, policy_req_3, common_enc_algo_1, MsgCount_3, AMS_payload_4)
    ))
  ) | (
    in(c_aircraft0[i_1], ());
    let MAClen_2: t_MAClen = MAClen128 in
    out(c_aircraft0'[i_1], ());
    in(c_aircraft1[i_1], (software_part_number_3: t_software_part_number, policy_id_3: t_policy_id, algo_bits_3: t_algo_bits, encode_alg_7: t_encode_algo, ams_dstaddr_5: t_AMS_SuppAddr, ams_imi_5: t_AMS_IMI, sid_5: t_SID, tU_3: t_AMS_Time));
    new current_session_id_3: session_ids;
    let s_init_info_2: t_AMS_elem = buildAMS10_s_init_info(software_part_number_3, policy_id_3, U, V) in
    let comp_algo_id_2: t_AMS_elem = buildAMS41_comp_algo_id(algo_bits_3) in
    let ams_payload_2: bitstring = concat_AMS_element(s_init_info_2, payload_with_1_element(comp_algo_id_2)) in
    let encoded_payload_6: bitstring = encode(encode_alg_7, ams_payload_2) in
    let ams_id_6: t_AMS_ID = buildAMS_id1(ams_dstaddr_5, ams_imi_5, ams_pid2) in
    let ams_header_6: t_AMS_Header = buildAMS_Header(false, AUTH, encode_alg_7, sid_5, comp_OFF, Init_REQ) in
    let alg_ID_U_2: t_AMS_AlgID = algo(MAClen_2, HMAC_SHA256, AES128_CFB128) in
    let AMS_Init_REQ_prefix_2: bitstring = buildAMS_msg_prefix_Init(ams_id_6, ams_header_6, encoded_payload_6, alg_ID_U_2, tU_3) in
    let TBP_AMS_Init_REQ_2: bitstring = buildMAC_arg(U, V, AMS_Init_REQ_prefix_2) in
    let MAC0_U_2: t_SHA256_out = MAC(K_UV, TBP_AMS_Init_REQ_2) in
    let AMS_Appendix_2: bitstring = buildAMS_appendix_Init(alg_ID_U_2, tU_3, MAC0_U_2) in
    let AMS_Init_REQ_2: bitstring = build_msg_Init(AMS_Init_REQ_prefix_2, MAC0_U_2) in
    event send_Init_REQ(AMS_Init_REQ_2, tU_3);
    out(c_aircraft2[i_1], AMS_Init_REQ_2);
    in(c_aircraft3[i_1], AMS_Init_RSP_3: bitstring);
    let (AMS_Init_RSP_prefix_3: bitstring, mac2_4: bitstring) = split_message(MAClen_2, AMS_Init_RSP_3) in
    let buildAMS_msg_prefix_Rest(ams_id2_2: t_AMS_ID, ams_header2_2: t_AMS_Header, buildAMS_RSP(compressed_payload2_2: bitstring, AlgSel_2: t_AMS_AlgID, =tU_3, RandV_2: t_Rand32), MsgCount_4: t_Count) = AMS_Init_RSP_prefix_3 in
    let buildAMS_Header(R1_4: bool, =AUTH, encode_alg2_2: t_encode_algo, sid2_2: t_SID, compression2_2: t_comp_algo, cmd2_2: t_Cmd) = ams_header2_2 in
    let encoded_payload2_2: bitstring = decompress(compression2_2, compressed_payload2_2) in
    let AMS_payload2_2: bitstring = decode(encode_alg2_2, encoded_payload2_2) in
    let concat_AMS_element(common_comp_algo_id_2: t_AMS_elem, app_data2_2: bitstring) = AMS_payload2_2 in
    let X_UV_2: t_SHA256_out = HASH(hk, concat_hash(AMS_Appendix_2, RandV_2)) in
    let algo(MAClen'_2: t_MAClen, =HMAC_SHA256, common_enc_algo_2: t_EncAlgo) = AlgSel_2 in
    let KMAC_UV_2: mac_key = KDF256(K_UV, X_UV_2, U, V) in
    let KENC_UV_2: enc_key = KDF128(K_UV, X_UV_2, U, V) in
    let TBP_AMS_Init_RSP_2: bitstring = buildMAC_arg(V, U, AMS_Init_RSP_prefix_3) in
    if MsgCount_4 = Count1 then
    if mac2_4 = sessionMAC(MAClen_2, KMAC_UV_2, TBP_AMS_Init_RSP_2) then
    if cmd2_2 = Init_RSP_Plus then
    insert received_count_table(current_session_id_3, Count1);
    let ams_pid_2: t_AMS_PID = ams_pid2 in
    let dir_send_2: byte = CstDN in
    let dir_recv_2: byte = CstUP in
    let my_id_2: t_id = U in
    let other_id_2: t_id = V in
    out(c_aircraft4[i_1], ());
    ((
      ! i_9 <= Nmessage
      in(choicechannel[i_9, i_1], (AMS_payload_5: bitstring, encode_alg_8: t_encode_algo, comp_algo_3: t_comp_algo, ams_dstaddr_6: t_AMS_SuppAddr, ams_imi_6: t_AMS_IMI, count_3: t_Count, cmd_5: t_Cmd));
      get sent_count_table(=current_session_id_3, =count_3) in
        yield
      else
        let policy_req_4: t_AMS_Policy = get_policy(policy_id_3, AMS_payload_5) in
        event send_msg(my_id_2, other_id_2, tU_3, RandV_2, policy_id_3, policy_req_4, common_enc_algo_2, count_3, AMS_payload_5);
        if policy_req_4 = NONE then
          out(pub[i_9, i_1], AMS_payload_5)
        else
          let encoded_payload_7: bitstring = encode(encode_alg_8, AMS_payload_5) in
          let actual_comp_algo_2: t_comp_algo = select_common_compression(common_comp_algo_id_2, comp_algo_3) in
          let compressed_payload_4: bitstring = compress(actual_comp_algo_2, encoded_payload_7) in
          insert sent_count_table(current_session_id_3, count_3);
          let protect_mode_4: t_AMS_Policy = (let policy_4: t_AMS_Policy = policy_req_4 in (let enc_algo_4: t_EncAlgo = common_enc_algo_2 in if (enc_algo_4 = NULL_enc) && (policy_4 = BOTH) then AUTH else policy_4)) in
          let encrypted_AMS_payload_4: bitstring = (if protect_mode_4 = AUTH then compressed_payload_4 else E'(KENC_UV_2, buildIVdata(dir_send_2, count_3), compressed_payload_4)) in
          let ams_id_7: t_AMS_ID = buildAMS_id1(ams_dstaddr_6, ams_imi_6, ams_pid_2) in
          let ams_header_7: t_AMS_Header = buildAMS_Header(false, protect_mode_4, encode_alg_8, sid_5, actual_comp_algo_2, cmd_5) in
          let AMS_Data_IND_prefix_4: bitstring = buildAMS_msg_prefix_Rest(ams_id_7, ams_header_7, encrypted_AMS_payload_4, count_3) in
          let TBP_AMS_Data_IND_4: bitstring = buildMAC_arg(my_id_2, other_id_2, AMS_Data_IND_prefix_4) in
          let mac_5: bitstring = sessionMAC(MAClen_2, KMAC_UV_2, TBP_AMS_Data_IND_4) in
          let AMS_Data_IND_4: bitstring = concat(AMS_Data_IND_prefix_4, mac_5) in
          out(pub[i_9, i_1], AMS_Data_IND_4)
    ) | (
      ! i_10 <= Nmessage
      in(pub[i_10, i_1], (clear_3: bool, AMS_Data_IND_5: bitstring));
      if clear_3 then
      (
        if get_policy(policy_id_3, AMS_Data_IND_5) = NONE then
        event recv_msg(my_id_2, other_id_2, tU_3, RandV_2, policy_id_3, NONE, common_enc_algo_2, Count_unspecified, AMS_Data_IND_5)
      )
      else
        let (AMS_Data_IND_prefix_5: bitstring, mac_6: bitstring) = split_message(MAClen_2, AMS_Data_IND_5) in
        let TBP_AMS_Data_IND_5: bitstring = buildMAC_arg(other_id_2, my_id_2, AMS_Data_IND_prefix_5) in
        if mac_6 = sessionMAC(MAClen_2, KMAC_UV_2, TBP_AMS_Data_IND_5) then
        let buildAMS_msg_prefix_Rest(ams_id_8: t_AMS_ID, ams_header_8: t_AMS_Header, encrypted_AMS_payload_5: bitstring, MsgCount_5: t_Count) = AMS_Data_IND_prefix_5 in
        let buildAMS_Header(R1_5: bool, protect_mode_5: t_AMS_Policy, encode_alg_9: t_encode_algo, sid_6: t_SID, compression_2: t_comp_algo, cmd_6: t_Cmd) = ams_header_8 in
        get received_count_table(=current_session_id_3, =MsgCount_5) in
          yield
        else
          insert received_count_table(current_session_id_3, MsgCount_5);
          let compressed_payload_5: bitstring = (if protect_mode_5 = AUTH then encrypted_AMS_payload_5 else D'(KENC_UV_2, buildIVdata(dir_recv_2, MsgCount_5), encrypted_AMS_payload_5)) in
          let encoded_payload_8: bitstring = decompress(compression_2, compressed_payload_5) in
          let AMS_payload_6: bitstring = decode(encode_alg_9, encoded_payload_8) in
          let policy_req_5: t_AMS_Policy = get_policy(policy_id_3, AMS_payload_6) in
          if protect_mode_5 = (let policy_5: t_AMS_Policy = policy_req_5 in (let enc_algo_5: t_EncAlgo = common_enc_algo_2 in if (enc_algo_5 = NULL_enc) && (policy_5 = BOTH) then AUTH else policy_5)) then
          event recv_msg(my_id_2, other_id_2, tU_3, RandV_2, policy_id_3, policy_req_5, common_enc_algo_2, MsgCount_5, AMS_payload_6)
    ))
  ))
) | (
  ! i_8 <= Nground
  in(c_ground1[i_8], (gd_algo_bits: t_algo_bits, tV_1: t_AMS_Time, app_data: bitstring, encode_alg_10: t_encode_algo, comp_algo_4: t_comp_algo, AMS_Init_REQ_3: bitstring));
  new current_session_id_4: session_ids;
  let build_msg_Init(AMS_Init_REQ_prefix_3: bitstring, MAC0_U_3: t_SHA256_out) = AMS_Init_REQ_3 in
  let TBP_AMS_Init_REQ_3: bitstring = buildMAC_arg(U, V, AMS_Init_REQ_prefix_3) in
  if MAC0_U_3 = MAC(K_UV, TBP_AMS_Init_REQ_3) then
  let buildAMS_msg_prefix_Init(ams_id_9: t_AMS_ID, ams_header_9: t_AMS_Header, encoded_payload_9: bitstring, alg_ID_U_3: t_AMS_AlgID, tU_4: t_AMS_Time) = AMS_Init_REQ_prefix_3 in
  let AMS_Appendix_3: bitstring = buildAMS_appendix_Init(alg_ID_U_3, tU_4, MAC0_U_3) in
  if check_time(tU_4, tV_1) then
  let buildAMS_Header(R1_6: bool, =AUTH, encode_alg_11: t_encode_algo, sid_7: t_SID, compression_3: t_comp_algo, =Init_REQ) = ams_header_9 in
  let ams_payload_3: bitstring = decode(encode_alg_11, encoded_payload_9) in
  let algo(MAClen_3: t_MAClen, =HMAC_SHA256, enc_algo_6: t_EncAlgo) = alg_ID_U_3 in
  let common_enc_algo_3: t_EncAlgo = (if enc_algo_6 = AES128_CFB128 then AES128_CFB128 else NULL_enc) in
  let concat_AMS_element(s_init_info_3: t_AMS_elem, payload_with_1_element(comp_algo_id_3: t_AMS_elem)) = ams_payload_3 in
  let buildAMS10_s_init_info(software_part_number_4: t_software_part_number, policy_id_4: t_policy_id, =U, =V) = s_init_info_3 in
  let buildAMS41_comp_algo_id(algo_bits_4: t_algo_bits) = comp_algo_id_3 in
  let gd_comp_algo_id: t_AMS_elem = buildAMS41_comp_algo_id(gd_algo_bits) in
  let common_comp_algo_id_3: t_AMS_elem = buildAMS42_comp_algo_sel(bool_and(algo_bits_4, gd_algo_bits)) in
  event recv_Init_REQ(AMS_Init_REQ_3, tU_4, tV_1);
  new RandV_3: t_Rand32;
  let X_UV_3: t_SHA256_out = HASH(hk, concat_hash(AMS_Appendix_3, RandV_3)) in
  let KMAC_UV_3: mac_key = KDF256(K_UV, X_UV_3, U, V) in
  let KENC_UV_3: enc_key = KDF128(K_UV, X_UV_3, U, V) in
  let AMS_payload_7: bitstring = concat_AMS_element(common_comp_algo_id_3, app_data) in
  let encoded_payload_10: bitstring = encode(encode_alg_11, AMS_payload_7) in
  let actual_comp_algo_3: t_comp_algo = select_common_compression(common_comp_algo_id_3, comp_algo_4) in
  let compressed_payload_6: bitstring = compress(actual_comp_algo_3, encoded_payload_10) in
  insert sent_count_table(current_session_id_4, Count1);
  let ams_id_10: t_AMS_ID = buildAMS_id2(ams_pid2) in
  let ams_header_10: t_AMS_Header = buildAMS_Header(false, AUTH, encode_alg_11, sid_7, actual_comp_algo_3, Init_RSP_Plus) in
  let AlgSel_3: t_AMS_AlgID = algo(MAClen_3, HMAC_SHA256, common_enc_algo_3) in
  let AMS_Init_RSP_prefix_4: bitstring = buildAMS_msg_prefix_Rest(ams_id_10, ams_header_10, buildAMS_RSP(compressed_payload_6, AlgSel_3, tU_4, RandV_3), Count1) in
  let TBP_AMS_Init_RSP_3: bitstring = buildMAC_arg(V, U, AMS_Init_RSP_prefix_4) in
  let mac_7: bitstring = sessionMAC(MAClen_3, KMAC_UV_3, TBP_AMS_Init_RSP_3) in
  let AMS_Init_RSP_4: bitstring = concat(AMS_Init_RSP_prefix_4, mac_7) in
  let ams_pid_3: t_AMS_PID = ams_pid2 in
  let dir_send_3: byte = CstUP in
  let dir_recv_3: byte = CstDN in
  let my_id_3: t_id = V in
  let other_id_3: t_id = U in
  out(c_ground2[i_8], AMS_Init_RSP_4);
  ((
    ! i_9 <= Nmessage
    in(choicechannel[i_9, i_8], (AMS_payload_8: bitstring, encode_alg_12: t_encode_algo, comp_algo_5: t_comp_algo, ams_dstaddr_7: t_AMS_SuppAddr, ams_imi_7: t_AMS_IMI, count_4: t_Count, cmd_7: t_Cmd));
    get sent_count_table(=current_session_id_4, =count_4) in
      yield
    else
      let policy_req_6: t_AMS_Policy = get_policy(policy_id_4, AMS_payload_8) in
      event send_msg(my_id_3, other_id_3, tU_4, RandV_3, policy_id_4, policy_req_6, common_enc_algo_3, count_4, AMS_payload_8);
      if policy_req_6 = NONE then
        out(pub[i_9, i_8], AMS_payload_8)
      else
        let encoded_payload_11: bitstring = encode(encode_alg_12, AMS_payload_8) in
        let actual_comp_algo_4: t_comp_algo = select_common_compression(common_comp_algo_id_3, comp_algo_5) in
        let compressed_payload_7: bitstring = compress(actual_comp_algo_4, encoded_payload_11) in
        insert sent_count_table(current_session_id_4, count_4);
        let protect_mode_6: t_AMS_Policy = (let policy_6: t_AMS_Policy = policy_req_6 in (let enc_algo_7: t_EncAlgo = common_enc_algo_3 in if (enc_algo_7 = NULL_enc) && (policy_6 = BOTH) then AUTH else policy_6)) in
        let encrypted_AMS_payload_6: bitstring = (if protect_mode_6 = AUTH then compressed_payload_7 else E'(KENC_UV_3, buildIVdata(dir_send_3, count_4), compressed_payload_7)) in
        let ams_id_11: t_AMS_ID = buildAMS_id1(ams_dstaddr_7, ams_imi_7, ams_pid_3) in
        let ams_header_11: t_AMS_Header = buildAMS_Header(false, protect_mode_6, encode_alg_12, sid_7, actual_comp_algo_4, cmd_7) in
        let AMS_Data_IND_prefix_6: bitstring = buildAMS_msg_prefix_Rest(ams_id_11, ams_header_11, encrypted_AMS_payload_6, count_4) in
        let TBP_AMS_Data_IND_6: bitstring = buildMAC_arg(my_id_3, other_id_3, AMS_Data_IND_prefix_6) in
        let mac_8: bitstring = sessionMAC(MAClen_3, KMAC_UV_3, TBP_AMS_Data_IND_6) in
        let AMS_Data_IND_6: bitstring = concat(AMS_Data_IND_prefix_6, mac_8) in
        out(pub[i_9, i_8], AMS_Data_IND_6)
  ) | (
    ! i_10 <= Nmessage
    in(pub[i_10, i_8], (clear_4: bool, AMS_Data_IND_7: bitstring));
    if clear_4 then
    (
      if get_policy(policy_id_4, AMS_Data_IND_7) = NONE then
      event recv_msg(my_id_3, other_id_3, tU_4, RandV_3, policy_id_4, NONE, common_enc_algo_3, Count_unspecified, AMS_Data_IND_7)
    )
    else
      let (AMS_Data_IND_prefix_7: bitstring, mac_9: bitstring) = split_message(MAClen_3, AMS_Data_IND_7) in
      let TBP_AMS_Data_IND_7: bitstring = buildMAC_arg(other_id_3, my_id_3, AMS_Data_IND_prefix_7) in
      if mac_9 = sessionMAC(MAClen_3, KMAC_UV_3, TBP_AMS_Data_IND_7) then
      let buildAMS_msg_prefix_Rest(ams_id_12: t_AMS_ID, ams_header_12: t_AMS_Header, encrypted_AMS_payload_7: bitstring, MsgCount_6: t_Count) = AMS_Data_IND_prefix_7 in
      let buildAMS_Header(R1_7: bool, protect_mode_7: t_AMS_Policy, encode_alg_13: t_encode_algo, sid_8: t_SID, compression_4: t_comp_algo, cmd_8: t_Cmd) = ams_header_12 in
      get received_count_table(=current_session_id_4, =MsgCount_6) in
        yield
      else
        insert received_count_table(current_session_id_4, MsgCount_6);
        let compressed_payload_8: bitstring = (if protect_mode_7 = AUTH then encrypted_AMS_payload_7 else D'(KENC_UV_3, buildIVdata(dir_recv_3, MsgCount_6), encrypted_AMS_payload_7)) in
        let encoded_payload_12: bitstring = decompress(compression_4, compressed_payload_8) in
        let AMS_payload_9: bitstring = decode(encode_alg_13, encoded_payload_12) in
        let policy_req_7: t_AMS_Policy = get_policy(policy_id_4, AMS_payload_9) in
        if protect_mode_7 = (let policy_7: t_AMS_Policy = policy_req_7 in (let enc_algo_8: t_EncAlgo = common_enc_algo_3 in if (enc_algo_8 = NULL_enc) && (policy_7 = BOTH) then AUTH else policy_7)) then
        event recv_msg(my_id_3, other_id_3, tU_4, RandV_3, policy_id_4, policy_req_7, common_enc_algo_3, MsgCount_6, AMS_payload_9)
  ))
) | (
  ! i_11 <= Nground_init
  in(c_ground_initiated_trigger1[i_11], (encode_alg_14: t_encode_algo, MAClen_4: t_MAClen, tV_2: t_AMS_Time));
  let ams_payload_4: bitstring = payload_with_1_element(buildAMS40_entity_id(U, V)) in
  let encoded_payload_13: bitstring = encode(encode_alg_14, ams_payload_4) in
  let ams_id_13: t_AMS_ID = buildAMS_id2(ams_pid2) in
  let ams_header_13: t_AMS_Header = buildAMS_Header(false, AUTH, encode_alg_14, SID0, comp_OFF, Init_IND) in
  let alg_ID_V: t_AMS_AlgID = algo(MAClen_4, HMAC_SHA256, AES128_CFB128) in
  let AMS_Init_IND_prefix: bitstring = buildAMS_msg_prefix_Init(ams_id_13, ams_header_13, encoded_payload_13, alg_ID_V, tV_2) in
  let TBP_AMS_Init_IND: bitstring = buildMAC_arg(V, U, AMS_Init_IND_prefix) in
  let MAC0_V: t_SHA256_out = MAC(K_UV, TBP_AMS_Init_IND) in
  let AMS_Init_IND: bitstring = build_msg_Init(AMS_Init_IND_prefix, MAC0_V) in
  event send_Init_IND(AMS_Init_IND, tV_2);
  out(c_ground_initiated_trigger2[i_11], AMS_Init_IND)
) | (
  ! i_12 <= Nground_init_react
  in(c_aircraft_react_ground_initiated_trigger1[i_12], (tU_5: t_AMS_Time, AMS_Init_IND_1: bitstring));
  let build_msg_Init(AMS_Init_IND_prefix_1: bitstring, MAC0_V_1: t_SHA256_out) = AMS_Init_IND_1 in
  let buildAMS_msg_prefix_Init(ams_id_14: t_AMS_ID, ams_header_14: t_AMS_Header, encoded_payload_14: bitstring, alg_ID_V_1: t_AMS_AlgID, tV_3: t_AMS_Time) = AMS_Init_IND_prefix_1 in
  if check_time(tV_3, tU_5) then
  let buildAMS_Header(R1_8: bool, =AUTH, encode_alg_15: t_encode_algo, sid_9: t_SID, compression_5: t_comp_algo, =Init_IND) = ams_header_14 in
  let ams_payload_5: bitstring = decode(encode_alg_15, encoded_payload_14) in
  let payload_with_1_element(buildAMS40_entity_id(=U, =V)) = ams_payload_5 in
  let TBP_AMS_Init_IND_1: bitstring = buildMAC_arg(V, U, AMS_Init_IND_prefix_1) in
  if MAC0_V_1 = MAC(K_UV, TBP_AMS_Init_IND_1) then
  event recv_Init_IND(AMS_Init_IND_1, tV_3, tU_5);
  out(c_aircraft_react_ground_initiated_trigger1[i_12], ())
))



(* EXPECTED
All queries proved.
48.012s (user 47.848s + system 0.164s), max rss 671056K
END *)
