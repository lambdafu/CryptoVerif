(* The proof now fails.
The problem occurred between 13 and 14 August 2011, at version 1.327
of src/cryptotransf.ml.

The change made in cryptotransf.ml changes the order in which expressions
are checked.

In version 1.326, one checks first xH[!_96] = exp2(ga_106, b)
so b in the game gets mapped to y in the equivalence, and the transformation
succeeds.
In version 1.327, one checks first (exp(g, mult(b, a)) = xH[@i_131]).
Out of bad luck, this is mapped to (z = exp(g, mult(x, y)))
in the equivalence, by mapping b to x and a to y.
The transformation then fails, because one needs to map 
b to y and a to x.

The formalization of CDH in the library of primitives avoids this
problem: it works both with b mapped to x and a to y,
and with b mapped to y and a to x.
With that formalization, one does not need to backtrack over the
mapping of names when the transformation later fails, as we
would need with the equivalence given in this file.
*) 


(* Signed Diffie-Hellman protocol *)

param n, q, nH, N, N2, nCDH, nCDH', n1, n2, n3.

type host.
type keyseed [large,fixed].
type seed [fixed].
type pkey [bounded].
type skey [bounded].
type blocksize.
type signature.

type Z [fixed].
type G.
type K [large,fixed].
type D [fixed].

fun exp(G,Z): G.
fun exp1(G,Z): G.
fun exp2(G,Z): G.
const g:G.

fun mult(Z,Z): Z.
equation builtin commut(mult).

(* exponents multiply *)

equation forall a:G, x:Z, y:Z;
  exp1(exp2(a,x), y) = exp(a, mult(x,y)).
equation forall a:G, x:Z, y:Z;
  exp2(exp1(a,x), y) = exp(a, mult(x,y)).

(* the CDH assumption *) 

proba pCDH.
(*
equiv
    !n new x:Z; new y:Z; (
      () -> exp(g,x), 
      () -> exp(g,y), 
      (z:G) nCDH -> z = exp(g, mult(x,y)),
      (z:G, m:G) n1 -> z = exp(m,x),
      (z:G, m:G) n2 -> z = exp(m,y),
      (m:G, m':G) n3 -> exp(m,x) = exp(m',y)
 )
<=(pCDH(time,n,nCDH))=>
    !n new x:Z; new y:Z; (
      () -> exp(g,x), 
      () -> exp(g,y), 
      (z:G) nCDH -> false,
      (z:G, m:G) n1 -> z = exp(m,x),
      (z:G, m:G) n2 -> z = exp(m,y),
      (m:G, m':G) n3 -> exp(m,x) = exp(m',y)
 ).

This does not work for two reasons:
1) a and b both get mapped to x (or perhaps both to y), as CryptoVerif
does not know a priori whether exp(g,x) or exp(g,y) should be used.
2) the fact that mult is commutative is not fully taken into account:
since the mapping z = exp(g, mult(x,y)) succeeds apparently,
the mapping z = exp(g, mult(y,x)) is not tried, but the transformation
will later fail when we check that the mappings of several expressions
are compatible.
These two problems could be considered bugs in the transformation mechanism,
since not all possibilities are considered. 
20/12/2009: PROBLEMS NOW FIXED, the equivalence above works.

The equivalence below solves these problems.
*)


equiv
  ! n new x: Z; new y: Z; (
    gen_Oracle() := return(exp1(g,x)) |
    gen_Oracle_1() := return(exp2(g,y)) |
    ! nCDH gen_Oracle_2(z: G) := return(z = exp(g, mult(x,y))) |
    ! nCDH' gen_Oracle_3(z: G) := return(z = exp(g, mult(y,x))) |
    ! n1 gen_Oracle_4(z: G, m: G) := return(z = exp1(m,x)) |
    ! n2 gen_Oracle_5(z: G, m: G) := return(z = exp2(m,y)) |
    ! n3 gen_Oracle_6(m: G, m': G) := return(exp1(m,x) = exp2(m',y)))
<=(pCDH(time,n,nCDH+nCDH'))=>
  ! n new x: Z; new y: Z; (
    gen_Oracle() := return(exp(g,x)) |
    gen_Oracle_1() := return(exp(g,y)) |
    ! nCDH gen_Oracle_2(z: G) := return(false) |
    ! nCDH' gen_Oracle_3(z: G) := return(false) |
    ! n1 gen_Oracle_4(z: G, m: G) := return(z = exp(m,x)) |
    ! n2 gen_Oracle_5(z: G, m: G) := return(z = exp(m,y)) |
    ! n3 gen_Oracle_6(m: G, m': G) := return(exp(m,x) = exp(m',y))).


(* h in the random oracle model *)

fun h(K,G): D.

equiv
  ! n new k: K; ! nH gen_Oracle_1(x: G) := return(h(k,x))
<=(0)=>
  ! n new k: K; ! nH gen_Oracle_1(x: G) := find j <= nH suchthat defined(x[j], r[j]) && (x= x[j]) then return(r[j]) else new r: D; return(r).

(* signatures *)

fun concatA(host, host, G, G):blocksize [data].
fun concatB(host, host, G, G):blocksize [data].
equation forall x:host, y:host, z:G, t:G, x':host, y':host, z':G, t':G;
   concatA(x,y,z,t) <> concatB(x',y',z',t').
    
proba Psign.
proba Psigncoll.

expand UF_CMA_signature(keyseed, pkey, skey, blocksize, signature, seed, skgen, pkgen, sign, check, Psign, Psigncoll).

const A,B:host.

(* query *)
query secret keyA.
query secret keyB.

channel start, cstart, cA1, cA2, cA3, cA4, cA5, cA6, cB1, cB2, cB3, cB4, cB5, cH, cHret, cK.







process
	in(start, ());
new k_1: K;
new rkA: keyseed;
let skA: skey = skgen(rkA) in
let pkA: pkey = pkgen(rkA) in
new rkB: keyseed;
let skB: skey = skgen(rkB) in
let pkB: pkey = pkgen(rkB) in
out(cstart, (pkA, pkB));
((
  in(cA1, hostB: host);
  new a: Z;
  let ga: G = exp1(g, a) in
  out(cA2, (A, hostB, ga));
  in(cA3, (=A, =hostB, gb_1: G, s_1: signature));
  if hostB = B then
  (
    if check(concatB(A, hostB, ga, gb_1), pkB, s_1) then
    new r2_2: seed;
    let gab: G = exp1(gb_1, a) in
    let kA: D = h(k_1, gab) in
    out(cA4, sign(concatA(A, hostB, ga, gb_1), skA, r2_2));
    in(cA5, ());
    let keyA: D = kA
  )
  else
    new r2_3: seed;
    let gab_1: G = exp1(gb_1, a) in
    let kA_1: D = h(k_1, gab_1) in
    out(cA4, sign(concatA(A, hostB, ga, gb_1), skA, r2_3));
    in(cA5, ());
    out(cA6, kA_1)
) | (
  in(cB1, (hostA: host, =B, ga_1: G));
  new b: Z;
  let gb_2: G = exp2(g, b) in
  new r1_1: seed;
  out(cB2, (hostA, B, gb_2, sign(concatB(hostA, B, ga_1, gb_2), skB, r1_1)));
  in(cB3, s_2: signature);
  if hostA = A then
  (
    if check(concatA(hostA, B, ga_1, gb_2), pkA, s_2) then
    let gab_2: G = exp2(ga_1, b) in
    let kB: D = h(k_1, gab_2) in
    let keyB: D = kB
  )
  else
    let gab_3: G = exp2(ga_1, b) in
    let kB_1: D = h(k_1, gab_3) in
    out(cB4, kB_1)
) | (
  ! i_1 <= nH
  in(cH[i_1], xH: G);
  out(cHret[i_1], h(k_1, xH))
))



(* DESIRED
All queries proved.
0.116s (user 0.104s + system 0.012s), max rss 0K
END
EXPECTED
RESULT Could not prove secrecy of keyB; secrecy of keyA.
0.076s (user 0.076s + system 0.000s), max rss 12740K
END *)
