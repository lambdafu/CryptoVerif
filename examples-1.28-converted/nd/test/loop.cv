(* THis example loops and it should not. Fixed 7/6/2010 *)

def DDH_loop(G, Z, g, exp, mult, pDDH) {

fun exp(G,Z): G.
fun exp'(G,Z): G.
const g:G.

fun mult(Z,Z): Z. 
equation commut(mult).

(* exponents multiply *)

forall a:G, x:Z, y:Z;
  exp(exp(a,x), y) = exp(a, mult(x,y)).

(* injectivity *)

forall x:Z, y:Z; (exp(g,x) = exp(g,y)) = (x = y).
forall x:Z, y:Z; (exp'(g,x) = exp'(g,y)) = (x = y).

(* collision between products *)

fun mult'(Z,Z): Z. 
equation commut(mult').
collision new x1: Z; new x2: Z; new x3: Z; new x4: Z; return(mult(x1,x2) = mult(x3,x4)) <=(1/|Z|)=> return((x1 = x3 && x2 = x4) || (x1 = x4 && x2 = x3) || ((x1 = x2 || x3 = x4) && mult'(x1,x2) = mult'(x3,x4))). 

(* replace a random group element with an exponentiation, and conversely *)

param N, N'.

equiv
  ! N new X: G; (
    OX() := return(X) |
    ! N' OXm(m: Z) [useful_change] := return(exp(X,m)))
<=(0)=>
  ! N new x: Z; (
    OX() := return(exp(g,x)) |
    ! N' OXm(m: Z) := return(exp(g,mult(x,m)))).

(* This equivalence is very general, apply it only manually, because
   otherwise it might be applied too often.  The equivalence above is
   particular case applied only when X is inside exp, and good for
   automatic proofs. *)

equiv
  ! N new X: G; OX() := return(X)
<=(0)=> [manual]
  ! N new x: Z; OX() := return(exp(g,x)).


equiv
  ! N new x: Z; OX() := return(exp(g,x))
<=(0)=>
  ! N new X: G; OX() := return(X).

equiv
  ! N new x: Z; OX() := return(exp'(g,x))
<=(0)=>
  ! N new X: G; OX() := return(X).

(* the DDH assumption *) 

const mark: bitstring.

param na, naDH, nb, nbDH.

equiv
  ! na new a: Z; (
    OA() := return(exp(g,a)) |
    Oa() [3] := return(a) |
    ! naDH ODHa(j <= nb) [useful_change] := return(exp(g, mult(b[j], a))))|
  ! nb new b: Z; (
    OB() := return(exp(g,b)) |
    Ob() [3] := return(b) |
    ! nbDH ODHb(j <= na) := return(exp(g, mult(a[j], b))))
<=((#ODHa + #ODHb) * max(1, 7.4*#Oa) * max(1, 7.4*#Ob) * pDDH(time + (na + nb + #ODHa + #ODHb) * time(exp)))=>
  ! na new a: Z; (
    OA() := return(exp(g,a)) |
    Oa() := return(a) |
    ! naDH ODHa(j <= nb) := return(exp(g, mult(b[j], a))))|
  ! nb new b: Z; (
    OB() := return(exp(g,b)) |
    Ob() := return(b) |
    ! nbDH ODHb(j <= na) := return(exp(g, mult(a[j], b)))).

}

(* Signed Diffie-Hellman protocol *)

param N, N2.

type host.
type keyseed [large,fixed].
type seed [fixed].
type pkey [bounded].
type skey [bounded].
type blocksize.
type signature.

type Z [large,fixed].
type G [large,fixed].
type K [large,fixed].
type D [fixed].

(* the DDH assumption *) 

proba pDDH.

expand DDH_loop(G, Z, g, exp, mult, pDDH).

(* h entropy extractor *)

proba pH.
fun h(G):D.

equiv
  ! N new x: G; OH() := return(h(x))
<=(N * pH(time + (N-1)*time(h)))=>
  ! N new X: D; OH() := return(X).


(* signatures *)

fun concatA(host, host, G, G):blocksize [data].
fun concatB(host, host, G, G):blocksize [data].
forall x:host, y:host, z:G, t:G, x':host, y':host, z':G, t':G;
   concatA(x,y,z,t) <> concatB(x',y',z',t').
    
proba Psign.
proba Psigncoll.

expand UF_CMA_signature(keyseed, pkey, skey, blocksize, signature, seed, skgen, pkgen, sign, check, Psign, Psigncoll).

const A,B:host.

(* query *)
query secret keyA.
query secret keyB.

event endA(host, host, G, G).
event beginB(host, host, G, G).
event endB(host, host, G, G).

query y: G, x: G;
  inj-event(endA(A, B, x, y)) ==> inj-event(beginB(A, B, x, y)) public_vars keyA, keyB.
query y: G, x: G;
  inj-event(endB(A, B, x, y)) ==> inj-event(endA(A, B, x, y)) public_vars keyA, keyB.

channel start, cstart, cA1, cA2, cA3, cA4, cA5, cA6, cB1, cB2, cB3, cB4, cB5, cH, cHret, cK.







process
	in(start, ());
new rkA: keyseed;
let skA: skey = skgen(rkA) in
let pkA: pkey = pkgen(rkA) in
new rkB: keyseed;
let skB: skey = skgen(rkB) in
let pkB: pkey = pkgen(rkB) in
out(cstart, (pkA, pkB));
((
  ! i_1 <= N
  in(cA1[i_1], hostB: host);
  new a_1: Z;
  let ga: G = exp(g, a_1) in
  out(cA2[i_1], (A, hostB, ga));
  in(cA3[i_1], (=A, =hostB, gb_1: G, s_1: signature));
  find j2_3 = j2_1 <= N2 suchthat defined(Khost[j2_1], Rkey[j2_1]) && (Khost[j2_1] = hostB) then
  let pkhostB: pkey = Rkey[j2_3] in
  if check(concatB(A, hostB, ga, gb_1), pkhostB, s_1) then
  new r2_1: seed;
  let gab: G = exp(gb_1, a_1) in
  let kA: D = h(gab) in
  event endA(A, hostB, ga, gb_1);
  out(cA4[i_1], sign(concatA(A, hostB, ga, gb_1), skA, r2_1));
  in(cA5[i_1], ());
  if hostB = B then
  (
    let keyA: D = kA
  )
  else
    out(cA6[i_1], kA)
) | (
  ! i_2 <= N
  in(cB1[i_2], (hostA: host, =B, ga_1: G));
  new b_1: Z;
  let gb_2: G = exp(g, b_1) in
  new r1_1: seed;
  event beginB(hostA, B, ga_1, gb_2);
  out(cB2[i_2], (hostA, B, gb_2, sign(concatB(hostA, B, ga_1, gb_2), skB, r1_1)));
  in(cB3[i_2], s_2: signature);
  find j2_4 = j2_2 <= N2 suchthat defined(Khost[j2_2], Rkey[j2_2]) && (Khost[j2_2] = hostA) then
  let pkhostA: pkey = Rkey[j2_4] in
  if check(concatA(hostA, B, ga_1, gb_2), pkhostA, s_2) then
  let gab_1: G = exp(ga_1, b_1) in
  let kB: D = h(gab_1) in
  event endB(hostA, B, ga_1, gb_2);
  if hostA = A then
  (
    let keyB: D = kB
  )
  else
    out(cB4[i_2], kB)
) | (
  ! i_3 <= N2
  in(cK[i_3], (Khost: host, Kkey: pkey));
  let Rkey: pkey = (if Khost = B then pkB else if Khost = A then pkA else Kkey)
))




(* EXPECTED
RESULT Could not prove secrecy of keyB; secrecy of keyA.
0.164s (user 0.152s + system 0.012s), max rss 50224K
END *)
