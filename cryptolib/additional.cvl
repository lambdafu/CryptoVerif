def CDH_single(G, Z, g, exp, exp', mult, pCDH) {

(* the CDH assumption *) 

param na, naDDH, naDH9.

event square.

equiv(cdh(exp))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach iaDDH <= naDDH do ODDHa(m:G, j<=na) [useful_change] := return(m = exp(g, mult(a[j], a))) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) [2] := return(exp(g, mult(a, x)))
    )
<=(naDDH * na * (na-1) * pCDH(time + (na + #ODDHa - 3) * time(exp)))=> [computational]
    foreach ia <= na do a <-R Z [unchanged]; (
      OA() := return(exp'(g,a)) |
      Oa() := let ka:bool = true in return(a) |
      foreach iaDDH <= naDDH do ODDHa(m:G, j<=na) :=
      	      if defined(ka[j]) then return(m = exp'(g, mult(a[j], a))) else
              if defined(ka) then return(m = exp'(g, mult(a[j], a))) else
              if j = ia then event_abort square else
	      return(false) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) := return(exp'(g, mult(a, x)))
    ).

}

def CDH_RSR_single(G, Z, g, exp, exp', mult, pCDH, pDistRerandom) {

(* the CDH assumption *) 

param na, naDDH, naDH9.

event square.

equiv(cdh(exp))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach iaDDH <= naDDH do ODDHa(m:G, j<=na) [useful_change] :=
      	      return(m = exp(g, mult(a[j], a))) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) [2] := return(exp(g, mult(a, x)))
    )
<=(2* #ODDHa * max(1, 27/4*#Oa*#Oa) * pCDH(time + (na + #ODDHa + 1) * time(exp)) + na * pDistRerandom)=> [computational]
    foreach ia <= na do a <-R Z [unchanged]; (
      OA() := return(exp'(g,a)) |
      Oa() := let ka:bool = true in return(a) |
      foreach iaDDH <= naDDH do ODDHa(m:G, j<=na) := 
      	      if defined(ka[j]) then return(m = exp'(g, mult(a[j], a))) else 
              if defined(ka) then return(m = exp'(g, mult(a[j], a))) else
              if j = ia then event_abort square else
	      return(false) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) := return(exp'(g, mult(a, x)))
    ).

}

def DDH_single(G, Z, g, exp, exp', mult, pDDH) {

(* the DDH assumption *) 

event ev_abort.
event square.

param na, naDH, naDH9.

table dhval(na, na, G).

equiv(ddh(exp))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return (a) |
      foreach iaDH <= naDH do ODHa(j<=na) [useful_change] := return (exp(g, mult(a[j], a))) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) [2] := return(exp(g, mult(a, x)))
    )
<=(na*(na-1)/2 * pDDH(time + (na + #ODHa - 3) * time(exp)))=>
    foreach ia <= na do a <-R Z; (
      OA() := return(exp'(g,a)) |
      Oa() :=
      	 get dhval(=ia, j, c) in event_abort ev_abort else
         let ka:bool = true in return(a) |
      foreach iaDH <= naDH do ODHa(j<=na) :=
	 if defined(ka[j]) then return(exp'(g, mult(a[j], a))) else 
         if defined(ka) then return(exp'(g, mult(a[j], a))) else
         if j = ia then event_abort square else
	 get[unique] dhval(=ia, =j, c) in return(c) else
	 ca <-R G;
	 insert dhval(ia, j, ca);
	 insert dhval(j, ia, ca);
	 return(ca) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) := return(exp'(g, mult(a, x)))
    ).

}


def GDH_single(G, Z, g, exp, exp', mult, pGDH) {

(* the square GDH assumption 
    This equivalence says that, when exp(g,a[i]) are known to the
    adversary, the adversary can compute exp(g, mult(a[i], a[j])) only with
    negligible probability, even in the presence of a DDH oracle
    DDH(G,A,B,C) tells whether A = G^a, B = G^b, and C = G^{ab} for some a,b,
    that is DDH(G,A,B,C) is (log_G(A) * log_G(B) = log_G(C)). *)

param na, naDDH, naDDH1, naDDH2, naDDH3, naDDH4, naDDH5, naDH9.

equiv(gdh(exp))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach iaDDH3 <= naDDH3 do ODDHa3(m:G, m':G,j<=na) := return(exp(m,a[j]) = exp(m', a)) |
      foreach iaDDH5 <= naDDH5 do ODDHa5(m:G, j'<=na,j<=na) [useful_change] := return(exp(m,a[j]) = exp(g, mult(a[j'], a))) |
      foreach iaDDH1 <= naDDH1 do ODDHa1(m:G, m':G) := return(m = exp(m', a)) |
      foreach iaDDH  <= naDDH  do ODDHa(m:G, j<=na) [useful_change] := return(m = exp(g, mult(a[j], a))) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) [2] := return(exp(g, mult(a, x)))
    ) 
<=(na * (na-1)/2 * pGDH(time + na * time(exp), #ODDHa + #ODDHa1 + #ODDHa3 + #ODDHa5))=> [computational]
    foreach ia <= na do a <-R Z [unchanged]; (
      OA() := return(exp'(g,a)) |
      Oa() := let ka:bool = true in return(a) |
      foreach iaDDH3 <= naDDH3 do ODDHa3(m:G, m':G,j<=na) := return(exp'(m,a[j]) = exp'(m', a)) |
      	   (* GDH allows to compute exp(m, a[j]) = exp(m',a) for any m and m', 
	      without leaking a, as it is DDH(exp(g,a), exp(g,a[j]), m, m')
	      Indeed, 
    	      D(exp(g,a),exp(g,a[j]),m,m') 
      	        = (log_{g^a}(g^a[j]) * log_{g^a}(m) = log_{g^a}(m'))
      		= (a[j]/a * log_g(m)/a = log_g(m')/a)
      		= (a[j] * log_g(m) = a log_g(m'))
      		= (m^a[j] = m'^a). *)
      foreach iaDDH5 <= naDDH5 do ODDHa5(m:G, j'<=na,j<=na) :=
      	      if defined(ka[j']) then return(exp'(m,a[j]) = exp'(g, mult(a[j'], a))) else
	      if defined(ka) then return(exp'(m,a[j]) = exp'(g, mult(a[j'], a))) else
	      return ((j = ia || j = j' || j' = ia) && exp'(m,a[j]) = exp'(g, mult(a[j'], a))) |
	    (* GDH always allows to compute exp(m, a[j]) = exp(g,mult(a[j'],a))
	       as a particular case of ODDHa2.
	       When a or a[j'] is leaked, that is all we use and we keep the value
	       that occurs in the left-hand side exp'(m, a[j]) = exp'(g,mult(a[j'],a)).
	       Otherwise, we distinguish two cases:
	       - When j = ia || j = j' || j' = ia, we keep the value
	       that occurs in the left-hand side exp'(m, a[j]) = exp'(g,mult(a[j'],a)).
	       - Otherwise, we apply the CDH assumption considering an adversary
	         that knows a[j] and computes exp(m, a[j]). This adversary cannot
	         compute exp(g,mult(a[j'],a)) by CDH, so the equality 
	         exp(m, a[j]) = exp(g,mult(a[j'],a)) is false in this case.
	       Hence, the equality exp(m, a[j]) = exp(g,mult(a[j'],a))
	       reduces to (j = ia || j = j' || j' = ia) && exp'(m, a[j]) = exp'(g,mult(a[j'],a)). *)
      foreach iaDDH1 <= naDDH1 do ODDHa1(m:G, m':G) := 
	      return(m = exp'(m', a))
		(* GDH allows to compute m = exp(m',a) for any m and m', without leaking a,
		   as it is DDH(g, exp(g,a), m', m) *) |
      foreach iaDDH <= naDDH do ODDHa(m:G, j<=na) := 
      	      if defined(ka[j]) then return(m = exp'(g, mult(a[j], a))) else 
              if defined(ka) then return(m = exp'(g, mult(a[j], a))) else
	      return(j = ia && m = exp'(g, mult(a[j], a))) |
            (* ODDHa is a particular case of ODDHa1 in which can apply the CDH assumption,
	       provided a and a[j] are not leaked. *)
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) := return(exp'(g, mult(a, x)))
    ).
    (* We need to consider both forms m = exp(m', a) and m = exp(g,
    mult(a[j], a)) in the equivalence, because, when m' is known to be
    exp(g, a[j]), CryptoVerif is going to simplify m = exp(m', a) into
    m = exp(g, mult(a[j], a)), and the procedure that tests whether a
    term in the game matches a term in the equivalence would not
    recognize that m = exp(g, mult(a[j], a)) in the game matches m =
    exp(m', a) in the equivalence. *)
}

def GDH_RSR_single(G, Z, g, exp, exp', mult, pGDH, pDistRerandom) {

(* the square GDH assumption 
    This equivalence says that, when exp(g,a[i]) are known to the
    adversary, the adversary can compute exp(g, mult(a[i], a[j])) only with
    negligible probability, even in the presence of a DDH oracle
    DDH(G,A,B,C) tells whether A = G^a, B = G^b, and C = G^{ab} for some a,b,
    that is DDH(G,A,B,C) is (log_G(A) * log_G(B) = log_G(C)). *)

param na, naDDH, naDDH1, naDDH2, naDDH3, naDDH4, naDDH5, naDH9.

equiv(gdh(exp))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach iaDDH3 <= naDDH3 do ODDHa3(m:G, m':G,j<=na) := return(exp(m,a[j]) = exp(m', a)) |
      foreach iaDDH5 <= naDDH5 do ODDHa5(m:G, j'<=na,j<=na) [useful_change] := return(exp(m,a[j]) = exp(g, mult(a[j'], a))) |
      foreach iaDDH1 <= naDDH1 do ODDHa1(m:G, m':G) := return(m = exp(m', a)) |
      foreach iaDDH  <= naDDH  do ODDHa(m:G, j<=na) [useful_change] := return(m = exp(g, mult(a[j], a))) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) [2] := return(exp(g, mult(a, x)))
    ) 
<=(2* max(1, 27/4*(#Oa-max(-1,-#ODDHa5))*(#Oa-max(-1,-#ODDHa5))) * 
	   pGDH(time + (na+1) * time(exp),
	   #ODDHa + #ODDHa1 + #ODDHa3 + #ODDHa5) + na * pDistRerandom)=> [computational]
    foreach ia <= na do a <-R Z [unchanged]; (
      OA() := return(exp'(g,a)) |
      Oa() := let ka:bool = true in return(a) |
      foreach iaDDH3 <= naDDH3 do ODDHa3(m:G, m':G,j<=na) := return(exp'(m,a[j]) = exp'(m', a)) |
      	   (* GDH allows to compute exp(m, a[j]) = exp(m',a) for any m and m', 
	      without leaking a, as it is DDH(exp(g,a), exp(g,a[j]), m, m')
	      Indeed, 
    	      D(exp(g,a),exp(g,a[j]),m,m') 
      	        = (log_{g^a}(g^a[j]) * log_{g^a}(m) = log_{g^a}(m'))
      		= (a[j]/a * log_g(m)/a = log_g(m')/a)
      		= (a[j] * log_g(m) = a log_g(m'))
      		= (m^a[j] = m'^a). *)
      foreach iaDDH5 <= naDDH5 do ODDHa5(m:G, j'<=na,j<=na) :=
      	      if defined(ka[j']) then return(exp'(m,a[j]) = exp'(g, mult(a[j'], a))) else
	      if defined(ka) then return(exp'(m,a[j]) = exp'(g, mult(a[j'], a))) else
	      return ((j = ia || j = j' || j' = ia) && exp'(m,a[j]) = exp'(g, mult(a[j'], a))) |
	    (* GDH always allows to compute exp(m, a[j]) = exp(g,mult(a[j'],a))
	       as a particular case of ODDHa2.
	       When a or a[j'] is leaked, that is all we use and we keep the value
	       that occurs in the left-hand side exp'(m, a[j]) = exp'(g,mult(a[j'],a)).
	       Otherwise, we distinguish two cases:
	       - When j = ia || j = j' || j' = ia, we keep the value
	       that occurs in the left-hand side exp'(m, a[j]) = exp'(g,mult(a[j'],a)).
	       - Otherwise, we apply the CDH assumption considering an adversary
	         that knows a[j] and computes exp(m, a[j]). This adversary cannot
	         compute exp(g,mult(a[j'],a)) by CDH, so the equality 
	         exp(m, a[j]) = exp(g,mult(a[j'],a)) is false in this case.
	       Hence, the equality exp(m, a[j]) = exp(g,mult(a[j'],a))
	       reduces to (j = ia || j = j' || j' = ia) && exp'(m, a[j]) = exp'(g,mult(a[j'],a)). *)
      foreach iaDDH1 <= naDDH1 do ODDHa1(m:G, m':G) := 
	      return(m = exp'(m', a))
		(* GDH allows to compute m = exp(m',a) for any m and m', without leaking a,
		   as it is DDH(g, exp(g,a), m', m) *) |
      foreach iaDDH <= naDDH do ODDHa(m:G, j<=na) := 
      	      if defined(ka[j]) then return(m = exp'(g, mult(a[j], a))) else 
              if defined(ka) then return(m = exp'(g, mult(a[j], a))) else
	      return(j = ia || m = exp'(g, mult(a[j], a))) | 
            (* ODDHa is a particular case of ODDHa1 in which can apply the CDH assumption,
	       provided a and a[j] are not leaked. *)
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) := return(exp'(g, mult(a, x)))
    ).
    (* We need to consider both forms m = exp(m', a) and m = exp(g,
    mult(a[j], a)) in the equivalence, because, when m' is known to be
    exp(g, a[j]), CryptoVerif is going to simplify m = exp(m', a) into
    m = exp(g, mult(a[j], a)), and the procedure that tests whether a
    term in the game matches a term in the equivalence would not
    recognize that m = exp(g, mult(a[j], a)) in the game matches m =
    exp(m', a) in the equivalence. *)
}


def PRF_ODH1_single(G, Z, prf_in, prf_out, g, exp, exp', mult, prf, pPRF_ODH) {

fun prf(G, prf_in): prf_out.

(* The PRF-ODH1 assumption *)

event ev_abort.
event square.

param na, na1, na2, naDH9.

table prf_dh_val(na, na, prf_in, prf_out).

equiv(prf_odh(prf))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) [useful_change] := return(prf(exp(g, mult(a[ja], a)), xa2)) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) [2] := return(exp(g, mult(a, x)))
    )
<=(na*(na-1)/2 * pPRF_ODH(time + (na + #Oa2 - 3)*time(exp) + (#Oa2 - 1) * time(prf, maxlength(xa2)), 2*na2))=>
    foreach ia <= na do a <-R Z; (
      OA() := return(exp'(g,a)) |
      Oa() :=
      	 (* Abort when a must not be compromised *)
         get prf_dh_val(=ia, ja, x, c) in event_abort ev_abort else
         let ka:bool = true in return(a) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) :=
	 if defined(ka[ja]) then (* a[ja] compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
         if defined(ka) then (* a compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
	 if ja = ia then event_abort square else
	 (* At this point, a and a[ja] are not compromised, and must never be compromised in the future *)
	 get[unique] prf_dh_val(=ia, =ja, =xa2, c) in return(c) else
         ca2 <-R prf_out;
	 insert prf_dh_val(ia, ja, xa2, ca2);
	 insert prf_dh_val(ja, ia, xa2, ca2);
	 return(ca2) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) := return(exp'(g, mult(a, x)))
    ).
	 
}


def PRF_ODH2_single(G, Z, prf_in, prf_out, g, exp, exp', mult, prf, pPRF_ODH) {

fun prf(G, prf_in): prf_out.

(* The PRF-ODH2 assumption *)

event ev_abort.

param na, na1, na2, naDH9.

table prf_dh_val(na, na, prf_in, prf_out).

equiv(prf_odh(prf))
    foreach ia <= na do a <-R Z; (
      OA() := return(exp(g,a)) | 
      Oa() [10] := return(a) |
      foreach ia1 <= na1 do Oa1(ma1:G, xa1:prf_in) := return(prf(exp(ma1, a), xa1)) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) [useful_change] := return(prf(exp(g, mult(a[ja], a)), xa2)) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) [2] := return(exp(g, mult(a, x)))
    )
<=(na*(na-1)/2 * pPRF_ODH(time + (na + #Oa1 + #Oa2 - 3)*time(exp) +
      (#Oa1 + #Oa2 - 1) * time(prf, max(maxlength(xa1), maxlength(xa2))), 2*na2, 2*na1))=>
    foreach ia <= na do a <-R Z; (
      OA() := return(exp'(g,a)) |
      Oa() :=
      	 (* Abort when a must not be compromised *)
         get prf_dh_val(=ia, ja, x, c) in event_abort ev_abort else
         let ka:bool = true in return(a) |
      foreach ia1 <= na1 do Oa1(ma1:G, xa1:prf_in) :=
      	 find j' <= na suchthat defined(a[j']) && ma1 = exp'(g, a[j']) then
	 (
	    (* In this case, that's the same as Oa2 *)
	    if defined(ka[j']) then (* a[j'] compromised *) return(prf(exp'(ma1, a), xa1)) else
            if defined(ka) then (* a compromised *) return(prf(exp'(ma1, a), xa1)) else
	    if j' = ia then (* square *) return(prf(exp'(ma1, a), xa1)) else
	    (* At this point, a and a[j'] are not compromised, and must never be compromised in the future *)
	    get[unique] prf_dh_val(=ia, =j', =xa1, c) in return(c) else
	    ca1 <-R prf_out;
	    insert prf_dh_val(ia, j', xa1, ca1);
	    insert prf_dh_val(j', ia, xa1, ca1);
	    return(ca1)
	 )
	 else
	    return(prf(exp'(ma1, a), xa1)) |
      foreach ia2 <= na2 do Oa2(ja <= na, xa2: prf_in) :=
	 if defined(ka[ja]) then (* a[ja] compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
         if defined(ka) then (* a compromised *) return(prf(exp'(g, mult(a[ja], a)), xa2)) else
	 if ja = ia then return(prf(exp'(g, mult(a[ja], a)), xa2)) else
	 (* At this point, a and a[ja] are not compromised, and must never be compromised in the future *)
	 get[unique] prf_dh_val(=ia, =ja, =xa2, c) in return(c) else
         ca2 <-R prf_out;
	 insert prf_dh_val(ia, ja, xa2, ca2);
	 insert prf_dh_val(ja, ia, xa2, ca2);
	 return(ca2) |
      foreach iaDH9 <= naDH9 do ODHa9(x:Z) := return(exp'(g, mult(a, x)))
    ).
	 
}

